/**
 * @preserve Joel Espinosa Longi
 * jlongi@im.unam.mx
 * https://github.com/jlongi/DescartesJS
 * LGPL - http://www.gnu.org/licenses/lgpl.html
 * 2019-02-08
 */

/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var babel = (function(babel) {
  if (babel.loadLib) { return babel; }

  babel.loadLib = true;
 
// ñ -> \u00F1
// á -> \u00E1
// é -> \u00E9
// í -> \u00ED
// ó -> \u00F3
// ú -> \u00FA

//  babel["espa\u00F1ol"] = babel["english"] = babel["catal\u00E0"] = babel["euskera"] = babel["fran\u00E7ais"] = babel["galego"] = babel["portugu\u00EAs"] = babel["valenci\u00E0"] = "";
  babel["falso"] = babel["false"] = babel["fals"] = babel["gezurra"] = babel["faux"] = babel["fals"] = "false";
  babel["verdadero"] = babel["true"] = babel["veritable"] = babel["egia"] = babel["vrai"] = babel["verdadeiro"] = babel["veritable"] = "true";
  babel["no"] = babel["ez"] = babel["non"] = babel["n\u00E3o"] = "false";
  babel["s\u00ED"] = babel["yes"] = babel["bai"] = babel["oui"] = babel["si"] = babel["sim "] = "true";
  babel["negro"] = babel["black"] = babel["negre"] = babel["beltza"] = babel["noir"] = babel["preto"] = babel["#000000"] = "#000000";
  babel["maxenta"] = babel["magenta"] = babel["#ff00ff"] = "#ff00ff";
  babel["azul"] = babel["blue"] = babel["blau"] = babel["urdina"] = babel["bleu"] = babel["#0000ff"] = "#0000ff";
  babel["turquesa"] = babel["cyan"] = babel["turkesa"] = babel["turquoise"] = babel["#00ffff"] = "#00ffff";
  babel["verde"] = babel["green"] = babel["verd"] = babel["berdea"] = babel["vert"] = babel["#00ff00"] = "#00ff00";
  babel["amarillo"] = babel["yellow"] = babel["groc"] = babel["horia"] = babel["jaune"] = babel["amarelo"] = babel["#ffff00"] = "#ffff00";
  babel["naranja"] = babel["orange"] = babel["taronja"] = babel["laranja"] = babel["laranxa"] = babel["#ffc800"] = "#ffc800";
  babel["rojo"] = babel["red"] = babel["vermell"] = babel["gorria"] = babel["rouge"] = babel["vermello"] = babel["vermelho"] = babel["#ff0000"] = "#ff0000";
  babel["pink"] = babel["rosa"] = babel["arrosa"] = babel["rose"] = babel["#ffafaf"] = "#ffafaf";
  babel["grisObscuro"] = babel["darkGray"] = babel["grisFosc"] = babel["gris iluna"] = babel["grisObscur"] = babel["grisEscuro"] = babel["cinzaEscuro"] = babel["#404040"] = "#404040";
  babel["gris"] = babel["gray"] = babel["grisa"] = babel["cinza"] = babel["#808080"] = "#808080";
  babel["grisClaro"] = babel["lightGray"] = babel["grisClar"] = babel["gris argia"] = babel["grisClair"] = babel["cinzaClaro"] = babel["#c0c0c0"] = "#c0c0c0";
  babel["blanco"] = babel["white"] = babel["blanc"] = babel["zuria"] = babel["branco"] = babel["#ffffff"] = "#ffffff";
  babel["escala"] = babel["scale"] = babel["eskala"] = babel["\u00E9chelle"] = "scale";
//  babel["Se puede copiar este texto y pegarlo en una p\u00E1gina Web."] = babel["You may copy this text and paste it on a Web page."] = babel["Podeu copiar aquest text i enganxar-lo en una p\u00E0gina web."] = babel["Testu hau kopia dezakezu eta web orri batean itsasi."] = babel["Vous pouvez copier ce texte et l'accrocher en une page web."] = babel["Pode copiar este texto e pegalo nunha p\u00E1xina Web."] = babel["Voc\u00EA pode copiar este texto e col\u00E1-lo em uma p\u00E1gina WEB."] = babel["Podeu copiar aquest text i enganxar-lo en una p\u00E0gina web."] = "";
  babel["nombre"] = babel["name"] = babel["nom"] = babel["izena"] = babel["nome"] = "name";
//  babel["editable"] = babel["editable"] = babel["editable"] = babel["editagarria"] = babel["editable"] = babel["editable"] = babel["modific\u00E1vel"] = babel["editable"] = "";
  babel["ikusgai"] = babel["vis\u00EDvel"] = babel["visible"] = "visible";
  babel["rastro"] = babel["trace"] = babel["rastre"] = babel["arrastoa"] = "trace";
//   babel["control"] = babel["control"] = babel["control"] = babel["kontrola"] = babel["contr\u00F4le"] = babel["control"] = babel["controle"] = babel["control"] = "";
  babel["fondo"] = babel["background"] = babel["fons"] = babel["hondoa"] = babel["fond"] = babel["fundo"] = "background";

  babel["par\u00E1metro"] = babel["parameter"] = babel["parametroa"] = babel["par\u00E2metro"] = babel["par\u00E0metre"] = "parameter";
  babel["sucesi\u00F3n"] = babel["sequence"] = babel["successi\u00F3"] = babel["segida"] = babel["succession"] = babel["seq\u00FC\u00EAncia"] = "sequence";
  babel["tama\u00F1o"] = babel["size"] = babel["neurria"] = babel["taille"] = babel["tamanho"] = babel["grand\u00E0ria"] = "size";
  babel["decimales"] = babel["decimals"] = babel["hamartarra"] = babel["d\u00E9cimales"] = babel["decimais"] = "decimals";
  babel["red"] = babel["net"] = babel["xarxa"] = babel["sarea"] = babel["r\u00E9seau"] = babel["rede"] = babel["malha"] = "net";
  babel["red10"] = babel["net10"] = babel["xarxa10"] = babel["sarea10"] = babel["r\u00E9seau10"] = babel["rede10"] = babel["malha10"] = "net10";
  babel["ejes"] = babel["axes"] = babel["eixos"] = babel["ardatzak"] = babel["eixes"] = "axes";
  babel["texto"] = babel["text"] = babel["testua"] = babel["texte"] = "text";
  //////////////////////////////
  // configuration buttons
  //////////////////////////////
  babel["cr\u00E9ditos"] = babel["about"] = babel["cr\u00E8dits"] = babel["kreditoak"] = babel["cr\u00E9dits"] = babel["sobre"] = "about";
  babel["config"] = babel["konfig"] = babel["configura\u00E7\u00E3o"] = "config";
  // babel["inicio"] = babel["init"] = babel["inici"] = babel["hasiera"] = babel["commencement"] = babel["in\u00EDcio"] = "init";
  babel["limpiar"] = babel["clear"] = babel["neteja"] = babel["ezabatu"] = babel["nettoye"] = babel["limpar"] = "clear";
  //////////////////////////////
  babel["incr"] = babel["gehi"] = babel["incremento"] = "incr";
  babel["min"] = babel["inf"] = "min";
  babel["max"] = babel["sup"] = babel["m\u00E1x"] = "max";
  babel["relleno"] = babel["fill"] = babel["ple"] = babel["betea"] = babel["plein"] = babel["recheo"] = babel["preencher"] = "fill";
  babel["relleno+"] = babel["fill+"] = babel["ple+"] = babel["betea+"] = babel["plein+"] = babel["recheo+"] = babel["preencher+"] = babel["fillP"] = "fillP";
  babel["relleno-"] = babel["fill-"] = babel["ple-"] = babel["betea-"] = babel["plein-"] = babel["recheo-"] = babel["preencher-"] = babel["fillM"] = "fillM";
  babel["flecha"] = babel["arrow"] = babel["fletxa"] = babel["gezia"] = babel["fl\u00E8che"] = babel["frecha"] = babel["seta"] = "arrow";
  babel["ancho"] = babel["width"] = babel["ample"] = babel["zabalera"] = babel["large"] = babel["largura"] = "width";
  babel["punta"] = babel["spear"] = babel["muturra"] = babel["pointe"] = babel["ponta"] = "spear";
  babel["regi\u00F3n"] = babel["region"] = babel["regi\u00F3"] = babel["eskualde"] = babel["r\u00E9gion"] = babel["rexi\u00F3n"] = babel["regi\u00E3o"] = "region";
  babel["norte"] = babel["north"] = babel["nord"] = babel["ipar"] = "north";
  babel["sur"] = babel["south"] = babel["sud"] = babel["hego"] = babel["sul"] = "south";
  babel["este"] = babel["east"] = babel["est"] = babel["ekialde"] = babel["leste"] = "east";
  babel["oeste"] = babel["west"] = babel["oest"] = babel["hegoalde"] = babel["ouest"] = "west";
  babel["exterior"] = babel["external"] = babel["kanpoalde"] = babel["externo"] = "external";
  babel["expresi\u00F3n"] = babel["expresion"] = babel["expresi\u00F3"] = babel["adierazpen"] = babel["express\u00E3o"] = "expresion";
  babel["tipo"] = babel["type"] = babel["tipus"] = babel["mota"] = "type";
  babel["posici\u00F3n"] = babel["position"] = babel["posici\u00F3"] = babel["posizio"] = babel["posi\u00E7\u00E3o"] = "position";
  babel["constricci\u00F3n"] = babel["constraint"] = babel["constricci\u00F3"] = babel["beharte"] = babel["constriction"] = babel["constrici\u00F3n"] = babel["restri\u00E7\u00E3o"] = "constraint";
//  babel["infinito"] = babel["infinity"] = babel["infinit"] = babel["infinitu"] = babel["infini"] = babel["infinito"] = babel["infinito"] = babel["infinit"] = "";
  babel["valor"] = babel["value"] = babel["balio"] = babel["valeur"] = "value";
  babel["ecuaci\u00F3n"] = babel["equation"] = babel["equaci\u00F3"] = babel["ekuazio"] = babel["\u00E9quation"] = babel["equa\u00E7\u00E3o"] = "equation";
  babel["curva"] = babel["curve"] = babel["corba"] = babel["kurba"] = babel["courbe"] = "curve";
  babel["texto"] = babel["text"] = babel["testu"] = babel["texte"] = "text";
  babel["punto"] = babel["point"] = babel["punt"] = babel["puntu"] = babel["ponto"] = "point";
  babel["segmento"] = babel["segment"] = babel["zuzenki"] = "segment";
  babel["arco"] = babel["arc"] = babel["arku"] = "arc";
  babel["pol\u00EDgono"] = babel["polygon"] = babel["pol\u00EDgon"] = babel["poligono"] = babel["polygone"] = "polygon";
  babel["imagen"] = babel["image"] = babel["imatge"] = babel["irudi"] = babel["imaxe"] = babel["imagem"] = "image";
  babel["Versi\u00F3n"] = babel["Version"] = babel["Versi\u00F3"] = babel["Vers\u00E3o"] = babel["version"] = "version";
  babel["Idioma"] = babel["Language"] = babel["Hizkuntza"] = babel["Langue"] = babel["language"] = "language";
//  babel["Espacio"] = babel["Space"] = babel["Espai"] = babel["Espazioa"] = babel["Espace"] = babel["Espazo"] = babel["Espa\u00E7o"] = babel["Espai"] = "";
  babel["O.x"] = "O.x";
  babel["O.y"] = "O.y";
//  babel["Controles"] = babel["Controls"] = babel["Controls"] = babel["Kontrolak"] = babel["Contr\u00F4les"] = babel["Controis"] = babel["Controles"] = babel["Controls"] = "";
//  babel["Auxiliares"] = babel["Auxiliaries"] = babel["Auxiliars"] = babel["Laguntzaile"] = babel["Auxiliaires"] = babel["Auxiliares"] = babel["Auxiliares"] = babel["Auxiliars"] = "";
//  babel["Gr\u00E1ficos"] = babel["Graphics"] = babel["Gr\u00E0fics"] = babel["Grafikoak"] = babel["Graphiques"] = babel["Gr\u00E1ficos"] = babel["Gr\u00E1ficos"] = babel["Gr\u00E0fics"] = "";
  babel["Botones"] = babel["Buttons"] = babel["Botons"] = babel["Botoiak"] = babel["Boutons"] = babel["Bot\u00F3ns"] = babel["Bot\u00F5es"] = babel["Botons"] = "Buttons";
  babel["Animaci\u00F3n"] = babel["Animation"] = babel["Animaci\u00F3"] = babel["Animazio"] = babel["Anima\u00E7\u00E3o"] = "Animation";
  babel["constante"] = babel["constant"] = babel["Konstante"] = "constant";
//  babel["original"] = babel["original"] = babel["original"] = babel["jatorrizkoa"] = babel["original"] = babel["orixinal"] = babel["original"] = babel["original"] = "";
//  babel["nueva"] = babel["new"] = babel["nova"] = babel["berria"] = babel["nouvelle"] = babel["novo"] = babel["novo"] = babel["nova"] = "";
//  babel["aplicar"] = babel["apply"] = babel["aplica"] = babel["ezarri"] = babel["appliquer"] = babel["aplicar"] = babel["aplicar"] = babel["aplica"] = "";
//  babel["cerrar"] = babel["close"] = babel["tanca"] = babel["itxi"] = babel["fermer"] = babel["pechar"] = babel["fechar"] = babel["tanca"] = "";
//  babel["cancelar"] = babel["cancel"] = babel["anul·la"] = babel["baliogabetu"] = babel["annuler"] = babel["cancelar"] = babel["cancelar"] = babel["anul·la"] = "";
//  babel["aceptar"] = babel["ok"] = babel["accepta"] = babel["onartu"] = babel["accepter"] = babel["aceptar"] = babel["ok"] = babel["accepta"] = "";
//  babel["agregar"] = babel["add"] = babel["afegeix"] = babel["erantsi"] = babel["ajouter"] = babel["engadir"] = babel["acrescentar"] = babel["afegeix"] = "";
//  babel["insertar"] = babel["insert"] = babel["insereix"] = babel["tartekatu"] = babel["ins\u00E9rer"] = babel["inserir"] = babel["inserir"] = babel["insereix"] = "";
//  babel["eliminar"] = babel["delete"] = babel["elimina"] = babel["kendu"] = babel["\u00E9liminer"] = babel["eliminar"] = babel["apagar"] = babel["elimina"] = "";
//  babel["arriba"] = babel["up"] = babel["amunt"] = babel["gora"] = babel["en haut"] = babel["arriba"] = babel["acima"] = babel["amunt"] = "";
//  babel["abajo"] = babel["down"] = babel["avall"] = babel["behera"] = babel["en bas"] = babel["abaixo"] = babel["abaixo"] = babel["avall"] = "";
//  babel["renombrar"] = babel["rename"] = babel["reanomenar"] = babel["berrizendatu"] = babel["r\u00E9appeler"] = babel["renomear"] = babel["renomear"] = babel["reanomenar"] = "";
//  babel["auxiliar"] = babel["auxiliary"] = babel["auxiliar"] = babel["laguntzaile"] = babel["auxiliaire"] = babel["auxiliar"] = babel["auxiliar"] = babel["auxiliar"] = "";
  babel["fuente"] = babel["font"] = babel["iturri"] = babel["source"] = babel["fonte"] = "font";
//  babel["deshacer"] = babel["undo"] = babel["desf\u00E9s"] = babel["desegin"] = babel["d\u00E9faire"] = babel["desfacer"] = babel["desfazer"] = babel["desf\u00E9s"] = "";
//  babel["rehacer"] = babel["redo"] = babel["ref\u00E9s"] = babel["berregin"] = babel["refaire"] = babel["refacer"] = babel["refazer"] = babel["ref\u00E9s"] = "";
  babel["num\u00E9rico"] = babel["numeric"] = babel["num\u00E8ric"] = babel["zenbakizko"] = babel["num\u00E9rique"] = "numeric";
  babel["gr\u00E1fico"] = babel["graphic"] = babel["gr\u00E0fic"] = babel["grafiko"] = babel["graphique"] = "graphic";
// babel["texto"] = babel["text"] = babel["testu"] = babel["texte"] = "text";
//  babel["pos"] = babel["pos"] = babel["pos"] = babel["pos"] = babel["pos"] = babel["pos"] = babel["pos"] = babel["pos"] = "";
  babel["inicio"] = babel["init"] = babel["inici"] = babel["hasiera"] = babel["commencement"] = babel["in\u00EDcio"] = "init";
  babel["hacer"] = babel["do"] = babel["fer"] = babel["egin"] = babel["faire"] = babel["facer"] = babel["fazer"] = babel["doExpr"] = "doExpr";
  babel["mientras"] = babel["while"] = babel["mentre"] = babel["bitartean"] = babel["tandis que"] = babel["mentres"] = babel["enquanto"] = babel["whileExpr"] = "whileExpr";
  babel["evaluar"] = babel["evaluate"] = babel["avalua"] = babel["ebaluatu"] = babel["\u00E9valuer"] = babel["avaliar"] = "evaluate";
  babel["variable"] = babel["aldagaia"] = babel["vari\u00E1vel"] = "variable";
  babel["funci\u00F3n"] = babel["function"] = babel["funci\u00F3"] = babel["funtzio"] = babel["fonction"] = babel["fun\u00E7\u00E3o"] = "function";
  babel["algoritmo"] = babel["algorithm"] = babel["algorisme"] = babel["algorithme"] = "algorithm";
  babel["vector"] = babel["array"] = babel["bektore"] = babel["vecteur"] = babel["matriz"] = "array";
//  babel["zoom"] = babel["zoom"] = babel["zoom"] = babel["zoom"] = babel["zoom"] = babel["zoom"] = babel["zoom"] = babel["zoom"] = "";
  babel["dibujar-si"] = babel["draw-if"] = babel["marraztu-baldin"] = babel["dessiner-si"] = babel["debuxar-se"] = babel["desenhar-se"] = babel["dibuixa-si"] = babel["drawif"] = "drawif";
  babel["dominio"] = babel["range"] = babel["domini"] = babel["izate-eremua"] = babel["domain"] = babel["dom\u00EDnio"] = "range";
  babel["pausa"] = babel["delay"] = babel["eten"] = "delay";
//  babel["detener"] = babel["stop"] = babel["atura"] = babel["geldiarazi"] = babel["arr\u00EAter"] = babel["deter"] = babel["parar"] = babel["atura"] = "";
  babel["eje-x"] = babel["x-axis"] = babel["eix-x"] = babel["x-ardatza"] = babel["axe-x"] = babel["eixe-x"] = babel["eixo-x"] = babel["x_axis"] = "x_axis";
  babel["eje-y"] = babel["y-axis"] = babel["eix-y"] = babel["y-ardatza"] = babel["axe-y"] = babel["eixe-y"] = babel["eixo-y"] = babel["y_axis"] = "y_axis";
  babel["n\u00FAmeros"] = babel["numbers"] = babel["nombres"] = babel["zenbakiak"] = "numbers";
  babel["exponencial-si"] = babel["exponential-if"] = babel["esponentzial-baldin"] = babel["exponentiel-si"] = babel["exponencial-se"] = babel["exponentialif"] = "exponentialif";
  babel["familia"] = babel["family"] = babel["fam\u00EDlia"] = babel["famille"] = "family";
  babel["intervalo"] = babel["interval"] = babel["tarte"] = babel["intervalle"] = "interval";
  babel["pasos"] = babel["steps"] = babel["passos"] = babel["pausoak"] = babel["pas"] = "steps";
  babel["centro"] = babel["center"] = babel["centre"] = babel["zentro"] = "center";
  babel["radio"] = babel["radius"] = babel["radi"] = babel["erradio"] = babel["rayon"] = babel["raio"] = "radius";
  babel["fin"] = babel["end"] = babel["fi"] = babel["bukaera"] = babel["fim"] = "end";
  babel["una-sola-vez"] = babel["only-once"] = babel["una-sola-vegada"] = babel["behin-bakarrik"] = babel["une-seule-fois"] = babel["unha-soa-vez"] = babel["apenas-uma-vez"] = babel["onlyOnce"] = "onlyOnce";
  babel["siempre"] = babel["always"] = babel["sempre"] = babel["beti"] = babel["toujours"] = "always";
//  babel["copiar"] = babel["copy"] = babel["copia"] = babel["kopiatu"] = babel["copier"] = babel["copiar"] = babel["copiar"] = babel["copia"] = "";
//  babel["pegar"] = babel["paste"] = babel["enganxa"] = babel["itsatsi"] = babel["accrocher"] = babel["pegar"] = babel["colar"] = babel["enganxa"] = "";
  babel["color-int"] = babel["int-colour"] = babel["barruko-kolore"] = babel["couleur-int"] = babel["cor-int"] = babel["colorInt"] = "colorInt";
  babel["repetir"] = babel["loop"] = babel["repeteix"] = babel["errepikatu"] = babel["r\u00E9p\u00E9ter"] = "loop";
  babel["controles"] = babel["controls"] = babel["kontrolak"] = babel["contr\u00F4les"] = babel["controis"] = "controls";
//  babel["c\u00F3digo"] = babel["<applet>"] = babel["</*applet*/>"] = babel["<applet>"] = babel["<applet>"] = babel["c\u00F3digo"] = babel["<applet>"] = babel["<applet>"] = "";
//  babel["Esta versi\u00F3n no permite editar."] = babel["Runtime only. No editing allowed."] = babel["Nom\u00E9s execuci\u00F3. Aquesta versi\u00F3 no permet l'edici\u00F3"] = babel["Bertsio honek ez du editatzen uzten."] = babel["Seulement ex\u00E9cution. Cette version ne permet pas l'\u00E9dition."] = babel["Esta versi\u00F3n non permite editar."] = babel["Somente para execu\u00E7\u00E3o. N\u00E3o \u00E9 poss\u00EDvel editar o c\u00F3digo."] = babel["Nom\u00E9s execuci\u00F3. Aquesta versi\u00F3 no permet l'edici\u00F3"] = "" ;
  babel["animar"] = babel["animate"] = babel["anima"] = babel["animatu"] = babel["animer"] = "animate";
//  babel["pausa"] = babel["pause"] = babel["pausa"] = babel["eten"] = babel["pause"] = babel["pausa"] = babel["pausa"] = babel["pausa"] = "";
  babel["auto"] = "auto";
  babel["alto"] = babel["height"] = babel["alt"] = babel["altu"] = babel["haut"] = babel["altura"] = "height";
  babel["x"] = babel["left"] = "x";
  babel["y"] = babel["top"] = "y";
  babel["espacio"] = babel["space"] = babel["espai"] = babel["espazio"] = babel["espace"] = babel["espazo"] = babel["espa\u00E7o"] = "space";
  babel["Nu"] = "Nu";
  babel["Nv"] = "Nv";
  babel["ancho"] = babel["depth"] = babel["amplada"] = babel["zabalera"] = babel["largeur"] = babel["ancho"] = babel["profundidade"] = babel["amplada"] = babel["width"] = "width";
  babel["largo"] = babel["length"] = babel["llargada"] = babel["luzera"] = babel["longueur"] = babel["longo"] = babel["comprimento"] = babel["llargada"] = "length";
  babel["alto"] = babel["height"] = babel["al\u00E7ada"] = babel["altu"] = babel["hauteur"] = babel["alto"] = babel["altura"] = babel["al\u00E7ada"] = "height";
  babel["color_reverso"] = babel["backcolor"] = babel["color_revers"] = babel["atzealde kolorea"] = babel["couleur_revers"] = babel["cor_reverso"] = babel["cor_de_fundo"] = "backcolor";
  babel["aristas"] = babel["edges"] = babel["arestes"] = babel["ertzak"] = babel["ar\u00EAtes"] = babel["arestas"] = "edges";
  babel["rotini"] = babel["inirot"] = "inirot";
  babel["posini"] = babel["inipos"] = "inipos";
  babel["tri\u00E1ngulo"] = babel["triangle"] = babel["hirukia"] = babel["tri\u00E2ngulo"] = "triangle";
  babel["cara"] = babel["face"] = babel["aurpegi"] = "face";
  babel["polireg"] = babel["regpoly"] = babel["pol\u00EDgonoRegular"] = "polireg";
  babel["superficie"] = babel["surface"] = babel["superf\u00EDcie"] = babel["azalera"] = "surface";
  babel["cubo"] = babel["cube"] = babel["cub"] = babel["kubo"] = "cube";
  babel["paralelep\u00edpedo"] = babel["box"] = babel["paral·lelep\u00edpede"] = babel["paralelepipedo"] = babel["parall\u00e9l\u00e9pip\u00e8de"] = "box";
  babel["cono"] = babel["cone"] = babel["con"] = babel["kono"] = babel["c\u00f4ne"] = "cone";
  babel["cilindro"] = babel["cylinder"] = babel["cilindre"] = babel["zilindro"] = babel["cylindre"] = "cylinder";
  babel["esfera"] = babel["sphere"] = babel["sph\u00e8re"] = "sphere";
  babel["tetraedro"] = babel["tetrahedron"] = babel["tetraedre"] = babel["t\u00e9tra\u00e8dre"] = "tetrahedron";
  babel["octaedro"] = babel["octahedron="] = babel["octaedre"] = babel["oktaedro"] = babel["octa\u00e8dre"] = "octahedron";
  babel["dodecaedro"] = babel["dodecahedron"] = babel["dodecaedre"] = babel["dodekaedro"] = babel["dod\u00e9ca\u00e8dre"] = "dodecahedron";
  babel["icosaedro"] = babel["icosahedron"] = babel["icosaedre"] = babel["ikosaedro"] = babel["icosa\u00e8dre"] = "icosahedron";
  babel["elipsoide"] = babel["ellipsoid"] = babel["el·lipsoide"] = babel["ellipso\u00efde"] = babel["elips\u00f3ide"] = "ellipsoid";
  babel["macro"] = babel["makro"] = "macro";
  babel["id"] = "id";
  babel["modelo"] = babel["model"] = babel["eredu"] = babel["mod\u00E8le"] = "model";
  babel["color"] = babel["kolore"] = babel["couleur"] = babel["cor"] = babel["colour"] = babel["kolorea"] = "color";

  babel["luz"] = babel["light"] = babel["llum"] = babel["argia"] = babel["lumi\u00E8re"] = "light";
  babel["metal"] = babel["metall"] = babel["m\u00E9tal"] = "metal";
  babel["alambre"] = babel["wire"] = babel["filferro"] = babel["alanbre"] = babel["fil de fer"] = babel["arame"] = "wire";

  babel["cortar"] = babel["split"] = babel["talla"] = babel["moztu"] = babel["couper"] = babel["dividir"] = "split";
  babel["despliegue"] = babel["render"] = babel["desplegament"] = babel["zabaltze"] = babel["d\u00E8ploiement"] = babel["despregamento"] = babel["processar"] = "render";
  babel["orden"] = babel["sort"] = babel["ordre"] = babel["ordena"] = babel["orde"] = babel["ordenar"] = "sort";
  babel["pintor"] = babel["painter"] = babel["margolari"] = babel["peintre"] = "painter";
  babel["trazado de rayos"] = babel["ray trace"] = babel["tra\u00E7at de raigs"] = babel["izpi trazadura"] = babel["trace de rayons"] = babel["trazado de raios"] = babel["tra\u00E7ado de raios"] = babel["raytrace"] = "raytrace";
  babel["imagen"] = babel["bg_image"] = babel["imatge"] = babel["irudia"] = babel["imaxe"] = babel["imagem_de_fundo"] = babel["image"] = "image";
  babel["despl_imagen"] = babel["bg_display"] = babel["despl_imatge"] = babel["irudi desplazamendu"] = babel["despl_image"] = babel["despr_imaxe"] = babel["apresenta\u00E7\u00E3o_de_imagem"] = "bg_display";
  babel["arr-izq"] = babel["topleft"] = babel["dalt-esq"] = babel["goi-ezk"] = babel["au-dessus-gau"] = babel["arr-esq"] = babel["acima-esquerda"] = "topleft";
  babel["expand."] = babel["stretch"] = babel["hedatu"] = babel["expandir "] = "stretch";
  babel["mosaico"] = babel["patch"] = babel["mosaic"] = babel["mosaiko"] = babel["mosa\u00EFque"] = "patch";
  babel["centrada"] = babel["zentratu"] = babel["centr\u00E9e"] = babel["centrado"] = "imgcenter";
  babel["archivo"] = babel["file"] = babel["fitxer"] = babel["artxibo"] = babel["fichier"] = babel["arquivo"] = "file";
//   babel["loc"] = babel["loc"] = babel["lloc"] = babel["lok"] = babel["lieu"] = babel["loc"] = babel["loc"] = babel["lloc"] = "";
//   babel["rot"] = babel["rot"] = babel["gir"] = babel["rot"] = babel["tour"] = babel["rot"] = babel["rot"] = babel["gir"] = "";
//   babel["macro"] = babel["macro"] = babel["macro"] = babel["makro"] = babel["macro"] = babel["macro"] = babel["macro"] = babel["macro"] = "";
  babel["tipo_de_macro"] = babel["macro_type"] = babel["tipus_de_macro"] = babel["makro_mota"] = babel["type_de_macro"] = babel["tipo_de_macro"] = babel["tipo_de_macro"] = babel["tipus_de_macro"] = "macro_type";
//   babel["Poniendo este texto en un archivo <nombre> en el subdirectorio macros/g2d/ se crea la macro <nombre>"] = babel["Puting this text in a file <name> in subdirectory macros/g2d/ creates the macro <name>"] = babel["Posant aquest text en un fitxer <nom> en el subdirectori macros/g2d/ es crea la macro <nom>"] = babel["Artxibo batean testu hau jarriz <izena> macros/g2d/ izeneko azpidirektorioan"] = babel["En mettant ce texte dans un fichier <nom> dans le sous-r\u00E9pertoire macros/g2d/ la macro <nom> est cr\u00E9e "] = babel["Po\u00F1endo este texto nun arquivo <nombre> no subdirectorio macros/g2d/ cr\u00E9ase a macro <nombre>"] = babel["Colocando este texto num arquivo <nome> no subdiret\u00F3rio macros/g2d/ voc\u00EA criar\u00E1 a macro <nome>"] = babel["Posant aquest text en un fitxer <nom> en el subdirectori macros/g2d/ es crea la macro <nom>"] = "";
//   babel["codigo HTML"] = babel["HTML encoding"] = babel["codi HTML"] = babel[" <izena>duen makroa sortzen da"] = babel["code HTML"] = babel["c\u00F3digo HTML"] = babel["codigo HTML"] = babel["codi HTML"] = "";
  babel["filas_norte"] = babel["rows_north"] = babel["files_nord"] = babel["HTML kodea"] = babel["files_nord"] = babel["filas_norte"] = babel["linhas_norte"] = babel["files_nord"] = babel["rowsNorth"] = "rowsNorth";
  babel["filas_sur"] = babel["rows_south"] = babel["files_sud"] = babel["ipar_lerro"] = babel["files_sud"] = babel["filas_sur"] = babel["linhas_sul"] = babel["files_sud"] = babel["rowsSouth"] = "rowsSouth";
  babel["ancho_este"] = babel["width_east"] = babel["ample_est"] = babel["hego_lerro"] = babel["ample_est"] = babel["ancho_leste"] = babel["largura_leste"] = babel["ample_est"] = babel["widthEast"] = "widthEast";
  babel["ancho_oeste"] = babel["width_west"] = babel["ample_oest"] = babel["ekialde_zabalera"] = babel["ample_ouest"] = babel["ancho_oeste"] = babel["largura_oeste"] = babel["ample_oest"] = babel["widthWest"] = "widthWest";
  babel["fijo"] = babel["fixed"] = babel["fix"] = babel["hegoalde_zabalera"] = babel["fixe"] = babel["fixo"] = "fixed";
  babel["Reiniciar Animaci\u00F3n"] = babel["Init Animation"] = babel["Reinicia Animaci\u00F3"] = babel["finko"] = babel["Recommencer l'Animation"] = babel["Reiniciar Anima\u00E7\u00E3o"] = babel["initAnimation"] = "initAnimation";
//   babel["emergente"] = babel["pop"] = babel["emergent"] = babel["Animazioa bberrabiatu"] = babel["\u00E9mergent"] = babel["emerxente"] = babel["pop"] = babel["emergent"] = "";
//   babel[" "] = babel[" "] = babel[" "] = babel["azaleratzaile"] = babel[" "] = babel["00:"] = babel["  "] = babel[" "] = "";
//   babel["="] = babel["="] = babel["="] = babel["="] = babel["="] = babel["="] = babel["="] = babel["="] = "";
  babel["Explicaci\u00F3n"] = babel["Explanation"] = babel["Azalpena"] = babel["Explication"] = babel["Explica\u00E7\u00E3o"] = babel["Explicaci\u00F3"] = "Explanation";
//   babel["gr\u00E1ficos 3D"] = babel["graphics 3D"] = babel["gr\u00E0fics 3D"] = babel["3d grafikoak"] = babel["graphiques 3D"] = babel["gr\u00E1ficos 3D"] = babel["gr\u00E1ficos 3D"] = babel["gr\u00E0fics 3D"] = "";
//   babel["?"] = babel["?"] = babel["?"] = babel["?"] = babel["?"] = babel["?"] = babel["?"] = babel["?"] = "";
  babel["tooltip"] = babel["dica"] = "tooltip";
//   babel["clic derecho"] = babel["right click"] = babel["clic dret"] = babel["lik eskuina"] = babel["clic droit"] = babel["clic dereito"] = babel["clique com o bot\u00E3o direito"] = babel["clic dret"] = "";
  babel["discreto"] = babel["discrete"] = babel["discret"] = babel["diskretu"] = "discrete";
  babel["interfaz"] = babel["gui"] = babel["interf\u00EDcie"] = babel["interfaze"] = babel["interface"] = "gui";
  babel["pulsador"] = babel["spinner"] = babel["polsador"] = babel["pultsadore"] = babel["bouton"] = "spinner";
  babel["campo de texto"] = babel["textfield"] = babel["camp de text"] = babel["testu esarrua"] = babel["champ de texte"] = "textfield";
  babel["men\u00FA"] = babel["choice"] = babel["menu"] = babel["escolha"] = "menu";
  babel["barra"] = babel["scrollbar"] = babel["barre"] = "scrollbar";
  babel["opciones"] = babel["options"] = babel["opcions"] = babel["aukerak"] = babel["opci\u00F3ns"] = babel["op\u00E7\u00F5es"] = "options";
  babel["interior"] = babel["barruko"] = babel["int\u00E9rieur"] = "interior";
  babel["condici\u00F3n"] = babel["condition"] = babel["condici\u00F3"] = babel["baldintza"] = babel["condi\u00E7\u00E3o"] = "condition";
  babel["acci\u00F3n"] = babel["action"] = babel["acci\u00F3"] = babel["ekintza"] = babel["a\u00E7\u00E3o"] = "action";
  babel["evento"] = babel["event"] = babel["esdeveniment"] = babel["gertaera"] = babel["\u00E9v\u00E9nement"] = "event";
  babel["abrir URL"] = babel["open URL"] = babel["obre URL"] = babel["URL zabaldu"] = babel["ouvrir URL"] = babel["openURL"] = "openURL";
  babel["abrir Escena"] = babel["open Scene"] = babel["obre Escena"] = babel["eszena zabaldu"] = babel["ouvrir Escena"] = babel["abrir Cena"] = babel["openScene"] = "openScene";
  babel["bot\u00F3n"] = babel["button"] = babel["bot\u00F3"] = babel["botoi"] = babel["bouton"] = babel["bot\u00E3o"] = "button";
  babel["mensaje"] = babel["message"] = babel["mezua"] = babel["mensaxe"] = babel["mensagem"] = babel["missatge"] = "message";
  babel["alternar"] = babel["alternate"] = babel["alterna"] = babel["txandakatu"] = babel["alterner"] = "alternate";
  babel["ejecuci\u00F3n"] = babel["execution"] = babel["execuci\u00F3"] = babel["gauzatze"] = babel["ex\u00E9cution"] = babel["execuci\u00F3n"] = babel["execu\u00E7\u00E3o"] = "execution";
  babel["calcular"] = babel["calculate"] = babel["calcula"] = babel["kalkulatu"] = babel["calculer"] = "calculate";
//   babel["s\u00EDmbolo"] = babel["symbol"] = babel["s\u00EDmbol"] = babel["sinbolo"] = babel["symbole"] = babel["s\u00EDmbolo"] = babel["s\u00EDmbolo"] = babel["s\u00EDmbol"] = "";
//   babel["UNIDAD"] = babel["UNIT"] = babel["UNITAT"] = babel["UNITATE"] = babel["UNIT\u00C9"] = babel["UNIDADE"] = babel["UNIDADE"] = babel["UNITAT"] = "";
//   babel["CURSO"] = babel["COURSE"] = babel["CURS"] = babel["IKASTAROA"] = babel["COURS"] = babel["CURSO"] = babel["CURSO"] = babel["CURS"] = "";
//   babel["animado"] = babel["animated"] = babel["animat"] = babel["animatu"] = babel["anim\u00E9"] = babel["animado"] = babel["animado"] = babel["animat"] = "";
//   babel["frecuencia"] = babel["frequency"] = babel["freq\u00FC\u00E8ncia"] = babel["maiztasun"] = babel["fr\u00E9quence"] = babel["frecuencia"] = babel["freq\u00FC\u00EAncia"] = babel["freq\u00FC\u00E8ncia"] = "";
  babel["coord_abs"] = babel["abs_coord"] = babel["koor_abs"] = "abs_coord";
//   babel["Editor de F\u00F3rmulas"] = babel["Formula Editor"] = babel["Editor de F\u00F2rmules"] = babel["Formula-editore"] = babel["\u00C9diteur de Formules"] = babel["Editor de F\u00F3rmulas"] = babel["Editor de F\u00F3rmulas"] = babel["Editor de F\u00F2rmules"] = "";
//   babel["Editor de Textos"] = babel["Text Editor"] = babel["Editor de Textos"] = babel["Testu-editore"] = babel["\u00C9diteur de Textes"] = babel["Editor de Textos"] = babel["Editor de Textos"] = babel["Editor de Textos"] = "";
//   babel["s\u00EDmbolos"] = babel["symbols"] = babel["s\u00EDmbols"] = babel["sinboloak"] = babel["symboles"] = babel["s\u00EDmbolos"] = babel["s\u00EDmbolos"] = babel["s\u00EDmbols"] = "";
//   babel["fracci\u00F3n"] = babel["fraction"] = babel["fracci\u00F3"] = babel["zatiki"] = babel["fraction"] = babel["fracci\u00F3n"] = babel["fra\u00E7\u00E3o"] = babel["fracci\u00F3"] = "";
//   babel["ra\u00EDz cuadrada"] = babel["square Root"] = babel["arrel quadrada"] = babel["erro karratu"] = babel["racine carr\u00E9e"] = babel["ra\u00EDz cadrada"] = babel["raiz quadrada"] = babel["arrel quadrada"] = "";
//   babel["sub\u00EDndice"] = babel["subindex"] = babel["sub\u00EDndex"] = babel["azpi-indize"] = babel["subindice"] = babel["sub\u00EDndice"] = babel["sub\u00EDndice"] = babel["sub\u00EDndex"] = "";
//   babel["super\u00EDndice"] = babel["superindex"] = babel["super\u00EDndex"] = babel["goi-indize"] = babel["superindice"] = babel["super\u00EDndice"] = babel["super\u00EDndice"] = babel["super\u00EDndex"] = "";
//   babel["editar"] = babel["edit"] = babel["edita"] = babel["editatu"] = babel["\u00E9diter"] = babel["editar"] = babel["editar"] = babel["edita"] = "";
//   babel["mostrar"] = babel["show"] = babel["mostra"] = babel["erakutsi"] = babel["montrer"] = babel["mostrar"] = babel["exibir"] = babel["mostra"] = "";
  babel["negrita"] = babel["bold"] = babel["negreta"] = babel["lodi"] = babel["caract\u00E8re gras"] = babel["negra"] = babel["negrito"] = "bold";
  babel["cursiva"] = babel["italics"] = babel["etzana"] = babel["italique"] = babel["it\u00E1lico"] = "italics";
  babel["subrayada"] = babel["underlined"] = babel["subratllat"] = babel["azpimarratua"] = babel["soulignement"] = babel["subli\u00F1ada"] = babel["sublinhado"] = "underlined";
//   babel["super-rayada"] = babel["overlined"] = babel["sobreratllat"] = babel["goimarratua"] = babel["surrayure"] = babel["super-raiada"] = babel["linha-superior"] = babel["sobreratllat"] = "";
//   babel["f\u00F3rmula"] = babel["formula"] = babel["f\u00F3rmula"] = babel["formula"] = babel["formule"] = babel["f\u00F3rmula"] = babel["f\u00F3rmula"] = babel["f\u00F3rmula"] = "";
//   babel["Lat\u00EDno b\u00E1sico"] = babel["Basic Latin"] = babel["Llat\u00ED b\u00E0sic"] = babel["Oinarrizko Latindarra"] = babel["Latin basique"] = babel["Lat\u00EDn b\u00E1sico"] = babel["Latim B\u00E1sico"] = babel["Llat\u00ED b\u00E0sic"] = "";
//   babel["Latino "] = babel["Latin "] = babel["Llat\u00ED 1"] = babel["Latindar "] = babel["Latin 1"] = babel["Latin "] = babel["Latim 1"] = babel["Llat\u00ED "] = "";
//   babel["Latino extendido A"] = babel["Latin Extended A"] = babel["Llat\u00ED est\u00E8s A"] = babel["Latindar zabaldua A"] = babel["Latin r\u00E9pandu A"] = babel["Latin extendido A"] = babel["Latim estendido A"] = babel["Llat\u00ED est\u00E8s A"] = "";
//   babel["Latino extendido B"] = babel["Latin Extended B"] = babel["Llat\u00ED est\u00E8s B"] = babel["Latindar zabaldua B"] = babel["Llat\u00ED r\u00E9pandu B"] = babel["Latin extendido B"] = babel["Latim estendido B"] = babel["Llat\u00ED est\u00E8s B"] = "";
//   babel["Griego b\u00E1sico"] = babel["Basic Greek"] = babel["Grec b\u00E0sic"] = babel["Oinarrizko Grekera"] = babel["Grec basique"] = babel["Grego b\u00E1sico"] = babel["Grego B\u00E1sico"] = babel["Grec b\u00E0sic"] = "";
//   babel["Cir\u00EDlico"] = babel["Cyrillic"] = babel["Cir\u00EDl·lic"] = babel["Ziriliko"] = babel["Cyrillique"] = babel["Cir\u00EDlico"] = babel["Cir\u00EDlico"] = babel["Cir\u00EDl·lic"] = "";
//   babel["Hebreo b\u00E1sico"] = babel["Basic Hebrew"] = babel["Hebreu b\u00E0sic"] = babel["Oinarrizko Hebrear"] = babel["H\u00E9breu basique"] = babel["Hebreo b\u00E1sico"] = babel["Hebreu B\u00E1sico"] = babel["Hebreu b\u00E0sic"] = "";
//   babel["\u00C1rabe b\u00E1sico"] = babel["Basic Arab"] = babel["\u00C0rab b\u00E0sic"] = babel["Oinarrizko Arabiarra"] = babel["Arabe basique"] = babel["\u00C1rabe b\u00E1sico"] = babel["\u00C1rabe B\u00E1sico"] = babel["\u00C0rab b\u00E0sic"] = "";
//   babel["Puntuaci\u00F3n general"] = babel["General Punctuation"] = babel["Puntuaci\u00F3 general"] = babel["Puntuazio orokorra"] = babel["Ponctuation g\u00E9n\u00E9rale"] = babel["Puntuaci\u00F3n xeral"] = babel["Pontua\u00E7\u00E3o Geral"] = babel["Puntuaci\u00F3 general"] = "";
//   babel["S\u00EDmbolos de moneda"] = babel["Currency Symbols"] = babel["S\u00EDmbols de moneda"] = babel["Txanpon sinboloak"] = babel["Symboles de monnaie"] = babel["S\u00EDmbolos de moeda"] = babel["S\u00EDmbolos Monet\u00E1rios"] = babel["S\u00EDmbols de moneda"] = "";
//   babel["S\u00EDmbolos tipo carta"] = babel["Letterlike Symbols"] = babel["S\u00EDmbols tipus carta"] = babel["karta motako sinboloak"] = babel["Symboles types lettre"] = babel["S\u00EDmbolos tipo carta"] = babel["S\u00EDmbolos Tipo Carta"] = babel["S\u00EDmbols tipus carta"] = "";
//   babel["Formatos de n\u00FAmeros"] = babel["Number Forms"] = babel["Formats de n\u00FAmeros"] = babel["Zenbaki formatua"] = babel["Form\u00E9s de num\u00E9ros"] = babel["Formatos de n\u00FAmeros"] = babel["Formatos de N\u00FAmeros"] = babel["Formats de n\u00FAmeros"] = "";
//   babel["Operadores matem\u00E1ticos"] = babel["Mathematical Operators"] = babel["Operadors matem\u00E0tics"] = babel["Eragile matematikoak"] = babel["Op\u00E9rateurs math\u00E9matiques"] = babel["Operadores matem\u00E1ticos"] = babel["Operadores Matem\u00E1ticos"] = babel["Operadors matem\u00E0tics"] = "";
//   babel["Bordes de cuadros"] = babel["Box Drawing"] = babel["Vores de quadres"] = babel["Koadro ertzak"] = babel["Bord de carr\u00E9s"] = babel["Bordes de cadros"] = babel["Bordas"] = babel["Vores de quadres"] = "";
//   babel["Elementos de bloque"] = babel["Block Elements"] = babel["Elements de bloc"] = babel["Blokearen elementuak"] = babel["\u00C9l\u00E9ments de bloc"] = babel["Elementos de bloque"] = babel["Elementos de Blocos"] = babel["Elements de bloc"] = "";
//   babel["S\u00EDmbolos variados"] = babel["Miscelaneous Symbols"] = babel["S\u00EDmbols variats"] = babel["Askotariko sinboloak"] = babel["Symboles vari\u00E9s"] = babel["S\u00EDmbolos variados"] = babel["S\u00EDmbolos Diversos"] = babel["S\u00EDmbols variats"] = "";
//   babel["Alfabetos Unicode"] = babel["Unicode Alphabets"] = babel["Alfabets Unicode"] = babel["Unicode alfabetoa"] = babel["Alphabets Unicode"] = babel["Alfabetos Unicode"] = babel["Alfabetos Unicode"] = babel["Alfabets Unicode"] = "";
//   babel["Base Unicode"] = babel["Unicode Base"] = babel["Base Unicode"] = babel["Unicode oina"] = babel["Base Unicode"] = babel["Base Unicode"] = babel["Unicode Base"] = babel["Base Unicode"] = "";
  babel["imagen"] = babel["image"] = babel["imatge"] = babel["irundia"] = babel["imaxe"] = babel["imagem"] = "image";
//   babel["Doc"] = babel["Doc"] = babel["Doc"] = babel["Dok"] = babel["Doc"] = babel["Doc"] = babel["Doc"] = babel["Doc"] = "";
//   babel["Aux"] = babel["Aux"] = babel["Aux"] = babel["lagunt"] = babel["Aux"] = babel["Aux"] = babel["Aux"] = babel["Aux"] = "";
//   babel["clic"] = babel["click"] = babel["clic"] = babel["klik"] = babel["clic"] = babel["clic"] = babel["clique"] = babel["clic"] = "";
  babel["pos_mensajes"] = babel["msg_pos"] = babel["pos_missatges"] = babel["mezuen_pos"] = babel["pos_messages"] = babel["pos_mensaxes"] = "msg_pos";
//   babel["arr_izq"] = babel["top_left"] = babel["dalt_esq"] = babel["goi_ezk"] = babel["au-dessus_gauche"] = babel["arr_esq"] = babel["acima_esquerda"] = babel["dalt_esq"] = "";
//   babel["arriba"] = babel["top_center"] = babel["dalt"] = babel["goian"] = babel["au-dessus"] = babel["arriba"] = babel["acima_centro"] = babel["dalt"] = "";
//   babel["arr_der"] = babel["top_right"] = babel["dalt_dreta"] = babel["goi_eskuin"] = babel["au-dessus_droite"] = babel["arr_der"] = babel["acima_direita"] = babel["dalt_dreta"] = "";
  babel["izquierda"] = babel["left"] = babel["esquerra"] = babel["eskerrean"] = babel["gauche"] = babel["esquerda"] = babel["esquerda"] = babel["esquerra"] = babel["x"] = "x";
  babel["derecha"] = babel["right"] = babel["dreta"] = babel["eskuinan"] = babel["droite"] = babel["dereita"] = babel["direita"] = babel["dreta"] = "right";
//   babel["ab_izq"] = babel["bottom_left"] = babel["avall_esq"] = babel["Behe_ezk"] = babel["en bas_gauche"] = babel["ab_esq"] = babel["abaixo_esquerda"] = babel["avall_esq"] = "";
//   babel["abajo"] = babel["bottom"] = babel["avall"] = babel["behean"] = babel["en bas"] = babel["abaixo"] = babel["abaixo"] = babel["avall"] = "";
//   babel["ab_der"] = babel["bottom_right"] = babel["avall_dreta"] = babel["behe_eskuin"] = babel["en bas_droite"] = babel["ab_der"] = babel["abaixo_direita"] = babel["avall_dreta"] = "";
//   babel["img"] = babel["img"] = babel["img"] = babel["irud"] = babel["img"] = babel["img"] = babel["img"] = babel["img"] = "";
  babel["sensible_a_los_movimientos_del_rat\u00F3n"] = babel["sensitive_to_mouse_movements"] = babel["sensible_als_moviments_del_ratol\u00ED"] = babel["xagu mugimenduarekiko sentikorra"] = babel["sensible_aux_mouvements_du_souris"] = babel["sensible_aos_movementos_do_rato"] = babel["sens\u00EDvel_aos_movimentos_do_mouse"] = "sensitive_to_mouse_movements";
  babel["reproducir"] = babel["play"] = babel["reprodueix"] = babel["erreproduzitu"] = babel["reproduire"] = babel["reproduzir"] = babel["playAudio"] = "playAudio";
//   babel["infoind"] = babel["indinfo"] = babel["infoind"] = babel["baninf"] = babel["infoind"] = babel["infoind"] = babel["infoind"] = babel["infoind"] = "";
//   babel["infoest"] = babel["statinfo"] = babel["infoest"] = babel["estinf"] = babel["infoest"] = babel["infoest"] = babel["infoest"] = babel["infoest"] = "";
  babel["activo-si"] = babel["active-if"] = babel["actiu-si"] = babel["altiboa-baldin"] = babel["actif-si"] = babel["activo-se"] = babel["ativo-se"] = babel["activeif"] = "activeif";
  babel["rotfin"] = babel["finrot"] = babel["bukrot"] = babel["endrot"] = "endrot";
  babel["posfin"] = babel["finpos"] = babel["bukpos"] = babel["endpos"] = "endpos";
  babel["editable"] = babel["editagarria"] = babel["edit\u00E1vel"] = "editable";
//   babel["camposMixtos"] = babel["mixedTF"] = babel["CampsMixtes"] = babel["esparruMistoa"] = babel["ChampsMixtes"] = babel["camposMixtos"] = babel["camposMixtos"] = babel["CampsMixtes"] = "";
//   babel["sonido"] = babel["sound"] = babel["so"] = babel["soinu"] = babel["son"] = babel["son"] = babel["som"] = babel["so"] = "";
//   babel["\u00E1lgebra"] = babel["algebra"] = babel["\u00E0lgebra"] = babel["aljebra"] = babel["alg\u00E8bre"] = babel["\u00E1lxebra"] = babel["\u00E1lgebra"] = babel["\u00E0lgebra"] = "";
//   babel["RAD"] = babel["RAD"] = babel["RAD"] = babel["RAD"] = babel["RAD"] = babel["RAD"] = babel["RAD"] = babel["RAD"] = "";
  babel["tipo"] = babel["type"] = babel["tipus"] = babel["mota"] = "type";
  babel["R2"] = "R2";
  babel["R3"] = "R3";
//   babel["TA"] = babel["TA"] = babel["TA"] = babel["TA"] = babel["TA"] = babel["TA"] = babel["TA"] = babel["TA"] = "";
//   babel["TX"] = babel["TX"] = babel["TX"] = babel["TX"] = babel["TX"] = babel["TX"] = babel["TX"] = babel["TX"] = "";
//   babel["D"] = babel["D"] = babel["D3"] = babel["D"] = babel["D3"] = babel["D"] = babel["D3"] = babel["D"] = "";
  babel["vectores"] = babel["bektoreak"] = babel["vecteurs"] = babel["vetores"] = babel["vectors"] = "vectors";
//   babel["fuente tipo"] = babel["font type"] = babel["font tipus"] = babel["iturri mota"] = babel["source type"] = babel["fonte tipo"] = babel["tipo de fonte"] = babel["font tipus"] = "";
  babel["fuente puntos"] = babel["font size"] = babel["font punts"] = babel["puntu iturria"] = babel["source points"] = babel["fonte puntos"] = babel["fonte pontos"] = babel["font_size"] = "font_size";
//   babel["SansSerif"] = "SansSerif";
//   babel["Serif"] = "Serif";
//   babel["Monoespaciada"] = babel["Monospaced"] = babel["Monoespazada"] = "Monospaced";
//   babel["\u00E1rbol"] = babel["tree"] = babel["arbre"] = babel["zuhitz"] = babel["arbre"] = babel["\u00E1rbore"] = babel["\u00E1rvore"] = babel["arbre"] = "";
//   babel["sensible"] = babel["sensible"] = babel["sensible"] = babel["sentikor"] = babel["sensible"] = babel["sensible"] = babel["sens\u00EDvel"] = babel["sensible"] = "";
//   babel["paso de l\u00EDnea"] = babel["step size"] = babel["pas de l\u00EDnia"] = babel["lerro igarotze"] = babel["pas de ligne"] = babel["paso de li\u00F1a"] = babel["passo de linha"] = babel["pas de l\u00EDnia"] = "";
//   babel["s\u00EDmbolo de multiplicaci\u00F3n"] = babel["multiplication symbol"] = babel["s\u00EDmbol del producte"] = babel["biderketa sinboloa"] = babel["symbole du produit"] = babel["s\u00EDmbolo de multiplicaci\u00F3n"] = babel["s\u00EDmbolo de multiplica\u00E7\u00E3o"] = babel["s\u00EDmbol del producte"] = "";
//   babel["par\u00E9ntesis siempre"] = babel["parenthesis always"] = babel["par\u00E8ntesis sempre"] = babel["beti parentesia"] = babel["par\u00E8nth\u00E8ses toujours"] = babel["par\u00E9ntese sempre"] = babel["par\u00E9ntesis sempre"] = babel["par\u00E8ntesis sempre"] = "";
//   babel["modo"] = babel["mode"] = babel["model"] = babel["modu"] = babel["mod\u00E8le"] = babel["modo"] = babel["modo"] = babel["model"] = "";
//   babel["autom\u00E1tico"] = babel["automatic"] = babel["autom\u00E0tic"] = babel["autom\u00E1tiko"] = babel["automatique"] = babel["autom\u00E1tico"] = babel["autom\u00E1tico"] = babel["autom\u00E0tic"] = "";
//   babel["clic y arrastre"] = babel["click and drag"] = babel["clica i arrossega"] = babel["klik eta arrastatu"] = babel["cliquer et tr\u00E2iner"] = babel["clic e arrastre"] = babel["clique e arraste"] = babel["clica i arrossega"] = "";
//   babel["clic y escribir"] = babel["click and write"] = babel["clica i y escriu"] = babel["klik eta idatzi"] = babel["cliquer et \u00E9crire"] = babel["clic e escribir"] = babel["clique e escrever"] = babel["clica i y escriu"] = "";
//   babel["escribir"] = babel["write"] = babel["escriu"] = babel["idatzi"] = babel["\u00E9crire"] = babel["escribir"] = babel["escrever"] = babel["escriu"] = "";
//   babel["guiado"] = babel["guided"] = babel["guiat"] = babel["gidatua"] = babel["guid\u00E9"] = babel["guiado"] = babel["guiado"] = babel["guiat"] = "";
  babel["ecuaci\u00F3n"] = babel["equation"] = babel["equaci\u00F3"] = babel["ekuazio"] = babel["\u00E9quation"] = babel["equa\u00E7\u00E3o"] = "equation";
//   babel["ejercicios"] = babel["exercises"] = babel["exercicis"] = babel["ariketak"] = babel["exercices"] = babel["exercicios"] = babel["exerc\u00EDcios"] = babel["exercicis"] = "";
  babel["punto"] = babel["dot"] = babel["punt"] = babel["puntu"] = babel["point"] = babel["ponto"] = "point";
//   babel["aspas"] = babel["cross"] = babel["aspes"] = babel["gurutzeak"] = babel["ailes"] = babel["aspas"] = babel["aspas"] = babel["aspes"] = "";
  babel["escenario"] = babel["scenario"] = babel["escenari"] = babel["agertoki"] = babel["sc\u00E8ne"] = babel["cen\u00E1rio"] = "scenario";
  babel["cID"] = "cID";
  babel["matriz"] = babel["matrix"] = babel["matriu"] = babel["matrice"] = "matrix";
  babel["filas"] = babel["rows"] = babel["files"] = "rows";
  babel["columnas"] = babel["columns"] = babel["colonnes"] = "columns";
  babel["solo_texto"] = babel["only_text"] = babel["seulement_texte"] = babel["s\u00F3_texto"] = babel["tan_sols_texte"] = babel["onlyText"] = "onlyText";
  // babel["evaluar"] = babel["evaluate"] = "evaluate";
  babel["respuesta"] = babel["answer"] = "answer";
  babel["peso"] = babel["weight"] = babel["pes"] = "weight";
  babel["decimal_symbol"] = babel["signo decimal"] = babel["decimal symbol"] = "decimal_symbol";
  babel["info"] = "info";
//   babel["No se encuentra"] = babel["Not Found"] = babel["No es troba"] = babel["Ez da aurkitzen"] = babel["Il ne se trouve pas"] = babel["Non se atopa"] = babel["N\u00E3o Encontrado"] = babel["No es troba"] = "";
  
  ////////////////////////
  //  new options added
  babel["library"] = "library";

  babel["color_contorn_text"] = babel["color_text_border"] = babel["color_borde_texto"] = babel["muga_testuaren_kolorea"] = babel["couleur_contour_texte"] = babel["cor_borde_texto"] = babel["colore_bordo_testo"] = babel["cor_borda_texto"] = babel["color_contorn_text"] = babel["border"] = "border";
  babel["video"] = babel["vid\u00e9o"] = "video";
  babel["audio"] = babel["\u00e0udio"] = "audio"; 
  babel["autoplay"] = "autoplay";
  babel["loop"] = "loop";
  babel["poster"] = "poster";
  babel["opacidad"] = babel["opacity"] = babel["opacit\u00E9"] = babel["opacitat"] = babel["opacidade"] = "opacity";
  babel["alinear"] = babel["align"] = babel["ali\u00F1ar"] = babel["aligner"] = "align";
  babel["anchor"] = "anchor";
  babel["a_left"] = "left";
  babel["a_center"] = "center";
  babel["a_right"] = "right";
  babel["a_justify"] = "justify";
  babel["a_top_left"] = "top_left";
  babel["a_top_center"] = "top_center";
  babel["a_top_right"] = "top_right";
  babel["a_center_left"] = "center_left";
  babel["a_center_center"] = "center_center";
  babel["a_center_right"] = "center_right";
  babel["a_bottom_left"] = "bottom_left";
  babel["a_bottom_center"] = "bottom_center";
  babel["a_bottom_right"] = "bottom_right";
  babel["malla"] = babel["mesh"] = "mesh";
  babel["local"] = babel["Local"] = "local";
  babel["rectangle"] = babel["rect\u00E1ngulo"] = "rectangle";
  babel["lineDash"] = "lineDash";
  babel["solid"] = "solid";
  babel["dot"] = "dot";
  babel["dash"] = "dash";
  babel["dash_dot"] = "dash_dot";

  babel["offset_dist"] = "offset_dist";
  babel["offset_angle"] = "offset_angle";

  babel["cssClass"] = "cssClass";
  babel["doc"] = "doc";

  babel["flat"] = "flat";
  babel["borderColor"] = "borderColor";
  babel["text_align"] = "text_align";
  babel["image_align"] = "image_align";

  babel["checkbox"] = "checkbox";
  babel["torus"] = babel["toro"] = "torus";
  babel["R"] = "R";
  babel["r"] = "r";
  babel["border_radius"] = "border_radius";
  babel["radio_group"] = "radio_group";
  babel["font_family"] = "font_family";
  babel["resizable"] = "resizable";

  // extra
  babel["antialias"] = "antialias";
  babel["image_loader"] = "image_loader";
  babel["expand"] = "expand";
  babel["cover"] = babel["cubrir"] = "expand";
  babel["fit"] = babel["escalar"] = "fit";
  babel["code"] = "code";
  babel["jsfun"] = "jsfun";
  

  return babel;
})(babel || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }
  
  var fontTokens;
  var fontCanvas;
  var name;
  var style;

  descartesJS.serif_font     = "descartesJS_serif,DJS_symbola,DJS_extra,DJS_serif,Times,'Times New Roman','Liberation Serif','Nimbus Roman No9 L Regular',serif";
  descartesJS.sansserif_font = "descartesJS_sansserif,DJS_symbola,DJS_sansserif,Helvetica,Arial,'Liberation Sans','Nimbus Sans L',sans-serif";
  descartesJS.monospace_font = "descartesJS_monospace,DJS_symbola,DJS_monospace,'Courier New',Courier,'Liberation Mono','Nimbus Mono L',monospace";

  /**
   * Converts a Descartes font string, to a canvas font string
   * @param {String} fontStr the Descartes font string
   * @return {String} the canvas font string
   */
  descartesJS.convertFont = function(fontStr) {
    if (fontStr == "") {
      return "";
    }

    fontTokens = fontStr.split(",");
    fontCanvas = "";

    // font style
    fontCanvas += descartesJS.getFontStyle(fontTokens[1]);

    // font size
    fontCanvas += fontTokens[2] + "px ";

    // font name
    fontCanvas += descartesJS.getFontName((fontTokens[0].split(" "))[0]);

    return fontCanvas;
  }

  /**
   * 
   */
  descartesJS.getFontName = function(fontName) {
    fontName =  fontName.toLowerCase();
    
    // monospace font
    name = descartesJS.monospace_font;
    
    // serif font
    if ((fontName === "serif") || (fontName === "times new roman") || (fontName === "timesroman") || (fontName === "times")) {
      name = descartesJS.serif_font;
    }
    // sans serif font
    else if ((fontName === "sansserif") || (fontName === "arial") || (fontName === "helvetica")) {
      name = descartesJS.sansserif_font;
    }
    
    return name;
  }

  /**
   * 
   */
  descartesJS.getFontStyle = function(fontStyle) {
    style = "";
    fontStyle = fontStyle.toLowerCase();

    // bold text
    if (fontStyle == "bold") {
      style += "Bold ";
    } 
    // italic text
    else if ( (fontStyle == "italic") || (fontStyle == "italics")) {
      style += "Italic ";
    }
    // bold and italic text
    else if (fontStyle == "bold+italic") {
      style += "Italic Bold ";
    }

    return style;
  }

  /**
   * Get the width in pixels of a text 
   * @param {String} text the text to measured
   * @param {String} font the font of the text
   * @return {Number} return the width of the text in pixels
   */
  descartesJS.getTextWidth = function(text, font) {
    descartesJS.ctx.font = font;
    return Math.round( descartesJS.ctx.measureText(text).width );
  }


  /**
   * Get the font size give the height of an element
   * @param {Number} the height of an element
   * @return {Number} return the best font size of the text that fits in the element
   */
  descartesJS.getFieldFontSize = function(height) {
    height = Math.min(50, height);

    if (height >= 24) {
      height = Math.floor(height/2 +2 -height/16);
    } 
    else if (height >= 20) {
      height = 12;
    } 
    else if (height >= 17) {
      height = 11;
    } 
    else if (height >= 15) {
      height = 10;
    } 
    else {
      height = 9;
    }
    return height;
  }

  var _font_size;

  /**
   *
   */
  descartesJS.getFontMetrics = function(font) {
    var result = {};

// sans serif
// ascent = -0.0003140767846*(_font_size^2) + 0.921017849*_font_size + 0.7767317469;
// descent = -0.0005851175551*(_font_size^2) + 0.2674451709*_font_size + 1.0887015962;

// serif
// ascent = -0.00003647238191*(_font_size^2) + 0.8914890964*_font_size + 0.668615541;
// descent = -0.0009807742367*(_font_size^2) + 0.3184618868*_font_size + 0.8663797537;

// monospace
// ascent = 0.0001192160435*(_font_size^2) + 0.7541188887*_font_size + 1.4106492466;
// descent = -0.001256260588*(_font_size^2) + 0.3926891751*_font_size + 0.57969422598;

    _font_size = parseInt( font.match(/(\d+\.*)+px/)[0] );
    if (font.match("sansserif")) {
      result.ascent = -0.0003140767846*(_font_size^2) + 0.921017849*_font_size + 0.7767317469;
      result.descent = -0.0005851175551*(_font_size^2) + 0.2674451709*_font_size + 1.0887015962;
      result.h = result.ascent + result.descent;
      result.baseline = result.ascent;
    }
    else if (font.match("serif")) {
      result.ascent = -0.00003647238191*(_font_size^2) + 0.8914890964*_font_size + 0.668615541;
      result.descent = -0.0009807742367*(_font_size^2) + 0.3184618868*_font_size + 0.8663797537;
      result.h = result.ascent + result.descent;
      result.baseline = result.ascent;
    }
    else if (font.match("monospace")) {
      result.ascent = 0.0001192160435*(_font_size^2) + 0.7541188887*_font_size + 1.4106492466;
      result.descent = -0.001256260588*(_font_size^2) + 0.3926891751*_font_size + 0.57969422598;
      result.h = result.ascent + result.descent;
      result.baseline = result.ascent;
    }

    return result;
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var PI2 = Math.PI*2;
  var trecientosSesentaEntreDosPi = 360/PI2;
  var dosPiEntreTrecientosSesenta = PI2/360;
  var MathFloor = Math.floor;

  var colorExpr;
  var red;
  var green;
  var blue;
  var alpha;

  var touch;
  var mouseX;
  var mouseY;
  var boundingRect;

  var desp;

  descartesJS.rangeOK = 1;
  descartesJS.cssScale = 1;

  /**
   * Extends an object with inheritance
   * @param {Object} child is the object that extends
   * @param {Object} parent is the objecto to extends
   */
  descartesJS.extend = function(child, parent) {
    // updated method
    if (typeof Object.create == "function") {
      child.prototype = Object.create(parent.prototype);
    }
    // old method
    else {
      if (child.prototype.__proto__) {
        child.prototype.__proto__ = parent.prototype;
      }
      else {
        // copy all the functions of the parent
        for( var i in parent.prototype ) {
          if (parent.prototype.hasOwnProperty(i)) {
            child.prototype[i] = parent.prototype[i];
          }
        }
      }
    }

    // add the uber (super) property to execute functions of the parent
    child.prototype.uber = parent.prototype;
  }

  /**
   * Converts radians to degrees
   * @param {Number} r the radian to convert
   * @return {Number} return the convertion to degrees of the number r
   */
  descartesJS.radToDeg = function(r) {
    return r*trecientosSesentaEntreDosPi;
  }

  /**
   * Converts degrees to radians
   * @param {Number} d the degree to convert
   * @return {Number} return the convertion to radians of the number d
   */
  descartesJS.degToRad = function(d) {
    return d*dosPiEntreTrecientosSesenta;
  }

  /**
   * Function for draw the spinner control, that draws a line
   * @param {2DContext} ctx the canvas context to draw
   * @param {Number} x1 the x position of the initial point
   * @param {Number} y1 the y position of the initial point
   * @param {Number} x2 the x position of the final point
   * @param {Number} y2 the y position of the final point
   * @param {String} strokeStyle the style of the stroke used to draw the line
   * @param {Number} lineWidth the width of the line to draw
   */
  descartesJS.drawLine = function(ctx, x1, y1, x2, y2, strokeStyle, lineWidth) {
    ctx.lineWidth = lineWidth || 1;
    ctx.strokeStyle = strokeStyle || "black";
    desp = (ctx.lineWidth%2) ? .5 : 0;

    ctx.beginPath();
    ctx.moveTo(MathFloor(x1)+desp, MathFloor(y1)+desp);
    ctx.lineTo(MathFloor(x2)+desp, MathFloor(y2)+desp);
    ctx.stroke();
  }

  /**
   * Get a color string from a Descartes color
   * @param {DescartesJS.Evaluator} evaluator the evaluator needed for evaluate the posible expressions
   * @param {String|Object} color Descartes color especification
   * @return {String} return a string corresponding to the color
   */
  descartesJS.getColor = function(evaluator, color) {
    // if the color is a string then return that string color
    if ( typeof(color) == "string" ) {
      return color;
    }
    // if the color has an expression, then evaluate the string and return the corresponding color
    else {
      colorExpr = evaluator.eval(color);
      red   = MathFloor(colorExpr[0][0]*255);
      green = MathFloor(colorExpr[0][1]*255);
      blue  = MathFloor(colorExpr[0][2]*255);
      alpha = (1-colorExpr[0][3]);

      return "rgba(" + red + "," + green + "," + blue + "," + alpha + ")";
    }
  }

  /**
   * Get some feature needed for the properly interpretation of the Descartes lesson
   */
  descartesJS.getFeatures = function() {
    // detects if the browser supports touch events
    var system = navigator.appVersion.toLowerCase();
    descartesJS.hasTouchSupport = ((window.hasOwnProperty) && (window.hasOwnProperty("ontouchstart"))) || ("ontouchstart" in window) || ((/android/i).test(system));

    descartesJS.isIOS = (/iPad|iPhone/i).test(navigator.userAgent);
    descartesJS.isMsEdge = (/Edge/).test(navigator.userAgent);

    // detects if the browser has canvas support
    var elem = document.createElement('canvas');
    descartesJS.hasCanvas = (elem.getContext && elem.getContext('2d'));
    if (descartesJS.hasCanvas) {
      // render context used to measuere text
      descartesJS.ctx = document.createElement("canvas").getContext("2d");

      // var backingStoreRatio = descartesJS.ctx.webkitBackingStorePixelRatio ||
      //                         descartesJS.ctx.mozBackingStorePixelRatio ||
      //                         descartesJS.ctx.msBackingStorePixelRatio ||
      //                         descartesJS.ctx.oBackingStorePixelRatio ||
      //                         descartesJS.ctx.backingStorePixelRatio || 1;
      // descartesJS._ratio = (window.devicePixelRatio || 1) / backingStoreRatio;
      descartesJS._ratio = 1.5;
      // descartesJS._ratio = 1;
    }

    setNewToFixed();
  }

  /**
   * Function that changes the definition of the function toFixed of the Number object
   */
  function setNewToFixed() {
    var strNum;
    var indexOfDot;
    var diff;
    var exponentialSplit;
    var exponentialNumber;
    var exponentialSign;
    var moveDotTo;

    function getStringExtraZeros(n) {
      return new Array(n+1).join("0");
    }

    // maintain the original toFixed function
    Number.prototype.oToFixed = Number.prototype.toFixed;

    Number.prototype.toFixed = function(decimals) {
      decimals = (decimals) || 0;
      decimals = (decimals < 0) ? 0 : (decimals >> 0);

      strNum = this.toString();

      if (strNum.indexOf("e") !== -1) {
        exponentialSplit = strNum.split("e");
        exponentialSign = (exponentialSplit[0][0] === "-") ? "-" : "";
        exponentialNumber = (exponentialSign === "-") ? parseFloat(exponentialSplit[0].substring(1)).oToFixed(11) : parseFloat(exponentialSplit[0]).oToFixed(11);

        moveDotTo = (exponentialSplit[1] >> 0);
        indexOfDot = exponentialNumber.indexOf(".");

        if (indexOfDot+moveDotTo < 0) {
          indexOfDot = (indexOfDot < 0) ? 1 : indexOfDot;
          strNum = exponentialSign + "0." + getStringExtraZeros(Math.abs(indexOfDot+moveDotTo)) + exponentialNumber.replace(".", "");
        }
        else {
          exponentialNumber = exponentialNumber.replace(".", "");
          strNum = exponentialSign + exponentialNumber + getStringExtraZeros(moveDotTo-exponentialNumber.length+1);
        }
      }

      indexOfDot = strNum.indexOf(".");
      extraZero = "";
      
      // is a float number
      if (indexOfDot === -1) {
        if (decimals > 0) {
          strNum += ".";
        }
        strNum += getStringExtraZeros(decimals);
      }
      else {
        diff = strNum.length - indexOfDot - 1;
       
        if (diff >= decimals) {
          if (decimals <= 11) {
            strNum = parseFloat(strNum).oToFixed(decimals);
          }
          else {
            strNum = (decimals>0) ? strNum.substring(0, indexOfDot +decimals +1) : strNum.substring(0, indexOfDot);
          }
        }
        else {
          strNum += getStringExtraZeros(decimals-diff);
        }
      }

      return strNum;
    }
  }

  var indexOfDot;
  var decimalNumbers;

  /**
   *
   */
  descartesJS.removeNeedlessDecimals = function(num) {
    if (typeof(num) == "string") {
      indexOfDot = num.indexOf(".");

      if (indexOfDot != -1) {
        decimalNumbers = num.substring(indexOfDot);

        if (parseFloat(decimalNumbers) == 0) {
          return num.substring(0, indexOfDot);
        }
        else {
          for (var i=decimalNumbers.length; i>0; i--) {
            if (decimalNumbers.charAt(i) != 0) {
              return num.substring(0, indexOfDot+i+1);
            }
          }
        }
      }
    }

    return num;
  }

  /**
   *
   */
  descartesJS.returnValue = function(v) {
    return (typeof(v) === "number") ? parseFloat(v.toFixed(11)) : v;
  }

  /**
   * Get which mouse button is pressed
   */
  descartesJS.whichBtn = function(evt) {
    // all browsers
    if (evt.which !== null) {
      return (evt.which < 2) ? "L" : ((evt.which === 2) ? "M" : "R");
    }
    // IE
    return (evt.button < 2) ? "L" : ((evt.button === 4) ? "M" : "R");
  }

  /**
   * Get the cursor position in absolute coordinates
   * @param {Event} evt the event that has the cursor postion
   * @return {Object} return the position of the mouse in absolute coordinates
   */
  descartesJS.getCursorPosition = function(evt, container) {
    // if has touch events
    if (evt.touches) {
      touch = evt.touches[0];

      mouseX = touch.pageX;
      mouseY = touch.pageY;
    }
    // if has mouse events
    else {
      mouseX = evt.pageX;
      mouseY = evt.pageY;
    }

    boundingRect = container.getBoundingClientRect();

    // considerar para la escala por transformacion de css
    return { x: (mouseX -window.pageXOffset -boundingRect.left)/descartesJS.cssScale,
             y: (mouseY -window.pageYOffset -boundingRect.top)/descartesJS.cssScale
           }
  }

  // get the animation frame functions
  window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  window.cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;

  /**
   *
   */
  descartesJS.setInterval = function(fun, delay) {
    if (!requestAnimationFrame) {
      return setInterval(fun, delay);
    }

    var start = new Date().getTime();
    var handle = {};

    function loop() {
      if(((new Date().getTime()) - start) >= delay) {
        fun.call();
        start = new Date().getTime();
      }

      handle.value = requestAnimationFrame(loop);
    };

    handle.value = requestAnimationFrame(loop);
    return handle;
  }

  /**
   *
   */
  descartesJS.clearInterval = function(handle) {
    if (handle) {
      (cancelAnimationFrame) ? cancelAnimationFrame(handle.value) : clearInterval(handle);
    }
  }

  /**
   *
   */
  descartesJS.setTimeout = function(fun, delay) {
    if (!requestAnimationFrame) {
      return setTimeout(fun, delay);
    }

    var start = new Date().getTime();
    var handle = {};

    function loop() {
      if (((new Date().getTime()) - start) >= delay) {
        fun.call();
      }
      else {
        handle.value = requestAnimationFrame(loop);
      }
    };

    handle.value = requestAnimationFrame(loop);
    return handle;
  }

  /**
   *
   */
  descartesJS.clearTimeout = function(handle) {
    if (handle) {
      (cancelAnimationFrame) ? cancelAnimationFrame(handle.value) : clearTimeout(handle);
    }
  }

  var htmlAbout =
`<html>
<head>
<style>
body{text-align:center;}
iframe{width:650px;height:73px;overflow:hidden;border:1px solid black;}
dt{font-weight:bold;margin-top:10px;}
</style>
</head>
<body>
<iframe src='http://arquimedes.matem.unam.mx/Descartes5/creditos/bannerPatrocinadores.html'></iframe>
<h2><a href='http://proyectodescartes.org/' target='_blank'>ProyectoDescartes.org</a><br><a href='http://descartesjs.org' target='_blank'>DescartesJS.org</a></h2>
<dl>
<dt>Dise&ntilde;o funcional:</dt>
<dd>
<nobr>Jos&eacute; Luis Abreu Leon,</nobr>
<nobr>Jos&eacute; R. Galo Sanchez,</nobr>
<nobr>Juan Madrigal Muga</nobr>
</dd>
<dt>Autores del software:</dt>
<dd>
<nobr>Jos&eacute; Luis Abreu Leon,</nobr>
<nobr>Marta Oliver&oacute; Serrat,</nobr>
<nobr>Oscar Escamilla Gonz&aacute;lez,</nobr>
<nobr>Joel Espinosa Longi</nobr>
</dd></dl>
<p>
El software en Java est&aacute; bajo la licencia
<a href='https://joinup.ec.europa.eu/software/page/eupl/licence-eupl'>EUPL v.1.1</a>
<br>
El software en JavaScript est&aacute; bajo licencia
<a href='http://www.gnu.org/licenses/lgpl.html'>LGPL</a>
</p>
<p>
La documentaci&oacute;n y el c&oacute;digo fuente se encuentran en :
<br>
<a href='http://arquimedes.matem.unam.mx/Descartes5/'>http://arquimedes.matem.unam.mx/Descartes5/</a>
</p>`;

  var htmlCreative = 
`<p>
Este objeto, creado con Descartes, est&aacute; licenciado
por sus autores como
<a href='https://creativecommons.org/licenses/by-nc-sa/4.0/deed.es'><nobr>Creative Commons</nobr></a>
<br>
<a href='https://creativecommons.org/licenses/by-nc-sa/4.0/deed.es'><img src='https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png'></a>
</p>`;

  var htmlFinal = "</body> </html>";

  /**
   *
   */
  descartesJS.showAbout = function() {
    var content = htmlAbout;
    if (descartesJS.ccLicense) {
      content += htmlCreative;
    }
    content += htmlFinal;

    var tmpW = window.open("", "creditos", "width=700,height=500,titlebar=0,toolbar=0,location=0,menubar=0,resizable=0,scrollbars=0,status=0");
    tmpW.document.write(content);
    tmpW.document.close();
  }

  /**
   *
   */
  descartesJS.splitSeparator = function(value) {
    value = value.replace(/\\n/g, "\n");

    var inStr = false;
    var charAt;
    var valueArray = [];
    var lastIndex = 0;

    for (var i=0, l=value.length; i<l; i++) {
      charAt = value.charAt(i);
      // inside or outside of a string
      if (charAt === "'") {
        inStr = !inStr;
      }

      // if outside of a string then replace \\n and ; for a new line
      if ((!inStr) && ( (charAt === ";") || (charAt === "\n") ) ) {
        valueArray.push(value.substring(lastIndex, i).replace(/\n/g, "\\n"));
        lastIndex = i+1;
      }
    }
    valueArray.push(value.substring(lastIndex).replace(/\n/g, "\\n"));

    return valueArray;
  }

  descartesJS.preventDefault = function(evt) {
    evt.preventDefault();
    return false;
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var response;
  var xhr;
  descartesJS.cacheFiles = {};

  /**
   * Open an external file using an xml http request
   * @param {String} filename the filename of the file to open
   * @return {*} the content of the file if readed or null if not
   */
  descartesJS.openExternalFile = function(filename) {
    if (descartesJS.cacheFiles[filename]) {
      return descartesJS.cacheFiles[filename];
    }

    response = null;
    xhr = new XMLHttpRequest();
    xhr.open("GET", filename, false);
    try {
      xhr.send(null);
      response = (xhr.status === 200 || xhr.status === 304) ? xhr.responseText : (xhr.responseText || "");
      response = (xhr.status === 404) ? "" : response;

      ////////////////////////////////////////////////////////////////////////
      // patch to read ISO-8859-1 text files
      if (response.match(String.fromCharCode(65533))) {
	      xhr.open("GET", filename, false);
	      xhr.overrideMimeType("text/plain;charset=ISO-8859-1");
	      xhr.send(null);
	      response = xhr.responseText;
      }
      ////////////////////////////////////////////////////////////////////////
    }
    catch (e) {
      // console.log("Error to load the file :", filename);
      response = null;
    }

    return response;
  }

  /**
   *
   */
  descartesJS.addExternalFileContent = function(filename, data) {
    descartesJS.cacheFiles[filename] = data;
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var tmpAnswer;
  var regExpPattern_i;
  var answerArray;
  var regExpPattern;
  var answerValue;

  var answer_0;
  var answer_1;
  var limInf;
  var limSup;
  var cond1;
  var cond2;
  var cond3;
  var cond4;

  var indexOfRadial;

  /**
   * Build a text regular expression pattern from a Descartes answer pattern (auxiliary function)
   * @param {String} answer the Descartes answer pattern to convert
   * @return {Object} return an object representing a simple regular expression pattern
   */
  function buildTextRegularExpressionPattern(answer) {
    indexOfRadial = answer.indexOf("--radial--");
    if (indexOfRadial != -1) {
      answer = answer.substring(0, indexOfRadial);
    }

    tmpAnswer = answer.trim();
    answer = { ignoreAcents: false, ignoreCaps: false, regExp: null };

    // ignore uppercase
    if ((tmpAnswer[0] == tmpAnswer[tmpAnswer.length-1]) && (tmpAnswer[0] == "'")) {
      answer.ignoreCaps = true;
      tmpAnswer = tmpAnswer.substring(1, tmpAnswer.length-1);

      // ignore accents
      if ((tmpAnswer[0] == "`") && (tmpAnswer[tmpAnswer.length-1] == "´")) {
        answer.ignoreAcents = true;
        tmpAnswer = tmpAnswer.substring(1, tmpAnswer.length-1);
      }
    }

    // ignore accents
    if ((tmpAnswer[0] == "`") && (tmpAnswer[tmpAnswer.length-1] == "´")) {
      answer.ignoreAcents = true;
      tmpAnswer = tmpAnswer.substring(1, tmpAnswer.length-1);

      // ignore uppercase
      if ((tmpAnswer[0] == tmpAnswer[tmpAnswer.length-1]) && (tmpAnswer[0] == "'")) {
        answer.ignoreCaps = true;
        tmpAnswer = tmpAnswer.substring(1, tmpAnswer.length-1);
      }
    }

    if ((tmpAnswer.charAt(0) === "*") && (tmpAnswer.charAt(tmpAnswer.length-1) !== "*")) {
      tmpAnswer = (tmpAnswer.substring(1)) + "$";
    }

    else if ((tmpAnswer.charAt(0) !== "*") && (tmpAnswer.charAt(tmpAnswer.length-1) === "*")) {
      tmpAnswer = "^" + (tmpAnswer.substring(0, tmpAnswer.length-1));
    }

    else if ((tmpAnswer.charAt(0) !== "*") && (tmpAnswer.charAt(tmpAnswer.length-1) !== "*")) {
      tmpAnswer = "^" + tmpAnswer + "$";
    }

    else if ((tmpAnswer.charAt(0) === "*") && (tmpAnswer.charAt(tmpAnswer.length-1) === "*")) {
      tmpAnswer = tmpAnswer.substring(1, tmpAnswer.length-1);
    }

    answer.regExp = tmpAnswer.replace(/\?/g, "[\\S\\s]{1}");

    return answer;
  }

  /**
   * Build a text regular expression pattern from a Descartes answer pattern (auxiliary function)
   * @param {String} answer the Descartes answer pattern to convert
   * @return {Object} return an object representing a simple regular expression pattern
   */
  function buildNumericRegularExpressionPattern(answer, evaluator) {
    answer = answer || "";
    tmpAnswer = answer.trim();
    answer = { ignoreAcents: false, ignoreCaps: false, regExp: null };

    answer.expr = tmpAnswer.split(",");

    answer.expr[0] = answer.expr[0].trim();
    answer.expr[0] = { 
      type: answer.expr[0].charAt(0),
      expr: evaluator.parser.parse(answer.expr[0].substring(1))
    };

    answer.expr[1] = answer.expr[1].trim();
    answer.expr[1] = { 
      type: answer.expr[1].charAt(answer.expr[1].length-1),
      expr: evaluator.parser.parse(answer.expr[1].substring(0, answer.expr[1].length-1))
    };

    return answer;
  }

  function inRange(regExp, value, evaluator) {
    value = parseFloat(value);

    answer_0 = regExp.expr[0];
    answer_1 = regExp.expr[1];

    limInf = evaluator.eval(answer_0.expr);
    limSup = evaluator.eval(answer_1.expr);

    cond1 = (answer_0.type == "(") || (answer_0.type == "[");
    cond2 = (answer_1.type == ")") || (answer_1.type == "]");

    return ( (cond1 && (value > limInf)) && (cond2 && (value <= limSup)) ) ? 1 : 0;
  }

  /**
   * Remove the accents in a string and change the \u00f1 for n
   * @param {String} value the string to remove the accents
   * @return {String} return ths string with the accents remove
   */
  function removeAccents(value) {
    return value.toString().replace(/\u00e1/g, "a").replace(/\u00e9/g, "e").replace(/\u00ed/g, "i").replace(/\u00f3/g, "o").replace(/\u00fa/g, "u").replace(/\u00c1/g, "A").replace(/\u00c9/g, "E").replace(/\u00cd/g, "I").replace(/\u00d3/g, "O").replace(/\u00da/g, "U").replace(/\u00f1/g, "n").replace(/\u00d1/g, "N");
  }

  /**
   * Build a regular expression pattern from a Descartes answer pattern
   * @param {String} answer the Descartes answer pattern to convert
   * @return {Object} return an object representing a regular expression pattern
   */
  descartesJS.buildRegularExpresionsPatterns = function(answer, evaluator) {
    answer = answer || "";
    // remove parentheses in a text expression
    if ((answer.charAt(0) === "(" ) && (answer.charAt(answer.length-1) === ")") && (answer.indexOf(",") === -1)) {
      answer = answer.substring(1, answer.length-1);
    }

    answer = ((answer.replace(/&squot;/g, "'")).replace(/&amp;/g, "&")).split("|");

    for (var i=0, l=answer.length; i<l; i++) {
      regExpPattern_i = answer[i].split("&");
      answerArray = [];

      for (var j=0, k=regExpPattern_i.length; j<k; j++) {
        tmpAnswer = regExpPattern_i[j];

        // numeric pattern
        if ( (tmpAnswer.indexOf(",") !== -1) &&
             ( ((tmpAnswer.charAt(0) === "(" ) || (tmpAnswer.charAt(0) === "[")) &&
               ((tmpAnswer.charAt(tmpAnswer.length-1) === ")") || (tmpAnswer.charAt(tmpAnswer.length-1) === "]"))
             )
           ) {
          answerArray.push( buildNumericRegularExpressionPattern(tmpAnswer, evaluator) );
        }
        // text pattern
        else {
          answerArray.push( buildTextRegularExpressionPattern(tmpAnswer) );
        }
      }

      answer[i] = answerArray;
    }

    return answer;
  }

  /**
   * Decide whether the answer meets the Descartes answer pattern ignoring accents and uppercase
   * @param {String} respPattern the Descartes answer pattern
   * @param {String} resp the answer to check
   * @return {Number} return 1 if the answer meets the Descartes answer pattern and 0 if not
   */
  descartesJS.escorrecto = function(respPattern, resp, evaluator, regExpPattern) {
    evaluator = evaluator || descartesJS.externalEvaluator;
    regExpPattern = regExpPattern || descartesJS.buildRegularExpresionsPatterns(respPattern, evaluator);

    // remove the accents
    resp = removeAccents(resp);

    for (var i=0, l=regExpPattern.length; i<l; i++) {
      regExpPattern_i = regExpPattern[i];
      answerValue = true;

      for (var j=0, k=regExpPattern_i.length; j<k; j++) {
        // a text pattern
        if (regExpPattern_i[j].regExp) {
          answerValue = answerValue && !!(resp.match( new RegExp(removeAccents(regExpPattern_i[j].regExp), "i" )) );
        }
        // a numeric pattern
        else {
          answerValue = answerValue && inRange(regExpPattern_i[j], resp, evaluator);
        }
      }

      if (answerValue) {
        return 1;
      }
    }
    return 0;
  }

  /**
   * Decide whether the answer meets the Descartes answer pattern strictly
   * @param {String} respPattern the Descartes answer pattern
   * @param {String} resp the answer to check
   * @return {Number} return 1 if the answer meets the Descartes answer pattern and 0 if not
   */
  descartesJS.esCorrecto = function(respPattern, resp, evaluator, regExpPattern) {
    evaluator = evaluator || descartesJS.externalEvaluator;
    regExpPattern = regExpPattern || descartesJS.buildRegularExpresionsPatterns(respPattern, evaluator);

    for (var i=0, l=regExpPattern.length; i<l; i++) {
      regExpPattern_i = regExpPattern[i];
      answerValue = true;

      for (var j=0, k=regExpPattern_i.length; j<k; j++) {
        tmpAnswer = regExpPattern_i[j].regExp;

        // a text pattern
        if (tmpAnswer) {
          if (regExpPattern_i[j].ignoreAcents) {
            resp = removeAccents(resp);
            tmpAnswer = removeAccents(tmpAnswer);
          }

          if (regExpPattern_i[j].ignoreCaps) {
            resp = resp.toLowerCase();
            tmpAnswer = removeAccents(tmpAnswer).toLowerCase();
          }

          answerValue = answerValue && !!(resp.match(tmpAnswer));
        }
        // a numeric pattern
        else {
          answerValue = answerValue = answerValue && inRange(regExpPattern_i[j], resp, evaluator);
        }
      }

      if (answerValue) {
        return 1;
      }
    }

    return 0;
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   *  DescartesJS loader image
   */
  descartesJS.loaderImg = new Image();
  descartesJS.loaderImg.src = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4ODAiIGhlaWdodD0iODQwIj48ZyBmaWxsPSIjMmRhYWU0Ij48cGF0aCBkPSJNNDQwIDgwYy0xMzIuNSAwLTI0MCAxMDcuNS0yNDAgMjQwczEwNy41IDI0MCAyNDAgMjQwIDI0MC0xMDcuNSAyNDAtMjQwUzU3Mi41IDgwIDQ0MCA4MHptLTExLjEgNDYyLjJjLTEyMi43IDAtMjI0LjQtOTkuNS0yMjQuNC0yMjIuMlMzMDYuMiA5Ny44IDQyOC45IDk3LjggNjUxLjEgMTk3LjMgNjUxLjEgMzIwcy05OS41IDIyMi4yLTIyMi4yIDIyMi4yeiIvPjxwYXRoIGQ9Ik00MTcuOCAxMTUuNmMtMTEyLjkgMC0yMDguOSA5MS41LTIwOC45IDIwNC40czk2IDIwNC40IDIwOC45IDIwNC40UzYyMi4yIDQzMi45IDYyMi4yIDMyMHMtOTEuNS0yMDQuNC0yMDQuNC0yMDQuNHptLTExLjEgMzkxLjFjLTEwMy4xIDAtMTkzLjMtODMuNi0xOTMuMy0xODYuN3M5MC4yLTE4Ni43IDE5My4zLTE4Ni43UzU5My4zIDIxNi45IDU5My4zIDMyMHMtODMuNSAxODYuNy0xODYuNiAxODYuN3oiLz48cGF0aCBkPSJNMzk1LjYgMTUxLjFjLTkzLjMgMC0xNzcuOCA3NS42LTE3Ny44IDE2OC45czg0LjUgMTY4LjkgMTc3LjggMTY4LjlTNTY0LjQgNDEzLjMgNTY0LjQgMzIwYzAtOTMuMy03NS42LTE2OC45LTE2OC44LTE2OC45em0tMTEuMiAzMjBjLTgzLjUgMC0xNjIuMi02Ny43LTE2Mi4yLTE1MS4xUzMwMSAxNjguOSAzODQuNCAxNjguOSA1MzUuNiAyMzYuNSA1MzUuNiAzMjBzLTY3LjcgMTUxLjEtMTUxLjIgMTUxLjF6Ii8+PHBhdGggZD0iTTM3My4zIDE4Ni43Yy03My42IDAtMTQ2LjcgNTkuNy0xNDYuNyAxMzMuM3M3MyAxMzMuMyAxNDYuNyAxMzMuM1M1MDYuNyAzOTMuNiA1MDYuNyAzMjAgNDQ3IDE4Ni43IDM3My4zIDE4Ni43em0tMTEuMSAyNDguOWMtNjMuOCAwLTEzMS4xLTUxLjctMTMxLjEtMTE1LjZzNjcuMy0xMTUuNiAxMzEuMS0xMTUuNlM0NzcuOCAyNTYuMiA0NzcuOCAzMjAgNDI2IDQzNS42IDM2Mi4yIDQzNS42eiIvPjxwYXRoIGQ9Ik0zNTEuMSAyMjIuMmMtNTQgMC0xMTUuNiA0My44LTExNS42IDk3LjhzNjEuNiA5Ny44IDExNS42IDk3LjhjNTQgMCA5Ny44LTQzLjggOTcuOC05Ny44cy00My44LTk3LjgtOTcuOC05Ny44ek0zNDAgNDAwYy00NC4yIDAtMTAwLTM1LjgtMTAwLTgwczU1LjgtODAgMTAwLTgwIDgwIDM1LjggODAgODAtMzUuOCA4MC04MCA4MHoiLz48L2c+PGcgZmlsbD0iIzg2ODY4NiI+PHBhdGggZD0iTTExNS44IDYwMC43YzMyLjUgMCA0OC44IDI0LjggNDguOCA0OS43UzE0OC40IDcwMCAxMTUuOCA3MDBIODAuMnYtOTkuM2gzNS42em0wIDg1YzIzIDAgMzQuNi0xNy42IDM0LjYtMzUuMnMtMTEuNi0zNS40LTM0LjYtMzUuNEg5NC41djcwLjZoMjEuM3pNMTg3LjggNjg1LjdIMjM0VjcwMGgtNjAuNnYtOTkuM2g2MC41VjYxNWgtNDZ2MjhoNDV2MTQuNWgtNDV2MjguMnpNMjk2IDYyNi4zYy0yLTguOS0xMS42LTEyLjgtMjAuMy0xMi42LTYuNy4xLTE0LjEgMi40LTE4IDcuNS0yIDIuNi0yLjcgNS44LTIuNCA5LjIuNyAxMC4yIDExLjkgMTEuNSAyMi42IDEyLjUgMTMuNiAxLjcgMzAuNSA1LjMgMzQuNCAyMS4yLjQgMi4xLjcgNC41LjcgNi41IDAgMTkuMi0xOSAzMC4yLTM2LjkgMzAuMi0xNS4zIDAtMzMuOS05LjEtMzUuOC0yNi44bC0uMS0yLjcgMTQuNS0uMy4xIDIuMXYtLjZjMSA5LjIgMTIuMiAxNC4xIDIxLjQgMTQuMSAxMC42IDAgMjIuMy02IDIyLjMtMTYuMiAwLTEtLjEtMi4xLS40LTMuNC0xLjctNy41LTExLjktOC44LTIxLjktOS44LTE1LjUtMS42LTMzLjctNS0zNS4yLTI1Ljd2LjFjLS42LTYuNyAxLjEtMTMuMyA1LjQtMTguOSA2LjctOC43IDE4LjYtMTMuMiAzMC4xLTEzLjIgMTUuMyAwIDMxLjIgOCAzMy44IDI2LjFsLTE0LjMuN3pNMzM0LjIgNjE0LjljOC43LTguOSAyMC45LTE0LjggMzQuNC0xNC44IDIyLjcgMCA0MC42IDE0LjIgNDYuMyAzNi42aC0xNC4yYy01LjMtMTQuOS0xNy41LTIyLjQtMzIuMS0yMi40LTkuNSAwLTE4LjIgNC4xLTI0LjQgMTAuNy02LjIgNi41LTEwLjIgMTUuMy0xMC4yIDI1LjYgMCA5LjkgNCAxOC43IDEwLjIgMjUuM3MxNC45IDEwLjYgMjQuNCAxMC42YzE1LjEgMCAyNy44LTguNyAzMi45LTIzLjdoMTQuMWMtNS43IDIyLjYtMjMuOSAzNy45LTQ3IDM3LjktMTMuNSAwLTI1LjctNS43LTM0LjQtMTQuOC04LjUtOS4xLTE0LjItMjEuNi0xNC4yLTM1LjQgMC0xNCA1LjctMjYuNSAxNC4yLTM1LjZ6TTQ3OC44IDY3MC43aC0zNS42Yy0zLjggOS4xLTguOCAyMS0xMS45IDI5LjNoLTE1LjVsMzkuOS0xMDAuN2gxMC41TDUwNiA3MDBoLTE1LjNsLTExLjktMjkuM3ptLTMwLjMtMTMuNGgyNC43TDQ2MSA2MjIuMmwtMTIuNSAzNS4xek01MjguNiA2NDkuNmgxNi44YzEyLjEgMCAxOC04LjcgMTgtMTcuMyAwLTguNS02LTE3LjItMTgtMTcuMmgtMjJWNzAwaC0xNC4ydi05OS40aDM2LjJjMjEuNiAwIDMyLjQgMTUuOSAzMi40IDMxLjcgMCAxNC4xLTguNyAyNy40LTI1LjcgMzAuNGwzMS40IDM3LjNoLTE4LjZsLTM2LjItNDMuNnYtNi44ek02MTAuMyA3MDAuNHYtODUuM2gtMzAuMXYtMTQuNWg3NC40djE0LjVoLTMwdjg1LjNoLTE0LjN6TTY3Ni40IDY4NS43aDQ2LjFWNzAwSDY2MnYtOTkuM2g2MC41VjYxNWgtNDZ2MjhoNDV2MTQuNWgtNDV2MjguMnpNNzg0LjYgNjI2LjNjLTItOC45LTExLjYtMTIuOC0yMC4zLTEyLjYtNi43LjEtMTQuMSAyLjQtMTggNy41LTIgMi42LTIuNyA1LjgtMi40IDkuMi43IDEwLjIgMTEuOSAxMS41IDIyLjYgMTIuNSAxMy42IDEuNyAzMC41IDUuMyAzNC40IDIxLjIuNCAyLjEuNyA0LjUuNyA2LjUgMCAxOS4yLTE5IDMwLjItMzYuOSAzMC4yLTE1LjMgMC0zMy45LTkuMS0zNS44LTI2LjhsLS4xLTIuNyAxNC41LS4zLjEgMi4xdi0uNmMxIDkuMiAxMi4yIDE0LjEgMjEuNCAxNC4xIDEwLjYgMCAyMi4zLTYgMjIuMy0xNi4yIDAtMS0uMS0yLjEtLjQtMy40LTEuNy03LjUtMTEuOS04LjgtMjEuOS05LjgtMTUuNS0xLjYtMzMuNy01LTM1LjItMjUuN3YuMWMtLjYtNi43IDEuMS0xMy4zIDUuNC0xOC45IDYuNy04LjcgMTguNi0xMy4yIDMwLjEtMTMuMiAxNS4zIDAgMzEuMiA4IDMzLjggMjYuMWwtMTQuMy43eiIvPjwvZz48L3N2Zz4=";

  /**
   * Get the embedded image of the license used in Arquimedes
   * @return {Image} return the image of the license used in Arquimedes
   */
  descartesJS.getCCLImg = function() {
    var img = new Image();
    img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAAAfCAMAAABUFvrSAAABC1BMVEUAAAC1urSEhYRDREMNDg2EhoR5fHkpKSmRk5EbGxuRlJGVmZQoKShAQEBwcHCTmJNQUVAQEBBgYGCAgIC/v78ODg5QUFDf39/////v7++fn5+Rj49aV1jj4+PIx8cwMDB9f3zW1dUyMTGamJkZGRkNDA12c3SjoaEjHyC6ubkpKikoJSY/OzxoZWaHhoesq6s/NzljX2HPz891cnN4dXbx8fGflpqOh4uenZ0xLS4kJCQoKCjo5+ePj4+1tbUtLS3g3+Cvr6/JyMggICAqKip+e3wfGxyEgYIqJyeYlpd/gX5ubGyMiovLyst6fXmeoJ18f3xdXl2ChYJwcm81NjWWmZYyMzE+Pz6JjIk4KLQtAAACcklEQVR4AbyVhXbjMBREx2UIGWq/MCcqMy2Wu8z0/1+yz5ElKyrjlG99bpQR4eniPEmeRTwyOgbO2Oi4Y2ViEpzJiTuQVDw1DZ3pGVM7mwGyuVwWyOQlyd9MtLgAwPX8IPA9F0DBEM8hjIgThZjL35YAUF7XL5JMidUZ7Z2ExwyI/yFxZkDKFYtUa7WqJgASbz0inWI9HXMDYVOJKcQEt4lWm72dbq+qCT/TF5x5SZR4ir1quNqc9LyAKOURJuO3sCiWluGvYFWTiGpibb0nRFmSRDwNd4OGUnQxLcXIEscDPOJkEZPNLSFEr9pMCW3viF2iPbEviRSPAD5ZKQFy1SFHHEB2kYMktR6AXjMl2y/ES65ZiFdMlHgULhcRhNmsL3+8JiIXo9eI2dHbF6Iyr8mbt8FAfGCIx+CxEHGyh+DEf3sYu7wKSbb3qCk4S4rM94+IVoUwqwB4iHUcR8FxqY56dHhcGnQxEJ/IyQOMyWNSEfv76K2enimyJ8T5+Tvx3pw8ICBKetZ1B4n4A0KylxuT6nmnW942ybngfNyW5EYxZyHdIDlzg3yqWOTz6mpTEruK4saxz1XEP2QVD9zScvKSWdOTl8NYuqlR93J1dcBwMjcRKS7AJb3cDrODH3SMUUflyz2PzSnu4tIN8oDoLR1dvqUfKP562SE09VAxvjnOdzYbx1Akj80feGB+Dh/0Rd8FfjnONzw4jXjM9tX0Gypyf0B+cfQfzK2H6KL5q3mZTpleUPJJKZF/Wy+lgNWGM6Wu/xlnuAd1bBok+TCijhNY+eMM5S+M2EVIQvYALaDz95+y/jO1l49Yy+15IPzfkAUAdrZiwIT3fTYAAAAASUVORK5CYII=";

    return img;
  }

  /**
   *
   */
  descartesJS.getSvgMenu = function() {
    return "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCI+PHBhdGggZD0iTTYuNjQgOEwxMiAxMi45NjIgMTcuMzYgOCAxOSA5LjUxOSAxMiAxNiA1IDkuNTE5eiIvPjwvc3ZnPg==";
  }

  /**
   *
   */
  descartesJS.getSvgCheckbox = function() {
    return "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NSIgaGVpZ2h0PSI0NSI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMzcuMDk1IDYuMjg0TDE1LjQ3MyAyNy45MDVsLTcuNTY4LTcuNTY3TDIuNSAyNS43NDNsMTIuOTczIDEyLjk3M0w0Mi41IDExLjY5eiIgY29sb3I9IiMwMDAiIHNvbGlkLWNvbG9yPSIjMDAwMDAwIiBzdHlsZT0iYmxvY2stcHJvZ3Jlc3Npb246dGI7aXNvbGF0aW9uOmF1dG87bWl4LWJsZW5kLW1vZGU6bm9ybWFsO3RleHQtZGVjb3JhdGlvbi1jb2xvcjojMDAwO3RleHQtZGVjb3JhdGlvbi1saW5lOm5vbmU7dGV4dC1kZWNvcmF0aW9uLXN0eWxlOnNvbGlkO3RleHQtaW5kZW50OjA7dGV4dC10cmFuc2Zvcm06bm9uZSIgd2hpdGUtc3BhY2U9Im5vcm1hbCIvPjwvc3ZnPg==";
  }

  /**
   * Get the symbols font
   */
  descartesJS.symbolFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }

  /**
   * Get the extra font
   */
  descartesJS.extraBFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }
  descartesJS.extraBIFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }
  descartesJS.extraIFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }
  descartesJS.extraRFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }  

  /**
   * Get the sans serif font
   */
  descartesJS.arimoBFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }
  descartesJS.arimoBIFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }
  descartesJS.arimoIFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }
  descartesJS.arimoRFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }

  /**
   * Get the monospace font
   */
  descartesJS.cousineBFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }
  descartesJS.cousineBIFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }
  descartesJS.cousineIFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }
  descartesJS.cousineRFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }  

  /**
   * Get the serif font
   */
  descartesJS.tinosBFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }
  descartesJS.tinosBIFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }
  descartesJS.tinosIFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }
  descartesJS.tinosRFont = function() {
    return "data:font/woff2;charset=utf-8;base64,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";
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathFloor = Math.floor;
  var MathMin = Math.min;
  var evaluator;
  var tmpColor;
  var splitColor;
  var hexColor;
  var splitString;
  var splitColor_i;
  var numParentheses;
  var numSquareParenteses;
  var lastSplitIndex;
  var charAt;
  var r;
  var g;
  var b;
  var a;

  /**
   *
   */
  descartesJS.Color = function(color, evaluator) {
    var self = this;
    self.r = 0;
    self.g = 0;
    self.b = 0;
    self.a = 1;

    self.evaluator = evaluator;

    self.getColor = self.getColorStr;

    // construct a simple color
    if (!color) {
      self.colorStr = "rgba("+ self.r +","+ self.g +","+ self.b +","+ self.a + ")";
      return;
    }

    // the color is a color name
    if (babel[color]) {
      if (babel[color] === "net") {
        color = "rojo";
      }

      color = babel[color];

      self.r = parseInt("0x"+color.substring(1,3), 16);
      self.g = parseInt("0x"+color.substring(3,5), 16);
      self.b = parseInt("0x"+color.substring(5,7), 16);
      self.colorStr = color;
    }

    // the color is six hexadecimals digits #RRGGBB
    if (color.length === 6) {
      self.r = parseInt("0x"+color.substring(0,2), 16);
      self.g = parseInt("0x"+color.substring(2,4), 16);
      self.b = parseInt("0x"+color.substring(4,6), 16);
      self.colorStr = "#" + color;
    }

    // the color is eight hexadecimals digits #RRGGBBAA
    if (color.length === 8) {
      self.r = parseInt("0x"+color.substring(2,4), 16);
      self.g = parseInt("0x"+color.substring(4,6), 16);
      self.b = parseInt("0x"+color.substring(6,8), 16);
      self.a = (1-parseInt("0x"+color.substring(0,2), 16)/255);
      self.colorStr = "rgba("+ self.r +","+ self.g +","+ self.b +","+ self.a + ")";
    }

    // the color is a Descartes expression (exprR, exprG, exprB, exprA)
    if (color[0] === "(") {
      tmpColor = [];
      splitColor = self.splitComa(color.substring(1, color.length-1));

      for (var i=0, l=splitColor.length; i<l; i++) {
        splitColor_i = splitColor[i];
        hexColor = parseInt(splitColor_i, 16);
        
        if ( (splitColor_i !== hexColor.toString(16)) && (splitColor_i !== "0"+hexColor.toString(16)) ) {
          if ((splitColor_i.charAt(0) === "[") && (splitColor_i.charAt(splitColor_i.length-1) === "]")) {
            splitColor_i = splitColor_i.substring(1, splitColor_i.length-1);
          }

          tmpColor.push(self.evaluator.parser.parse( splitColor_i ));
        }
        else {
          tmpColor.push(self.evaluator.parser.parse( (hexColor/255).toString() ));
        }
      }

      self.rExpr = tmpColor[0];
      self.gExpr = tmpColor[1];
      self.bExpr = tmpColor[2];
      self.aExpr = tmpColor[3];

      self.getColor = self.getColorExp;
    }
  }

  /**
   * Split a string using a coma delimiter
   * @param {String} string the string to split
   * @return {Array<String>} return an array of the spliting string using a coma delimiter
   */
  descartesJS.Color.prototype.splitComa = function(string) {
    splitString = [];

    numParentheses = 0;
    numSquareParenteses = 0;

    lastSplitIndex = 0;

    for (var i=0, l=string.length; i<l; i++) {
      charAt = string.charAt(i);

      if (charAt === "(") {
        numParentheses++;
      }
      else if (charAt === ")") {
        numParentheses--;
      }
      else if (charAt === "[") {
        numSquareParenteses++;
      }
      else if (charAt === "]") {
        numSquareParenteses--;
      }
      else if ((charAt === ",") && (numParentheses === 0) && (numSquareParenteses === 0)) {
        splitString.push(string.substring(lastSplitIndex, i));
        lastSplitIndex = i+1;
      }
    }

    splitString.push(string.substring(lastSplitIndex));

    return splitString;
  }

  /**
   *
   */
  descartesJS.Color.prototype.getColorStr = function() {
    return this.colorStr;
  }

  /**
   *
   */
  descartesJS.Color.prototype.getColorExp = function() {
    var self = this;
    
    evaluator = self.evaluator;
    self.r = MathMin(255, MathFloor(evaluator.eval(self.rExpr) * 255));
    self.g = MathMin(255, MathFloor(evaluator.eval(self.gExpr) * 255));
    self.b = MathMin(255, MathFloor(evaluator.eval(self.bExpr) * 255));
    self.a = (1 - evaluator.eval(self.aExpr));

    return "rgba(" + self.r + "," + self.g + "," + self.b + "," + self.a + ")";
  }

  /**
   *
   */
  descartesJS.Color.prototype.borderColor = function() {
    return (this.r + this.g + this.b < 380) ? "#ffffff" : "#000000";
  }

  /**
   *
   */
  descartesJS.RGBAToHexColor = function(color) {
    color = color.substring(5, color.length-1).split(",");

    r = (color[0] >> 0).toString(16);
    g = (color[1] >> 0).toString(16);
    b = (color[2] >> 0).toString(16);
    a = (255 - ((parseFloat(color[3])*255) >> 0)).toString(16);

    if (r.length === 1) r = "0"+r;
    if (g.length === 1) g = "0"+g;
    if (b.length === 1) b = "0"+b;
    if (a.length === 1) a = "0"+a;

    return new descartesJS.Color(a+r+g+b);
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Add CSS rules for the lesson
   */
  (function() {
    ////////////////////////////////////////////////////////////////////
    // add metadata for tablets
    ////////////////////////////////////////////////////////////////////
    var head = document.head;

    // try chrome frame // <meta http-equiv="X-UA-Compatible" content="chrome=1">
    var meta = document.createElement("meta");
    meta.setAttribute("http-equiv", "X-UA-Compatible");
    meta.setAttribute("content", "IE=edge,chrome=1");
    // add the metadata to the head of the document
    head.appendChild(meta);

    meta = document.createElement("meta");
    meta.setAttribute("name", "viewport");
    meta.setAttribute("content", "width=device-width,initial-scale=1.0,user-scalable=yes");

    // add the metadata to the head of the document
    if (!document.querySelector("meta[name=viewport]")) {
      head.appendChild(meta);
    }

    meta = document.createElement("meta");
    meta.setAttribute("name", "apple-mobile-web-app-capable");
    meta.setAttribute("content", "yes");
    // add the metadata to the head of the document
    head.appendChild(meta);

    meta = document.createElement("meta");
    meta.setAttribute("name", "apple-mobile-web-app-status-bar-style");
    meta.setAttribute("content", "black");
    // add the metadata to the head of the document
    head.appendChild(meta);

    meta = document.createElement("meta");
    meta.setAttribute("name", "DescartesJS_author");
    meta.setAttribute("content", "Joel Espinosa Longi");

    // add the metadata to the head of the document
    head.appendChild(meta);
    ////////////////////////////////////////////////////////////////////

    // try to get the style
    var cssNode = document.getElementById("StyleDescartesApps2");

    // if the style exists, then the lesson was saved before, then remove the style
    if (cssNode) {
      (cssNode.parentNode).removeChild(cssNode);
    }

    cssNode = document.createElement("style");
    cssNode.type = "text/css";
    cssNode.id = "StyleDescartesApps2";
    cssNode.setAttribute("rel", "stylesheet");

    // add the style to the head of the document
    document.head.insertBefore(cssNode, document.head.firstChild);

    cssNode.innerHTML =
      "@font-face{font-family:'DJS_symbola';src:url('"+ descartesJS.symbolFont() +"') format('woff2');font-style:normal;font-weight:bold;}\n" +
      "@font-face{font-family:'DJS_symbola';src:url('"+ descartesJS.symbolFont() +"') format('woff2');font-style:italic;font-weight:bold;}\n" +
      "@font-face{font-family:'DJS_symbola';src:url('"+ descartesJS.symbolFont() +"') format('woff2');font-style:italic;font-weight:normal;}\n" +
      "@font-face{font-family:'DJS_symbola';src:url('"+ descartesJS.symbolFont() +"') format('woff2');font-style:normal;font-weight:normal;}\n" +

      "@font-face{font-family:'DJS_extra';src:url('"+ descartesJS.extraBFont()  +"') format('woff2');font-style:normal;font-weight:bold;}\n" +
      "@font-face{font-family:'DJS_extra';src:url('"+ descartesJS.extraBIFont() +"') format('woff2');font-style:italic;font-weight:bold;}\n" +
      "@font-face{font-family:'DJS_extra';src:url('"+ descartesJS.extraIFont()  +"') format('woff2');font-style:italic;font-weight:normal;}\n" +
      "@font-face{font-family:'DJS_extra';src:url('"+ descartesJS.extraRFont()  +"') format('woff2');font-style:normal;font-weight:normal;}\n" +

      "@font-face{font-family:'DJS_sansserif';src:url('"+ descartesJS.arimoBFont()  +"') format('woff2');font-style:normal;font-weight:bold;}\n" +
      "@font-face{font-family:'DJS_sansserif';src:url('"+ descartesJS.arimoBIFont() +"') format('woff2');font-style:italic;font-weight:bold;}\n" +
      "@font-face{font-family:'DJS_sansserif';src:url('"+ descartesJS.arimoIFont()  +"') format('woff2');font-style:italic;font-weight:normal;}\n" +
      "@font-face{font-family:'DJS_sansserif';src:url('"+ descartesJS.arimoRFont()  +"') format('woff2');font-style:normal;font-weight:normal;}\n" +

      "@font-face{font-family:'DJS_monospace';src:url('"+ descartesJS.cousineBFont()  +"') format('woff2');font-style:normal;font-weight:bold;}\n" +
      "@font-face{font-family:'DJS_monospace';src:url('"+ descartesJS.cousineBIFont() +"') format('woff2');font-style:italic;font-weight:bold;}\n" +
      "@font-face{font-family:'DJS_monospace';src:url('"+ descartesJS.cousineIFont()  +"') format('woff2');font-style:italic;font-weight:normal;}\n" +
      "@font-face{font-family:'DJS_monospace';src:url('"+ descartesJS.cousineRFont()  +"') format('woff2');font-style:normal;font-weight:normal;}\n" +

      "@font-face{font-family:'DJS_serif';src:url('"+ descartesJS.tinosBFont()  +"') format('woff2');font-style:normal;font-weight:bold;}\n" +
      "@font-face{font-family:'DJS_serif';src:url('"+ descartesJS.tinosBIFont() +"') format('woff2');font-style:italic;font-weight:bold;}\n" +
      "@font-face{font-family:'DJS_serif';src:url('"+ descartesJS.tinosIFont()  +"') format('woff2');font-style:italic;font-weight:normal;}\n" +
      "@font-face{font-family:'DJS_serif';src:url('"+ descartesJS.tinosRFont()  +"') format('woff2');font-style:normal;font-weight:normal;}\n" +
      
      ".PBL{position:absolute;background-color:#f2f2f2;border:none;-webkit-appearance:none;-moz-apearance:none;apearance:none;color:#2daae4;visibility:hidden;border-radius:100vw;}\n" +
      ".PBL::-moz-progress-bar{background:#2daae4;border-radius:inherit;}\n" +
      ".PBL::-webkit-progress-bar{background:#f2f2f2;border-radius:100vw;}\n" +
      ".PBL::-webkit-progress-value{background:#2daae4;border-radius:inherit;}\n" +
      ".PBL::-ms-fill{background:#2daae4;border-radius:inherit;}\n" +

      "canvas{transform:translate3d(0,0,0);}\n" +
      // "select{transform:scale(1);}\n" +
      
      "div.DescartesAppContainer html,div.DescartesAppContainer *,div.DescartesAppContainer *:before,div.DescartesAppContainer *:after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;}\n" +
      "div.DescartesCatcher{background-color:rgba(255,255,255,0);cursor:pointer;position:absolute;}\n" +
      "div.DescartesAppContainer{border:0 solid #000;overflow:hidden;position:relative;top:0;left:0;}\n" +
      "div.DescartesLoader{background-color:#fff;overflow:hidden;position:absolute;top:0;left:0;}\n" +
      "div.DescartesLoaderImage{position:absolute;background-repeat:no-repeat;background-position:center;overflow:hidden;top:0;left:0;width:100%;height:100%;}\n" +
      "canvas.DescartesLoaderBar{position:absolute;overflow:hidden;top:0;left:0;}\n" +
      "canvas.DescartesSpace2DCanvas,canvas.DescartesSpace3DCanvas,div.blocker{touch-action:none;position:absolute;overflow:hidden;left:0;top:0;}\n" +
      "div.DescartesSpace2DContainer,div.DescartesSpace3DContainer{position:absolute;overflow:hidden;line-height:0;}\n" +

      // style for check box
      ".DescartesCheckboxContainer input[type=checkbox],.DescartesCheckboxContainer input[type=radio]{display: none;}\n" +
      ".DescartesCheckboxContainer input[type=checkbox]+label::after,.DescartesCheckboxContainer input[type=radio]+label::after{position:absolute;left:0px;content:'';padding:0;margin:0;width:100%;height:100%;background:white;border: 1px solid gray;}\n" +
      ".DescartesCheckboxContainer input[type=checkbox]:checked+label::after,.DescartesCheckboxContainer input[type=radio]:checked+label::after{content:'';background:url("+ descartesJS.getSvgCheckbox() +") center center no-repeat;background-size:contain;background-color:white;}\n" +

      "canvas.DescartesButton{position:absolute;cursor:pointer;}\n" +
      "div.DescartesButtonContainer{position:absolute;overflow:hidden;}\n" +
      "div.DescartesButtonContainer div{display:inline-flex;justify-content:center;align-items:center;width:100%;height:100%;}\n" +
      "div.DescartesButtonContainer[data-active='false']::after{content:' ';position:absolute;left:0;top:0;width:100%;height:100%;background:rgba(240,240,240,0.6);pointer-events:none;}\n" +
      "div.DescartesSpinnerContainer,div.DescartesCheckboxContainer,div.DescartesTextFieldContainer,div.DescartesMenuContainer{background:lightgray;position:absolute;overflow:hidden;}\n" +
      "div.DescartesSpinnerContainer input,div.DescartesCheckboxContainer,div.DescartesTextFieldContainer input,div.DescartesMenuContainer select{border-radius:0;}\n" +
      ".DescartesCheckbox{position:absolute;}\n" +
      "input.DescartesSpinnerField,input.DescartesTextFieldField,input.DescartesMenuField,input.DescartesScrollbarField{font-family:"+ descartesJS.sansserif_font +";padding:0 2px;border:solid #666 1px;position:absolute;top:0;}\n" +
      "label.DescartesSpinnerLabel,label.DescartesCheckboxLabel,label.DescartesMenuLabel,label.DescartesScrollbarLabel,label.DescartesTextFieldLabel{font-family:"+ descartesJS.sansserif_font +";font-weight:normal;text-align:center;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;background-color:#e0e4e8;position:absolute;left:0;top:0;}\n" +
      "div.DescartesGraphicControl{touch-action:none;border-style:none;position:absolute;}\n" +
      "div.DescartesTextAreaContainer{position:absolute;overflow:hidden;background:#F7F7F7;}\n" +
      "select.DescartesMenuSelect{font-family:"+ descartesJS.sansserif_font +";padding-top:0;text-align:center;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;position:absolute;border:1px solid #7a8a99; background:#fff url('"+ descartesJS.getSvgMenu() +"') 100%/22px no-repeat;padding:0 22px 0 5px;-webkit-appearance:none;-moz-appearance:none;appearance:none;}\n" +
      "select.DescartesMenuSelect::-ms-expand{display:none;}\n" + // corrects the aparence in internet explorer
      "div.DescartesScrollbarContainer{touch-action:none;background:#eee;overflow:hidden;position:absolute;}\n";
  })();
  // immediately add the style to the document

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathSin = Math.sin;
  var MathFloor = Math.floor;
  var MathRandom = Math.random;
  var MathRound = Math.round;
  var MathAbs = Math.abs;
  var stringfromCharCode = String.fromCharCode;
  
  var a1 = 1.0;
  var a2 = 1.4;
  var a3 = 0.6;
  var a4 = 2.2;

  var ll;

  var n;
  var k;
  var a;
  var b;
  var c;

  var encripMeu;
  var desencripMeu;
  var nx;
  var x;
  var y;

  /**
   * Descartes krypto
   * @constructor 
   * @param {String} key the key of encryptation
   */
  descartesJS.Krypto = function(key){
    key = key || 0;
    this.key = key.toString();
  }

  /**
   * @param {Number} n
   * @return {String}
   */
  descartesJS.Krypto.prototype.getKey = function(n) {
    ll = [];
    for (var i=0; i<256; i++) {
      ll[i] = stringfromCharCode(this.alfanum( MathFloor( MathAbs(7.5*(MathSin(a1*i-n) + MathSin(a2*i+n) + MathSin(a3*i-n) + MathSin(a4*i+n))) ) ));
    }
    
    return ll.join("");
  }
  
  /**
   * @param {String} s the string to encode
   * @return {String}
   */
  descartesJS.Krypto.prototype.encode = function(s) {
    n = MathFloor(31*MathRandom());
    this.key = this.getKey(n);
    
    return stringfromCharCode(this.alfanum(n)) + this.encripta(s);
  }
  
  /**
   * @param {String} s the string to decode
   * @return {String}
   */
  descartesJS.Krypto.prototype.decode = function(s) {
    n = this.numalfa( s.charCodeAt(0) );
    this.key = this.getKey(n);

    return this.desencripta(s.substring(1));
  }

  /**
   * @param {String} OrigMeu
   * @return {String}
   */
  descartesJS.Krypto.prototype.encripta = function(OrigMeu) {
    return this.bytesToString( this.encriptaAux(this.stringToBytes(OrigMeu)));
  }
  
  /**
   * @param {Array<Bytes>} OrigMeu
   * @return {String}
   */
  descartesJS.Krypto.prototype.encriptaAux = function(OrigMeu) {
    if (OrigMeu == null) {
      return null;
    }
    
    if (this.key == null) {
      return null;
    }
    
    encripMeu = new Array(3*OrigMeu.length);
    
    for (var i=0, l=OrigMeu.length; i<l; i++) {
      x = MathFloor(OrigMeu[i]+128)*256 + MathRound(MathRandom()*255) + MathRound(MathRandom()*255)*256*256;
      y = MathFloor((x<<this.shift(i))/256);

      encripMeu[3*i]   = this.alfanum(y%32); 
      encripMeu[3*i+1] = this.alfanum((y/32)%32);
      encripMeu[3*i+2] = this.alfanum((y/1024)%32);
    }

    return encripMeu;
  }
    
  /**
   * @param {String} OrigMeu
   * @return {String}
   */
  descartesJS.Krypto.prototype.desencripta = function(OrigMeu) {
    return this.bytesToString( this.desencriptaAux(this.stringToBytes(OrigMeu)));
  }
  
  /**
   * @param {Array<Bytes>} OrigMeu
   * @return {String}
   */
  descartesJS.Krypto.prototype.desencriptaAux = function(OrigMeu) {
    if (OrigMeu == null) {
      return null;
    }
    if (this.key == null) {
      return null;
    }

    desencripMeu = new Array(OrigMeu.length/3);

    for (var i=0, l=desencripMeu.length; i<l; i++) {
      y = this.numalfa(OrigMeu[3*i]) + this.numalfa(OrigMeu[3*i+1])*32 + this.numalfa(OrigMeu[3*i+2])*1024;
      x = MathFloor((y*256)>>this.shift(i));
      
      nx = (MathFloor(x/256)%256)-128;
      if (nx < 0) {
        nx = nx +256;
      }
      
      desencripMeu[i] = nx;
    }
    
    return desencripMeu;   
  }
  
  /**
   * @param Number {Array<Number>} k
   * @return Number {Array<Number>}
   */
  descartesJS.Krypto.prototype.alfanum = function(k) {
    k = MathFloor(k);
    if (k<10) {
      return 48 + k;
    } else {
      return 87 + k;
    }
  }
  
  /**
   * @param Number {Array<Number>} b
   * @return Number {Array<Number>}
   */
  descartesJS.Krypto.prototype.numalfa = function(b) {
    if (b<58) {
      return b-48;
    } else {
      return b-87;
    }
  }
  
  /**
   * @param {String} 
   * @return {Array<Number>}
   */
  descartesJS.Krypto.prototype.stringToBytes = function(OrigMeu) {
    b = new Array(OrigMeu.length);
    
    for (var i=0, l=OrigMeu.length; i<l; i++) {
      b[i] = OrigMeu.charCodeAt(i);
    }
    
    return b;
  }

  /**
   * @param {Array<Number>}
   * @return {String} 
   */
  descartesJS.Krypto.prototype.bytesToString = function(b) {
    for (var i=0, l=b.length; i<l; i++) {
      b[i] = stringfromCharCode(b[i]);
    }

    return b.join("");
  }
  
  /**
   * @param {Number}
   * @return {Number} 
   */
  descartesJS.Krypto.prototype.shift = function(i) {
    a = (this.key).charCodeAt(i%(this.key.length));
    b = this.numalfa(a);
    c = MathFloor((b/2)%8);
    if (c == 0) {
      c = 4;
    }
    return c;
  }

  /**
   * @param {String} n
   * @return {Array<Number>}
   */
  descartesJS.Krypto.prototype.parseByte = function(n) {
    n = parseInt(n);
    n = (n < 0) ? 0 : n;
    n = (n > 255) ? 255 : n;
    
    return n;
  }
  
  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathMax = Math.max;

  /**
   * Descartes animation
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the graphic
  */
  descartesJS.Animation = function(parent, values) {
    /**
     * Descartes application
     * type {DescartesApp}
     * @private
     */
    this.parent = parent;

    var tmp;
    var evaluator = parent.evaluator;
    var parser = evaluator.parser;
    var algorithmAuxiliary = new descartesJS.Auxiliary(parent);
    var self = this;

    self.delay = (values.delay) ? parser.parse(values.delay) : parser.parse("60");
    self.loop = (values.loop) ? values.loop : false;
    self.auto = (values.auto == undefined) ? true : values.auto;
    self.controls = values.controls;
    
    // parse the init expression
    self.init = algorithmAuxiliary.splitInstructions(parser, values.init);

    // parse the do expression
    self.doExpr = algorithmAuxiliary.splitInstructions(parser, values.doExpr);

    // parse the while expression
    if (values.whileExpr) {
      self.whileExpr = parser.parse(values.whileExpr);
    }
    
    var i;
    var l = self.doExpr.length;

    self.animExec = function() {  
      for (i=0; i<l; i++) {
        evaluator.eval(self.doExpr[i]);
      }
      self.parent.update();

      if ( (self.playing) && ((evaluator.eval(self.whileExpr) > 0) || (self.loop)) ) {
        self.timer = descartesJS.setTimeout(self.animExec, evaluator.eval(self.delay));
      } 
      else {
        self.stop();
        self.pause = false;
        self.parent.update();
      }
    }

    self.playing = false;

    // init the animation automatically
    if (self.auto) {
      self.play();
    }    
  }  
  
  /**
   * Play the animation
   */
  descartesJS.Animation.prototype.play = function() {
    if (!this.playing) {
      if (!this.pause) {
        this.reinit();
      }

      this.playing = true;
      this.pause = false;
      this.timer = descartesJS.setTimeout(this.animExec, MathMax(10, this.parent.evaluator.eval(this.delay)));
    } 
    else {
      this.pause = true;
      this.stop();
    }
  }

  /**
   * Stop the animation
   */
  descartesJS.Animation.prototype.stop = function() {
    this.playing = false;
    descartesJS.clearTimeout(this.timer);
  }
  
  /**
   * Reinit the animation
   */
  descartesJS.Animation.prototype.reinit = function() {
    for (var i=0, l=this.init.length; i<l; i++) {
      this.parent.evaluator.eval(this.init[i]);
    }
  }
  
  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }
  
  /**
   * Descartes action
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} parameter the values of the action
   */
  descartesJS.Action = function(parent, parameter) {
    /**
     * Descartes application
     * type {DescartesApp}
     * @private
     */
    this.parent = parent;

    this.evaluator = this.parent.evaluator;
  }  
  
  /**
   * Execute the action
   */
  descartesJS.Action.prototype.execute = function() { }
  
  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes message action
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} parameter the values of the action
   */
  descartesJS.Message = function(parent, parameter) {
    // call the parent constructor
    descartesJS.Action.call(this, parent, parameter);
    
    this.parameter = (parameter || "").replace(/\\n/g, "\n").replace(/&squot;/g, "'");
  }  
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Action
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Message, descartesJS.Action);

  /**
   * Execute the action
   */
  descartesJS.Message.prototype.execute = function() {
    alert(this.parameter);
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes calculate action
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} parameter the values of the action
   */
  descartesJS.Calculate = function(parent, parameter) {
    // call the parent constructor
    descartesJS.Action.call(this, parent, parameter);

    var evaluator = this.evaluator;
    var parser = evaluator.parser;

    // replace the semicolon with a newline, since both notations can appear in the expression
    parameter = parameter || "";
    parameter = parameter.replace(/&squot;/g, "'");
    parameter = descartesJS.splitSeparator(parameter);

    // add only the instructions tha execute something, i.e. instructions with parsing different of null
    var tmpParameter = [];
    var tmp;
    for (var i=0, l=parameter.length; i<l; i++) {
      tmp = parser.parse(parameter[i], true);
      if (tmp) {
        tmpParameter.push(tmp);
      }
    }

    var i;
    var l = tmpParameter.length;
    /**
     * Execute the action
     */
    this.execute = function() {
      for (i=0; i<l; i++) {
        evaluator.eval(tmpParameter[i]);
      }
    }

  }  
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Action
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Calculate, descartesJS.Action);

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes open URL action
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} parameter the values of the action
   */
  descartesJS.OpenURL = function(parent, parameter) {
    // call the parent constructor
    descartesJS.Action.call(this, parent, parameter);

    this.parser = parent.evaluator.parser;
    this.evaluator = parent.evaluator;    

    this.parameter = parameter;
    this.target = "_blank";
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Action
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.OpenURL, descartesJS.Action);

  /**
   * Execute the action
   */
  descartesJS.OpenURL.prototype.execute = function() {
    var theParameter = this.parameter;

    if ((theParameter.charAt(0) === "[") && (theParameter.charAt(theParameter.length-1) === "]")) {
      theParameter = this.evaluator.eval( this.parser.parse(theParameter.substring(1, theParameter.length-1)) );
    }

    var indexOfTarget = theParameter.indexOf("target");

    if (indexOfTarget != -1) {
      this.target = theParameter.substring(indexOfTarget);
      this.target = this.target.substring(this.target.indexOf("=")+1);
      theParameter = theParameter.substring(0, indexOfTarget-1);
    }

    // if the parameter is JavaScript code
    if (theParameter.substring(0,10) == "javascript") {
      // replace the &squot; with '
      theParameter = new descartesJS.SimpleText(parent, (theParameter.substring(11)).replace(/&squot;/g, "'"));

      try {
        eval(theParameter.toString());
        return;
      }
      catch(e) {}
    }
    // if the paramater is a file name
    else {
      // if the parameter is a file name relative to the current page
      if (theParameter.substring(0,4) != "http") {
        var location = window.__dirname || window.location.href;
        theParameter = location.substring(0, location.lastIndexOf("/")+1) + theParameter;
      }

      // build an action to open a new page relative to the actual page
      window.open(theParameter, this.target);
      return;
    }
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes openscene action
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} parameter the values of the action
   */
  descartesJS.OpenScene = function(parent, parameter) {
    // call the parent constructor
    descartesJS.Action.call(this, parent, parameter);
    
    this.parser = parent.evaluator.parser;
    this.evaluator = parent.evaluator;

    this.parameter = parameter.trim();
    this.target = "_blank";
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Action
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.OpenScene, descartesJS.Action);

  /**
   * Execute the action
   */
  descartesJS.OpenScene.prototype.execute = function() {
    var theParameter = this.parameter;

    if ((theParameter.charAt(0) === "[") && (theParameter.charAt(theParameter.length-1) === "]")) {
      theParameter = this.evaluator.eval( this.parser.parse(theParameter.substring(1, theParameter.length-1)) );
    }

    var indexOfTarget = theParameter.indexOf("target");
    
    if (indexOfTarget != -1) {
      this.target = theParameter.substring(indexOfTarget);
      this.target = this.target.substring(this.target.indexOf("=")+1);
      theParameter = theParameter.substring(0, indexOfTarget-1);
    }

    // if the parameter is JavaScript code
    if (theParameter.substring(0,10) == "javascript") {
      // replace the &squot; with '
      theParameter = (theParameter.substring(11)).replace(/&squot;/g, "'");

      try {
        eval(theParameter.toString());
        return;
      }
      catch(e) {}
    } 

    // if the paramater is a file name
    else {
      // if the parameter is a file name relative to the current page
      if (theParameter.substring(0,4) != "http") {
        var location = window.__dirname || window.location.href;
        theParameter = location.substring(0, location.lastIndexOf("/")+1) + theParameter;
      }
 
      // build an action to open a new page relative to the actual page
      window.open(theParameter, this.target, "width=" + this.parent.width + ",height=" + this.parent.height + ",left=" + (window.screen.width - this.parent.width)/2 + ", top=" + (window.screen.height - this.parent.height)/2 + "location=0,menubar=0,scrollbars=0,status=0,titlebar=0,toolbar=0");
      return;
    }
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes config action
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} parameter the values of the action
   */
  descartesJS.Config = function(parent, parameter) {
    // call the parent constructor
    descartesJS.Action.call(this, parent, parameter);
  }  
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Action
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Config, descartesJS.Action);

  var jsScript = "<script type='text/javascript' src='http://arquimedes.matem.unam.mx/Descartes5/lib/descartes-min.js'></script>\n";


  /**
   * Execute the action
   */
  descartesJS.Config.prototype.execute = function() {
    if (this.parent.editor) {
      this.parent.editor.show();
    }
    else {
      var codeWindow = window.open("about:blank", "_blank", "width=800px,height=600px,location=no,menubar=no,scrollbars=yes")
      codeWindow.document.write("<xmp style='width:100%; height:100%;'>" + jsScript + (this.parent.applet.outerHTML.replace(/<applet/g, "<ajs").replace(/<\/applet/g, "</ajs")) + "</xmp>");
    }
    
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes init action
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} parameter the values of the action
   */
  descartesJS.Init = function(parent, parameter) {
    // call the parent constructor
    descartesJS.Action.call(this, parent, parameter);
  }  
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Action
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Init, descartesJS.Action);

  /**
   * Execute the action
   */
  descartesJS.Init.prototype.execute = function() {
    this.parent.init();
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes clear action
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} parameter the values of the action
   */
  descartesJS.Clear = function(parent, parameter) {
    // call the parent constructor
    descartesJS.Action.call(this, parent, parameter);
  }  
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Action
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Clear, descartesJS.Action);

  /**
   * Execute the action
   */
  descartesJS.Clear.prototype.execute = function() {
    this.parent.clear();
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes animate action
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} parameter the values of the action
   */
  descartesJS.Animate = function(parent, parameter) {
    // call the parent constructor
    descartesJS.Action.call(this, parent, parameter);
  }  
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Action
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Animate, descartesJS.Action);

  /**
   * Execute the action
   */
  descartesJS.Animate.prototype.execute = function() {
    this.parent.play();
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes init animation action
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} parameter the values of the action
   */
  descartesJS.InitAnimation = function(parent, parameter) {
    // call the parent constructor
    descartesJS.Action.call(this, parent, parameter);
  }  
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Action
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.InitAnimation, descartesJS.Action);
  
  /**
   * Execute the action
   */
  descartesJS.InitAnimation.prototype.execute = function() {
    this.parent.reinitAnimation();
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var regExpAudio = /[\w\.\-//]*(\.ogg|\.oga|\.mp3|\.wav)/gi;

  /**
   * Descartes play audio action
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} parameter the values of the action
   */
  descartesJS.PlayAudio = function(parent, parameter) {
    // call the parent constructor
    descartesJS.Action.call(this, parent, parameter);
   
    parameter = parameter || '';
    if (parameter.match(regExpAudio)) {
      this.filenameExpr = this.evaluator.parser.parse("'" + parameter.match(regExpAudio) + "'");
    }
    else {
      // if the parameter inits with braces [], extract the expression
      if ( (parameter !== '') && (parameter.charAt(0) === '[') && (parameter.charAt(parameter.length-1) === ']') ) {
        parameter = parameter.substring(1, parameter.length-1);
      }
      this.filenameExpr = this.evaluator.parser.parse(parameter);
    }
  }  
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Action
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.PlayAudio, descartesJS.Action);
  
  /**
   * Execute the action
   */
  descartesJS.PlayAudio.prototype.execute = function() {
    this.theAudio = this.parent.getAudio( this.evaluator.eval(this.filenameExpr) );

    var theAudio = this.theAudio;

    // if the audio is paused then play it
    if (theAudio.paused) {
      theAudio.play();
    }
    // if the audio is playing then stop it
    else {
      theAudio.pause();
      theAudio.currentTime = 0.0;
    }
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }
  
  /**
   * Descartes auxiliary
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the auxiliary
   */
  descartesJS.Auxiliary = function(parent, values) {
    /**
     * Descartes application
     * type {DescartesApp}
     * @private
     */
    this.parent = parent;
    this.evaluator = this.parent.evaluator;

    var parser = parent.evaluator.parser;

    /**
     * identifier of the auxiliary
     * type {String}
     * @private
     */
    this.id = "";
    
    /**
     * the expression of the auxiliary
     * type {String}
     * @private
     */
    this.expresion = "";

    /**
     * type of evaluation of the auxiliary
     * type {String}
     * @private
     */
    this.evaluate = "onlyOnce";

    this.local = "";

    // traverse the values to replace the defaults values of the object
    for (var propName in values) {
      // verify the own properties of the object
      if (values.hasOwnProperty(propName)) {
        this[propName] = values[propName];
      }
    }
  }  
  
  /**
   * Set the first run of an algotithm
   */
  descartesJS.Auxiliary.prototype.firstRun = function() { };

  /**
   * Update the auxiliary
   */
  descartesJS.Auxiliary.prototype.update = function() { };

  var tmp;
  var tmpExpression;
  
  /**
   * Split the expression using the semicolon as separator, ignoring the empty expressions
   * @param {Parser} parser a Descartes parser object
   * @param {String} expression the expression to split
   * @return {Array<Node>} return an array of nodes correspoding to the expression split
   */
  descartesJS.Auxiliary.prototype.splitInstructions = function(parser, expression) {
    tmpExpression = [];

    expression = (expression) ? descartesJS.splitSeparator(expression) : [""];

    // add only the instructions that execute something, i.e. instructions whit parsing different of null
    for (var i=0, l=expression.length; i<l; i++) {
      descartesJS.DEBUG.lineCount = i;
      tmp = parser.parse(expression[i], true);
      if (tmp) {
        tmpExpression.push(tmp);
      }
    }
    
    return tmpExpression;
  }

  /**
   *
   */
  descartesJS.Auxiliary.prototype.getPrivateVariables = function(parser, expression) {
    tmpExpression = [];

    if (expression) {
      expression = expression.split(/;|,/);
    } else {
      expression = [""];
    }

    // add only the instructions tha execute something, i.e. instructions whit parsing different of null
    for (var i=0, l=expression.length; i<l; i++) {
      tmp = parser.parse(expression[i], true);
      if (tmp) {
        tmpExpression.push(tmp);
      }
    }    

    // add the identifier nodes to local variables
    for (var i=0, l=tmpExpression.length; i<l; i++) {
      if (tmpExpression[i].type === "asign") {
        tmpExpression[i] = tmpExpression[i].childs[0].value;
      }
      else if (tmpExpression[i].type === "identifier") {
        tmpExpression[i] = tmpExpression[i].value;
      }
      else {
        tmpExpression[i] = "";
      }
    }

    return tmpExpression;
  }

  /**
   *
   */
  descartesJS.Auxiliary.prototype.parseExpressions = function(parser) {
    descartesJS.DEBUG.paramName = "inicio";
    // parse the init expression
    this.init = this.splitInstructions(parser, this.init);

    descartesJS.DEBUG.paramName = "local";
    // parse the local expression
    this.privateVars = this.getPrivateVariables(parser, this.local);

    descartesJS.DEBUG.paramName = "hacer";
    // parse the do expression
    this.doExpr = this.splitInstructions(parser, this.doExpr);
    
    descartesJS.DEBUG.paramName = "mientras";
    // parse the while expression
    this.whileExpr = parser.parse(this.whileExpr);
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes variable
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the auxiliary
   */
  descartesJS.Variable = function(parent, values){
    // call the parent constructor
    descartesJS.Auxiliary.call(this, parent, values);

    var parser = this.evaluator.parser;
 
    this.expresionString = this.expresion;
    this.expresion = parser.parse(this.expresionString);

    if (this.expresion) {
      parser.setVariable(this.id, this.expresion);
    }
    
    if (this.editable) {
      this.registerTextField();
      this.parent.editableRegionVisible = true;
    }    
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Auxiliary
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Variable, descartesJS.Auxiliary);
  
  /**
   * 
   */
  descartesJS.Variable.prototype.registerTextField = function() {
    var container = document.createElement("div");

    var label = document.createElement("label");
    // underscores are added at the beginning and end to determine the initial size of the label
    label.appendChild( document.createTextNode("___" + this.id + "=___") );
    
    var textField = document.createElement("input");
    textField.value = this.expresionString;
    textField.disabled = !(this.editable);

    container.appendChild(label);
    container.appendChild(textField);

    var self = this;
    var parser = self.evaluator.parser;
    textField.onkeydown = function(evt) {
      if (evt.keyCode == 13) {
        self.expresion = parser.parse(this.value);
        
        parser.setVariable(self.id, self.expresion);
        self.parent.update();
      }
    }
    
    var containerTextField = { container: container,  type: "div" };
    this.parent.editableRegion.textFields.push(containerTextField);
  }
  
  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes constant
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the auxiliary
   */
  descartesJS.Constant = function(parent, values){
    // call the parent constructor
    descartesJS.Auxiliary.call(this, parent, values);
    
    this.expresion = this.evaluator.parser.parse(this.expresion);
    this.update();
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Auxiliary
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Constant, descartesJS.Auxiliary);
  
  /**
   * Update constant
   */
  descartesJS.Constant.prototype.update = function() {
    this.evaluator.setVariable(this.id, this.evaluator.eval(this.expresion));
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var evaluator;
  var parser;
  var newFile;
  var response;

  /**
   * Descartes vector
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the auxiliary
   */
  descartesJS.Vector = function(parent, values) {
    evaluator = parent.evaluator;
    parser = evaluator.parser;

    /**
     * number of elements of the vector
     * type {Node}
     * @private
     */
    this.size = parser.parse("3");

    // call the parent constructor
    descartesJS.Auxiliary.call(this, parent, values);
    
    this.expresion = this.expresion.split(";");

    this.parseFile = parser.parse(this.file);
    
    this.update();
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Auxiliary
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Vector, descartesJS.Auxiliary);

  /**
   * Update the vector
   */
  descartesJS.Vector.prototype.update = function() {
    var expresion = this.expresion;

    evaluator = this.evaluator;
    parser = evaluator.parser;

    // if the filename is a variable
    this.oldFile = this.file;
    newFile = evaluator.eval(this.parseFile);
    if (newFile) {
      this.file = newFile;
    }

    var response;
    // if has an asociate file then read it
    if (this.file) {
      // if the vector is embedded in the page
      vectorElement = document.getElementById(this.file);
      if ((vectorElement) && (vectorElement.type == "descartes/vectorFile")) {
        response = vectorElement.text;
      }
      // read the vector data from a file
      else {
        response = descartesJS.openExternalFile(this.file);
      }

      // if the read information has content, split the content
      if (response != null) {
        response = response.replace(/\r/g, "").split("\n");

        var tmpResponse = [];
        for (var i=0,l=response.length; i<l; i++) {

          if (response[i] != "") {
            tmpResponse.push( response[i] );
          }
        }
        response = tmpResponse;
      }

      // if the file has no content or could not be read
      if ( (response == null) || ((response.length == 1) && (response[0] == "")) ) {
        response = [];
        this.size = parser.parse( "0" );
      }
      // if the file has content and could be read
      else {
        expresion = response;
        this.size = null;
      }
      
      if (this.size === null) {
        this.size = parser.parse( expresion.length + "" );
      }
    }

    var tmpExp;
    var newExpression = [];
    // parse the elements of the expression
    for(var i=0, l=expresion.length; i<l; i++) {
      tmpExp = parser.parse(expresion[i], true);

      // if the expression is not an assignment
      if ((tmpExp) && (tmpExp.type != "asign")) {
        tmpExp = parser.parse( this.id + "[" + i + "]=" + expresion[i], true );
      }

      newExpression.push( tmpExp );
    }

    var vectInit = [];
    vectInit._size_ = evaluator.eval(this.size);
    for (var i=0, l=this._size_; i<l; i++) {
      vectInit.push(0);
    }
    evaluator.vectors[this.id] = vectInit;

    evaluator.setVariable(this.id + ".long", vectInit._size_);

    for(var i=0, l=newExpression.length; i<l; i++) {
      evaluator.eval(newExpression[i]);
    }    
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes matrix
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the auxiliary
   */
  descartesJS.Matrix = function(parent, values){
    var evaluator = parent.evaluator;
    var parser = evaluator.parser;

    /**
     * number of rows of a matrix
     * type {Node}
     * @private
     */
    this.rows = parser.parse("3");

    /**
     * number of columns of a matrix
     * type {Node}
     * @private
     */
    this.columns = parser.parse("3");

    // call the parent constructor
    descartesJS.Auxiliary.call(this, parent, values);

    // parse the expression
    this.expresion = this.splitInstructions(parser, this.expresion);

    var rows = evaluator.eval(this.rows);
    var cols = evaluator.eval(this.columns);

    var mat = [];
    mat.type = "matrix";
    
    var vectInit;
    for (var j=0, k=cols; j<k; j++) {
      vectInit = [];
      for (var i=0, l=rows; i<l; i++) {
        vectInit.push(0);
      }
      mat[j] = vectInit;
    }
    evaluator.matrices[this.id] = mat;
    
    this.update();
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Auxiliary
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Matrix, descartesJS.Auxiliary);

  /**
   * Update the matrix
   */
  descartesJS.Matrix.prototype.update = function() {
    var evaluator = this.evaluator;
    var rows = evaluator.eval(this.rows);
    var cols = evaluator.eval(this.columns);

    evaluator.setVariable(this.id + ".filas", rows);
    evaluator.setVariable(this.id + ".columnas", cols);

    var mat = evaluator.matrices[this.id];
    mat.rows = rows;
    mat.cols = cols;

    for(var i=0, l=this.expresion.length; i<l; i++) {
      evaluator.eval(this.expresion[i]);
    }
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes function
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the auxiliary
   */
  descartesJS.Function = function(parent, values){
    // call the parent constructor
    descartesJS.Auxiliary.call(this, parent, values);

    var evaluator = this.evaluator;
    var parser = evaluator.parser;

    var parPos = this.id.indexOf("(");
    this.name = this.id.substring(0, parPos);
    this.params = this.id.substring(parPos+1, this.id.indexOf(")"));
    this.domain = (this.range) ? parser.parse(this.range) : parser.parse("1");

    if (this.params == "") {
      this.params = [];
    } else {
      this.params = this.params.split(",");
    }
    
    this.numberOfParams = this.params.length;

    // if do not have an algorithm ignore the init, doExpr and whileExpr values
    if (!this.algorithm) {
      this.init = "";
      this.doExpr = "";
      this.whileExpr = "";
    }

    this.parseExpressions(parser);
      
    this.expresion = parser.parse(this.expresion);

    var self = this;

    this.functionExec = function() {
      self.iterations = 0;

      if (self.numberOfParams <= arguments.length) {

        // saves the private variables
        var localVars = [];
        for (var i=0, l=self.privateVars.length; i<l; i++) {
          localVars.push( evaluator.getVariable(self.privateVars[i]) );
          // set the local variables to 0
          evaluator.setVariable(self.privateVars[i], 0);
        }

        // saves the variable values ​​that have the same names as function parameters
        var paramsTemp = [];
        for (var i=0, l=self.params.length; i<l; i++) {
          paramsTemp[i] = evaluator.getVariable(self.params[i]);
          // associated input parameters of the function with parameter names
          evaluator.setVariable(self.params[i], arguments[i]);
        }
        
        for (var i=0, l=self.init.length; i<l; i++) {
          evaluator.eval(self.init[i]);
        }
        
        do {
          for (var i=0, l=self.doExpr.length; i<l; i++) {
            evaluator.eval(self.doExpr[i]);
          }

          if (++self.iterations > 100000) {
            console.log("se ha excedido el límite de 100000 repeticiones en la función << " + self.name + " >>");
            return 0;
          }
        }
        while (evaluator.eval(self.whileExpr) > 0);

        // evaluates to the return value
        var result = evaluator.eval(self.expresion);
        descartesJS.rangeOK = evaluator.eval(self.domain);

        // restore the variable values that have the same names as function parameters
        for (var i=0, l=self.params.length; i<l; i++) {
          evaluator.setVariable(self.params[i], paramsTemp[i]);
        }

        // restore the local variable values
        for (var i=0, l=self.privateVars.length; i<l; i++) {
          evaluator.setVariable(self.privateVars[i], localVars[i]);
        }          
      
        return result;
      }
      
      return 0;
    }

    
    evaluator.setFunction(this.name, this.functionExec);
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Auxiliary
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Function, descartesJS.Auxiliary);

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes function
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the auxiliary
   */
  descartesJS.JsFunction = function(parent, values){
    this.code = "";
    
    // call the parent constructor
    descartesJS.Auxiliary.call(this, parent, values);

    var evaluator = this.evaluator;
    // var parser = evaluator.parser;

    var parPos = this.id.indexOf("(");
    this.name = this.id.substring(0, parPos);

    this.params = this.id.substring(parPos+1, this.id.indexOf(")"));
    this.params = (this.params === "") ? [] : this.params.split(",");

    this.functionCode = this.code.replace(/\\;/g, ";") + ";\nreturn " + (this.expresion || 0) + ";";
    // this.functionCode = this.functionCode.replace(/getVar/g, "this.getVariable").replace(/setVar/g, "this.setVariable");
// console.log(this.functionCode)
    this.functionExec = new Function(this.params, this.functionCode);
    evaluator.setFunction(this.name, this.functionExec);
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Auxiliary
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.JsFunction, descartesJS.Auxiliary);

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes algorithm
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the auxiliary
   */
  descartesJS.Algorithm = function(parent, values){
    // call the parent constructor
    descartesJS.Auxiliary.call(this, parent, values);

    var evaluator = this.evaluator;
    this.parseExpressions(evaluator.parser);
    
    var self = this;

    // create the function to exec when the algorithm evaluates
    this.algorithmExec = function() {
      self.iterations = 0;

      for (var i=0, l=self.init.length; i<l; i++) {
        evaluator.eval(self.init[i]);
      }
      
      do {
        for (var i=0, l=self.doExpr.length; i<l; i++) {
          evaluator.eval(self.doExpr[i]);
        }

        if (++self.iterations > 100000) {
          console.log("se ha excedido el límite de 100000 repeticiones en el algoritmo << " + self.name + " >>");
          return 0;
        }
      }
      while (evaluator.eval(self.whileExpr) > 0);
    }
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Auxiliary
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Algorithm, descartesJS.Auxiliary);

  /**
   * Update the algorithm
   */
  descartesJS.Algorithm.prototype.update = function() {
    this.algorithmExec();
    
    if (this.evaluate === "onlyOnce") {
      this.update = function() {};
    }
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes event
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the auxiliary
   */
  descartesJS.Event = function(parent, values){
    // call the parent constructor
    descartesJS.Auxiliary.call(this, parent, values);
    
    var evaluator = this.evaluator;
    
    delete(this.evaluate);
    this.condition = evaluator.parser.parse(this.condition);
    this.lastEvaluation = false;

    this.action = this.parent.lessonParser.parseAction(this);
    
    // if the type of evaluation is onlyOnce
    if (this.execution == "onlyOnce") {
      this.eventExec = function() {
        if ((this.evaluator.eval(this.condition) > 0) && (!this.lastEvaluation)) {
          this.lastEvaluation = true;
          this.action.execute();
        }
      }
    }
    
    // if the type of evaluation is alternate
    if (this.execution == "alternate") {
      this.eventExec = function() {
        var cond = (this.evaluator.eval(this.condition) > 0);
        //////////////////////////////////////////////////////////////////
        // DESCARTES 3
        if (this.parent.version == 3) {
          if (cond != this.lastEvaluation) {
            this.action.execute();
            this.lastEvaluation = (cond) ? true : false;
          }
        }
        // DESCARTES 3
        //////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////
        // other versions
        else {
          // if the condition was true and the last time was not executed, then the event is executed
          if ((cond) && (!this.lastEvaluation)) {
            this.action.execute();
            this.lastEvaluation = true;
          }
          // if already run once and the condition is evaluated to false, then rerun the event
          else if ((!cond) && (this.lastEvaluation)) {
            this.lastEvaluation = false;
          }
        }
        //////////////////////////////////////////////////////////////////
        
      }
    }

    // if the type of evaluation is always
    if (this.execution == "always") {
      this.eventExec = function() {
        if (this.evaluator.eval(this.condition) > 0) {
          this.action.execute();
        }
      }
    }
    
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Auxiliary
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Event, descartesJS.Auxiliary);

  /**
   * Update the event
   */
  descartesJS.Event.prototype.update = function() {
    this.eventExec();
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes Library
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the auxiliary
   */
  descartesJS.Library = function(parent, values){
    // call the parent constructor
    descartesJS.Auxiliary.call(this, parent, values);

    var filename = values.file;

    if (filename) {
      // the macro is embeded in the webpage
      var macroElement = document.getElementById(filename);

      if ((macroElement) && (macroElement.type == "descartes/library")) {
        response = macroElement.text;
      }
      // the macro is in an external file
      else {
        response = descartesJS.openExternalFile(filename);
      }
    }

    if (response) {
      response = ( response.replace(/&aacute;/g, "\u00e1").replace(/&eacute;/g, "\u00e9").replace(/&iacute;/g, "\u00ed").replace(/&oacute;/g, "\u00f3").replace(/&uacute;/g, "\u00fa").replace(/&Aacute;/g, "\u00c1").replace(/&Eacute;/g, "\u00c9").replace(/&Iacute;/g, "\u00cd").replace(/&Oacute;/g, "\u00d3").replace(/&Uacute;/g, "\u00da").replace(/&ntilde;/g, "\u00f1").replace(/&Ntilde;/g, "\u00d1").replace(/\&gt;/g, ">").replace(/\&lt;/g, "<").replace(/\&amp;/g, "&").replace(/\r/g, "") ).split("\n");

      // create the elements
      for (var i=0,l=response.length; i<l; i++){
        if (response[i].trim() !== "") {
          parent.lessonParser.parseAuxiliar(response[i]);
        }
      }
    }
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Auxiliary
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Library, descartesJS.Auxiliary);
    
  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var evaluator;
  var expr;
  var tempParam;
  var theText;
  var verticalDisplace;
  var ctx;

  /**
   * Descartes graphics
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the graphic
   */
  descartesJS.Graphic = function(parent, values) {
    var self = this;
    /**
     * Descartes application
     * type {DescartesApp}
     * @private
     */
    self.parent = parent;

    /**
     * object for parse and evaluate expressions
     * type {Evaluator}
     * @private
     */
    self.evaluator = parent.evaluator;

    var parser = self.evaluator.parser;

    /**
     * identifier of the space that belongs to the graphic
     * type {String}
     * @private
     */
    self.spaceID = "";

    /**
     * the condition for determining whether the graph is drawn in the background
     * type {Boolean}
     * @private
     */
    self.background = false;

    /**
     * type of the graphic
     * type {String}
     * @private
     */
    self.type = "";

    /**
     * the condition to draw the graphic
     * type {Node}
     * @private
     */
    self.drawif = parser.parse("1");

    /**
     * the condition for determine whether the graphic is in absolute coordinates
     * type {Boolean}
     * @private
     */
    self.abs_coord = (values.type && values.type === "text") ? true : false;

    /**
     * the primary color of the graphic
     * type {String}
     * @private
     */
    self.color = new descartesJS.Color("blue");
    if (self.parent.version !== 2) {
      self.color = new descartesJS.Color("20303a");

      // ##ARQUIMEDES## //
      if (self.parent.arquimedes) {
        self.color = new descartesJS.Color("black");
      }
      // ##ARQUIMEDES## //
    }

    /**
     * the color for the trace of the graphic
     * type {String}
     * @private
     */
    self.trace = "";

    /**
     * the expression for determine the position of the graphic
     * type {Node}
     * @private
     */
    self.expresion = parser.parse("(0,0)");

    /**
     * the condition and parameter name for family of the graphic
     * type {String}
     * @private
     */
    self.family = "";

    /**
     * the interval of the family
     * type {Node}
     * @private
     */
    self.family_interval = parser.parse("[0,1]");

    /**
     * the number of steps of the family
     * type {Node}
     * @private
     */
    self.family_steps = parser.parse("8");

    /**
     * type {Boolean}
     * @private
     */
    self.visible = false;

    /**
     * the condition for determining whether the graph is editable
     * type {Boolean}
     * @private
     */
    self.editable = false;

    /**
     * font of the text
     * type {String}
     * @private
     */
    self.font = "SansSerif,PLAIN," + ((self.parent.version >=5) ? "18" : "12");

    /**
     * the condition for determining whether the text of the graph is fixed or not
     * type {Boolean}
     * @private
     */
    self.fixed = true;

    /**
     * text of the graphic
     * type {String}
     * @private
     */
    self.text = "";

    /**
     * the number of decimal of the text
     * type {Node}
     * @private
     */
    self.decimals = parser.parse("2");

    // traverse the values to replace the defaults values of the object
    for (var propName in values) {
      // verify the own properties of the object
      if (values.hasOwnProperty(propName)) {
        self[propName] = values[propName];
      }
    }

    // get the space of the graphic
    self.space = self.getSpace();

    // get the canvas
    self.canvas = (self.background) ? self.space.backCanvas : self.space.canvas;
    self.ctx = self.canvas.getContext("2d");

    // if the object has trace, then get the background canvas render context
    if (self.trace) {
      self.traceCtx = self.space.backCtx;
    }

    // get a Descartes font
    this.font_str = this.font;
    this.font = descartesJS.convertFont(this.font);
    // get the font size
    this.fontSize = this.font.match(/([\d\.]+)px/);
    this.fontSize = (this.fontSize) ? parseFloat(this.fontSize[1]) : 10;

    this.font_style = descartesJS.getFontStyle(this.font_str.split(",")[1]);
    if ((typeof this.bold === "boolean") || (typeof this.italics === "boolean")) {
      if (this.bold && !this.italics) {
        this.font_style = "Bold ";
      }
      else if (!this.bold && this.italics) {
        this.font_style = "Italic ";
      }
      else if (this.bold && this.italics) {
        this.font_style = "Italic Bold ";
      }
      else if (!this.bold && !this.italics) {
        this.font_style = " ";
      }
    }

    if (!this.font_family) {
      this.font_family = this.font_str.split(",")[0];
    }
    this.font_family = descartesJS.getFontName(this.font_family);

    if (typeof this.font_size === "undefined") {
      this.font_size = parent.evaluator.parser.parse(this.fontSize.toString());
    }
  }

  /**
   * Get the space to which the graphic belongs
   * return {Space} return the space to which the graphic belongs
   */
  descartesJS.Graphic.prototype.getSpace = function() {
    var spaces = this.parent.spaces;
    var space_i;

    // find in the spaces
    for (var i=0, l=spaces.length; i<l; i++) {
      space_i = spaces[i];
      if (space_i.id == this.spaceID) {
        return space_i;
      }
    }

    // if do not find the identifier, return the first space
    return spaces[0];
  }

  /**
   * Get the family values of the graphic
   */
  descartesJS.Graphic.prototype.getFamilyValues = function() {
    evaluator = this.evaluator;
    expr = evaluator.eval(this.family_interval);
    this.familyInf = expr[0][0];
    this.familySup = expr[0][1];
    this.fSteps = Math.round(evaluator.eval(this.family_steps));
    this.family_sep = (this.fSteps > 0) ? (this.familySup - this.familyInf)/this.fSteps : 0;
  }

  /**
   * Auxiliar function for draw a family graphic
   * @param {CanvasRenderingContext2D} ctx the render context to draw
   * @param {String} fill the fill color of the graphic
   * @param {String} stroke the stroke color of the graphic
   */
  descartesJS.Graphic.prototype.drawFamilyAux = function(ctx, fill, stroke) {
    evaluator = this.evaluator;

    // update the family values
    this.getFamilyValues();

    // save the las value of the family parameter
    tempParam = evaluator.getVariable(this.family);

    if (this.fSteps >= 0) {
      // draw all the family mebers of the graphic
      for(var i=0, l=this.fSteps; i<=l; i++) {
        // update the value of the family parameter
        evaluator.setVariable(this.family, this.familyInf+(i*this.family_sep));

        // if the condition to draw if true then update and draw the graphic
        if ( evaluator.eval(this.drawif) > 0 ) {
          // update the values of the graphic
          this.update();
          //awful hack to help the pstricks exporter
          ctx.oldTextNode = null;
          // draw the graphic
          this.drawAux(ctx, fill, stroke);
        }
      }
    }

    evaluator.setVariable("_Text_H_", 0);
    evaluator.setVariable(this.family, tempParam);
  }

  /**
   * Draw the graphic
   * @param {String} fill the fill color of the graphic
   * @param {String} stroke the stroke color of the graphic
   */
  descartesJS.Graphic.prototype.draw = function(fill, stroke) {
    // if the graphic has a family
    if (this.family != "") {
      this.drawFamilyAux(this.ctx, fill, stroke);
    }
    // if the graphic has not a family
    else  {
      // if the condition to draw is true
      if ( this.evaluator.eval(this.drawif) > 0 ) {
        // update the values of the graphic
        this.update();
        // draw the graphic
        this.drawAux(this.ctx, fill, stroke);
      }
    }
  }

  /**
   * Draw the trace of the graphic
   * @param {String} fill the fill color of the graphic
   * @param {String} stroke the stroke color of the graphic
   */
  descartesJS.Graphic.prototype.drawTrace = function(fill, stroke) {
    // if the graphic has a family
    if (this.family != "") {
      this.drawFamilyAux(this.traceCtx, fill, stroke);
    }
    // if the graphic has not a family
    else {
      // if the condition to draw is true
      if ( this.evaluator.eval(this.drawif) > 0 ) {
        // update the values of the graphic
        this.update();
        // draw the graphic
        this.drawAux(this.traceCtx, fill, stroke);
      }
    }
  }

  /**
   *
   */
  descartesJS.Graphic.prototype.dashStyle = function() {
    ctx = this.ctx
    if (this.lineDash === "dot") {
      ctx.lineCap = "butt";
      ctx.setLineDash([ctx.lineWidth, ctx.lineWidth])
    }
    else if (this.lineDash === "dash") {
      ctx.lineCap = "butt";
      ctx.setLineDash([ctx.lineWidth*4, ctx.lineWidth*3])
    }
    else if (this.lineDash === "dash_dot") {
      ctx.lineCap = "butt";
      ctx.setLineDash([ctx.lineWidth*4, ctx.lineWidth*2, ctx.lineWidth, ctx.lineWidth*2])
    }
    else {
      ctx.setLineDash([]);
    }
  }

  /**
   * Draw the text of the graphic
   * @param {CanvasRenderingContext2D} ctx the context render to draw
   * @param {String} text the text to draw
   * @param {Number} x the x position of the text
   * @param {Number} y the y position of the text
   * @param {String} fill the fill color of the graphic
   * @param {String} font the font of the text
   * @param {String} align the alignment of the text
   * @param {String} baseline the baseline of the text
   * @param {Number} decimals the number of decimals of the text
   * @param {Boolean} fixed the number of significant digits of the number in the text
   * @param {Boolean} displaceY a flag to indicate if the text needs a displace in the y position
   */
  descartesJS.Graphic.prototype.drawText = function(ctx, text, x, y, fill, font, align, baseline, decimals, fixed, displaceY) {
    ctx.textNode = text;

    // rtf text
    if (text.type === "rtfNode") {
      ctx.fillStyle = fill.getColor();
      ctx.strokeStyle = fill.getColor();
      ctx.textBaseline = "alphabetic";
      ctx.textNode.pos = { x:x, y:y };

      // text.draw(ctx, x, y, decimals, fixed, align, displaceY, fill.getColor());
      text.update(ctx, x, y, decimals, fixed, align, displaceY, fill.getColor());

      return;
    }

    // simple text (none rtf text)
    if (text.type === "simpleText") {
      text = text.toString(decimals, fixed).split("\\n");
    }

    evaluator = this.evaluator;
    ctx.fillStyle = fill.getColor();
    ctx.font = font;
    ctx.textAlign = align;
    ctx.textBaseline = baseline;

    verticalDisplace = this.fontSize*1.2 || 0;

    for (var i=0, l=text.length; i<l; i++) {
      theText = text[i];

      if (this.border) {
        ctx.strokeStyle = this.border.getColor();
        ctx.lineWidth = 4;
        ctx.lineJoin = "round";
        ctx.miterLimit = 2;
        ctx.strokeText(theText, x, y+(verticalDisplace*i));
      }
     
      ctx.fillText(theText, x, y+(verticalDisplace*i));
    }
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * A Descartes plain text (not RTF)
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} text the content text
   */
  descartesJS.SimpleText = function(parent, text) {
    this.text = text = text.replace("&#x2013", "–").replace(/\&squot;/g, "'");

    this.textElements = [];
    this.textElementsMacros = [];
    this.parent = parent;
    this.evaluator = parent.evaluator;
    this.type = "simpleText"

    var txt = "'";
    var pos = 0;
    var lastPos = 0;
    var ignoreSquareBracket = -1;
    var charAt;
    var charAtAnt;

    while (pos < text.length) {
      charAt = text.charAt(pos);
      charAtAnt = text.charAt(pos-1);

      // open square bracket scaped
      if ((charAt === "[") && (charAtAnt === "\\")) {
        this.textElements.push(text.substring(lastPos, pos-1) + "[");
        this.textElementsMacros.push("'" + text.substring(lastPos, pos-1) + "['");
        lastPos = pos+1;
      }

      // close square bracket scaped
      else if ((charAt === "]") && (charAtAnt === "\\")) {
        this.textElements.push(text.substring(lastPos, pos-1) + "]");
        this.textElementsMacros.push("'" + text.substring(lastPos, pos-1) + "]'");
        lastPos = pos+1;
      }

      // if find an open square bracket
      else if ((charAt === "[") && (ignoreSquareBracket === -1)) {
        this.textElements.push(text.substring(lastPos, pos));
        this.textElementsMacros.push("'" + text.substring(lastPos, pos) + "'");
        lastPos = pos;
        ignoreSquareBracket++;
      }

      else if (charAt === "[") {
        ignoreSquareBracket++;
      }

      // if find a close square bracket add the string +'
      else if ((charAt === "]") && (ignoreSquareBracket === 0)) {
        this.textElements.push( this.evaluator.parser.parse(text.substring(lastPos, pos+1)) );
        this.textElementsMacros.push( "[" + text.substring(lastPos, pos+1) + "]");
        lastPos = pos+1;
        ignoreSquareBracket--;
      }

      else if (text.charAt(pos) == "]") {
        ignoreSquareBracket = (ignoreSquareBracket < 0) ? ignoreSquareBracket : ignoreSquareBracket-1;
        txt = txt + text.charAt(pos);
      }

      else {
        txt = txt + text.charAt(pos);
      }

      pos++;
    }
    this.textElements.push(text.substring(lastPos, pos));
    this.textElementsMacros.push("'" + text.substring(lastPos, pos) + "'");
  }

  var txt;
  var evalString;

  /**
   * Get the string representation of the text, replacing the number taking into acount the number of decimals and the fixed value
   * @param {Number} decimal the number of decimal of the number in the text
   * @param {Boolean} fixed a condition to indicate if the number has a fixed representation
   * @return {String} return the string representation of te text
   */
  descartesJS.SimpleText.prototype.toString = function(decimals, fixed) {
    txt = "";

    for(var i=0, l=this.textElements.length; i<l; i++) {
      if (typeof(this.textElements[i]) === "string") {
        txt += this.textElements[i];
      }
      else {
        evalString = this.evaluator.eval(this.textElements[i])[0][0];

        if (evalString !== "") {
          // the evaluation is a string
          if (typeof(evalString) === "string") {
            txt += evalString;
          }
          else if (evalString == Infinity) {
            txt += "Infinity";
          }
          else if (evalString == -Infinity) {
            txt += "-Infinity";
          }
          else if (isNaN(evalString) || (evalString == "NaN")) {
            txt += "NaN";
          }
          // the evaluation is a number
          else {
            evalString = parseFloat(evalString);
            
            evalString = (fixed) ? evalString.toFixed(decimals) : descartesJS.removeNeedlessDecimals(evalString.toFixed(decimals));
            txt += evalString.toString().replace(".", this.parent.decimal_symbol);
          }
        }
      }
    }

    return txt;
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathFloor = Math.floor;

  var b;

  var evaluator;
  var parser;
  var space;
  var color;
  var width;
  var savex;
  var savey;
  var w;
  var h;
  var dx;
  var dy;
  var q0;
  var qb;
  var t;
  var Q;
  var q;
  var q_ij;
  var Qx;
  var Qy;
  var t0;
  var zeroVisited;
  var side;
  var changeSide;
  var Px;
  var Py;
  var i;
  var j;

  var theZeroX;
  var theZeroY;
  var initX;
  var initY;
  var tmpX;
  var tmpY;
  var actualTmpAbsoluteX;
  var actualTmpAbsoluteY;
  var previousTmpAbsoluteX;
  var previousTmpAbsoluteY;
  var min;
  var max;
  var minmax;
  var va;
  var colorFillM;
  var colorFillP;
  var disc;
  var saveX;
  var Xr;
  var auxv;

descartesJS._debug_vez = 0;

  /**
   * A Descartes equation
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the equation
   */
  descartesJS.Equation = function(parent, values) {
    /**
     * the stroke width of the graph
     * type {Number}
     * @private
     */
    this.width = parent.evaluator.parser.parse("1");

    /**
     * the condition and the color of the fill+
     * type {String}
     * @private
     */
    this.fillP = "";//new descartesJS.Color("00ff80");

    /**
     * the condition and the color of the fill-
     * type {String}
     * @private
     */
    this.fillM = "";//new descartesJS.Color("ffc800");

    // call the parent constructor
    descartesJS.Graphic.call(this, parent, values);

    // parse the expression and build a newton evaluator
    this.parseExpression();

    // Descartes 2 visible
    this.visible = ((this.parent.version === 2) && (this.visible == undefined)) ? true : this.visible;
    if (this.visible) {
      this.registerTextField();
    }

    q0 = new descartesJS.R2();
    qb = new descartesJS.R2();
    t = new descartesJS.R2();
    q_ij = new descartesJS.R2();
    Q = new descartesJS.R2();

    this.cInd = 0;
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Equation, descartesJS.Graphic);

  /**
   * Parse the expression and build a newton evaluator
   */
  descartesJS.Equation.prototype.parseExpression = function() {
    if (this.expresion.type === "compOperator") {
      var left = this.expresion.childs[0];
      var right = this.expresion.childs[1];

      if ( (left.type == "identifier") && (left.value == "y") && (!right.contains("y")) ) {
        this.funExpr = right;
        this.of_y = false;
        this.drawAux = this.drawAuxFun;
      }
      else if ( (right.type == "identifier") && (right.value == "y") && (!left.contains("y")) ) {
        this.funExpr = left;
        this.of_y = false;
        this.drawAux = this.drawAuxFun;
      }
      else if ( (left.type == "identifier") && (left.value == "x") && (!right.contains("x")) ) {
        this.funExpr = right;
        this.of_y = true;
        this.drawAux = this.drawAuxFun;
      }
      else if ( (right.type == "identifier") && (right.value == "x") && (!left.contains("x")) ) {
        this.funExpr = right;
        this.of_y = true;
        this.drawAux = this.drawAuxFun;
      }
    }

    this.newt = new descartesJS.R2Newton(this.evaluator, this.expresion);
  }

  /**
   * Update the equation
   */
  descartesJS.Equation.prototype.update = function() { }

  /**
   * Draw the equation (special case of the draw defined in Graphic)
   */
  descartesJS.Equation.prototype.draw = function() {
    // if the equation has a family
    if (this.family != "") {
      this.drawFamilyAux(this.ctx, this.fill, this.color);
    }
    // if the equation has not a family
    else  {
      // update the values of the equation
      this.update();
      // draw the equation
      this.drawAux(this.ctx, this.fill, this.color);
    }
  }

  /**
   * Auxiliar function for draw a family graphic
   * @param {CanvasRenderingContext2D} ctx the render context to draw
   * @param {String} fill the fill color of the graphic
   * @param {String} stroke the stroke color of the graphic
   */
  descartesJS.Equation.prototype.drawFamilyAux = function(ctx, fill, stroke) {
    evaluator = this.evaluator;

    // update the family values
    this.getFamilyValues();

    // save the las value of the family parameter
    tempParam = evaluator.getVariable(this.family);

    if (this.fSteps >= 0) {
      // draw all the family mebers of the graphic
      for(var i=0, l=this.fSteps; i<=l; i++) {
        // update the value of the family parameter
        evaluator.setVariable(this.family, this.familyInf+(i*this.family_sep));

        // // if the condition to draw if true then update and draw the graphic
        // update the values of the graphic
        this.update();
        // draw the graphic
        this.drawAux(ctx, fill, stroke);
      }
    }

    evaluator.setVariable(this.family, tempParam);
  }

  /**
   * Draw the trace of the equation
   */
  descartesJS.Equation.prototype.drawTrace = function() {
    // call the drawTrace function of the father (uber instead of super as it is reserved word)
    this.uber.drawTrace.call(this, this.fill, this.trace);
  }

  var Qxa;
  var Qya;
  var secondVisit;
  var Qsx;
  var Qsy;
  var np;
  var dist;
  var ds;

  /**
   * Auxiliary function for draw an non explicit equation
   * @param {CanvasRenderingContext2D} ctx rendering context on which the equation is drawn
   * @param {String} fill the fill color of the equation
   * @param {String} stroke the stroke color of the equation
   */
  descartesJS.Equation.prototype.drawAux = function(ctx, fill, stroke) {
    //
    if ( this.evaluator.eval(this.drawif) <= 0 ) {
      return;
    }
    //
    this.cInd = 0;

    evaluator = this.evaluator;
    parser = evaluator.parser;
    space = this.space;
    width = evaluator.eval(this.width);

    // ctx.fillStyle = stroke.getColor();
    ctx.strokeStyle = this.color.getColor();
    ctx.lineWidth = width;

    savex = parser.getVariable("x");
    savey = parser.getVariable("y");

    // w = space.w;
    // h = space.h;
    w = space.w +24;
    h = space.h +24;

    dx = w/9;
    if (dx < 3) {
      dx = 3;
    }
    dy = h/7;
    if (dy < 3) {
      dy = 3;
    }

    if (this.cInd == 0) {
      b = [];
      this.cInd++;
    }
    else {
      this.cInd = (this.cInd+1)%10000000;
    }

    q0.set(0, 0);
    qb.set(0, 0);
    t.set(0, 0);

    np = 8;
    dist = 0.25;
    ds = np;
    if (!this.abs_coord) {
      dist = dist/space.scale;
      ds = ds/space.scale;
    }

    // init the canvas path
    ctx.beginPath();

    for (j=parseInt(dy/2); j<h; j+=dy) {
      for (i=parseInt(dx/2); i<w; i+=dx) {
        if (this.abs_coord) {
          q_ij.set(i, j);
          q = this.newt.findZero(q_ij, dist);
          if (q == null) {
            continue;
          }
          evaluator.setVariable("x", q.x);
          evaluator.setVariable("y", q.y);
          Q.set(q.x, q.y);
        }
        else {
          q_ij.set(space.getRelativeX(i), space.getRelativeY(j));
          q = this.newt.findZero(q_ij, dist);
          if (q == null) {
            continue;
          }
          evaluator.setVariable("x", q.x);
          evaluator.setVariable("y", q.y);
          Q.set(space.getAbsoluteX(q.x), space.getAbsoluteY(q.y));
        }

        Qx = Q.ix();
        Qy = Q.iy();

        // if ((Qx>=0) && (Qx<w) && (Qy>=0) && (Qy<h)) {
        if ((Qx>=-12) && (Qx<w+24) && (Qy>=-12) && (Qy<h+24)) {
          // if (b[Qx + Qy*space.w]) {
          if (b[Qx+12 + (Qy+12)*space.w] === this.cInd) {
            continue; // zero already detected
          }
          // b[Qx + Qy*space.w] = true;
          b[Qx+12 + (Qy+12)*space.w] = this.cInd;
        }

        if (descartesJS.rangeOK) {
          ctx.moveTo(Qx, Qy);
          ctx.lineTo(Qx, Qy);
        }

        q0.x = q.x;
        q0.y = q.y;
        qb.x = q.x;
        qb.y = q.y;

        // t=t0= Unit Tangent Vector
        t0 = this.newt.getUnitNormal();
        if (t0.x==0 && t0.y==0) {
          continue; /* Zero normal vector */
        }

        t0.rotL90();
        t.x = t0.x;
        t.y = t0.y;

        zeroVisited = 0;
        side = 0;
        changeSide = false;

        while (side < 2)  {
          if (changeSide) {
            // Invert Unit Tangent Vector
            t.x = -t0.x;
            t.y = -t0.y;

            q.x = q0.x;
            q.y = q0.y;

            qb.x = q.x;
            qb.y = q.y;

            if (this.abs_coord) {
              Q.set(q.x, q.y);
            }
            else {
              Q.set(space.getAbsoluteX(q.x), space.getAbsoluteY(q.y));
            }

            Qx = Q.ix();
            Qy = Q.iy();
            changeSide = false;
            zeroVisited = 0;
          }

          q.x+=ds*t.x;
          q.y+=ds*t.y;

          q = this.newt.findZero(q, dist);
          if (q == null) {
            continue;
          }

          evaluator.setVariable("x", q.x);
          evaluator.setVariable("y", q.y);

          t.x = q.x-qb.x;
          t.y = q.y-qb.y;
          t.normalize(); // update Unit Tangent Vector

          if ((t.x==0) && (t.y==0)) {
            break; /* Zero tangent vector */
          }

          qb.x = q.x;
          qb.y = q.y;

          if (this.abs_coord) {
            Q.set(q.x, q.y);
          } else {
            Q.set(space.getAbsoluteX(q.x), space.getAbsoluteY(q.y));
          }

          Px = parseInt(Q.ix());
          Py = parseInt(Q.iy());

          if ((Px!=Qx) || (Py!=Qy)) {
            Qxa = Qx;
            Qya = Qy;
            Qx = Px;
            Qy = Py;

            // if ((Qx>=0) && (Qx<w) && (Qy>=0) && (Qy<h)) {
            if ((Qx>=-12) && (Qx<w+24) && (Qy>=-12) && (Qy<h+24)) {
              zeroVisited = 0;

              // secondVisit = b[Qx + Qy*space.w];
              secondVisit = b[Qx+12 + (Qy+12)*space.w];

              // b[Qx + Qy*space.w] = true;
              b[Qx+12 + (Qy+12)*space.w] = this.cInd;
              for (var s=1; s<np; s++) {
                Qsx = Qxa + Math.round((Qx-Qxa)*s/np);
                Qsy = Qya + Math.round((Qy-Qya)*s/np);
                if ((0<=Qsx) && (Qsx<w) && (0<=Qsy) && (Qsy<h)) {
                  // b[Qsx + Qsy*space.w] = true;
                  b[Qsx+12 + (Qsy+12)*space.w] = this.cInd;
                }
              }

              if (descartesJS.rangeOK) {
                ctx.moveTo(Qxa, Qya);
                ctx.lineTo(Qx, Qy);
              }

              if (secondVisit === this.cInd) {
                break;
              }
            }
            else {
              changeSide = true;
              side++; /* Zero out of bounds */
            }
          }
          else if ( ++zeroVisited > 4 ) {
            changeSide = true;
            side++; /* Stationary Zero */
          }
        }
      }
    }

    ctx.stroke();
  }

  /**
   *
   */
  descartesJS.Equation.prototype.X = function(size, x, abs_coord) {
    if (!abs_coord) {
      x = (this.space.w/2+this.space.Ox) + this.space.scale*x;
    }
    if (x < -size) {
      x = -size;
    }
    if (x > this.space.w+size) {
      x = this.space.w+size;
    }

    return x;
  }

  /**
   *
   */
  descartesJS.Equation.prototype.Y = function(size, y, abs_coord) {
    if (!abs_coord) {
      y = (this.space.h/2+this.space.Oy) - this.space.scale*y;
    }
    if (y < -size) {
      y = -size;
    }
    if (y > this.space.h+size) {
      y = this.space.h+size;
    }

    return y;
  }

  /**
   *
   */
  descartesJS.Equation.prototype.XX = function(size, v, abs_coord) {
    return Math.round(this.X(size, v, abs_coord));
  }

  /**
   *
   */
  descartesJS.Equation.prototype.YY = function(size, v, abs_coord) {
    return Math.round(this.Y(size, v, abs_coord));
  }

  /**
   *
   */
  descartesJS.Equation.prototype.extrapolate = function(cond, X, Y, F, v, dx) {
    var saveX = this.evaluator.getVariable(X);
    var dxx = dx/2;
    var Dx = 0;
    var vv = v;
    var xa;
    var x;
    var ok;
    var vva;
    var minmax;
    var sing;

    while (Math.abs(dxx)>1E-15) {
      xa = this.evaluator.getVariable(X);
      x  = this.evaluator.getVariable(X) + dxx;

      this.evaluator.setVariable(X, x);

      ok = true;

      try {
        vva = vv;
        vv = this.evaluator.eval(this.funExpr);
        this.evaluator.setVariable(Y, vv);

        if (this.evaluator.eval(cond) > 0) {
          minmax = new descartesJS.R2(Math.min(vva, vv), Math.max(vva, vv));
          sing = 0;

          if (dx>0) {
            sing = this.Singularity(Math.abs(dxx), X, F, xa, vva, x, vv, minmax);
          }
          else {
            sing = this.Singularity(Math.abs(dxx), X, F, x, vv, xa, vva, minmax);
          }
          if (sing > 0) {
            ok = false;
          }
        }
        else {
          ok = false;
        }
      }
      catch (e) {
        ok = false;
      }

      if (ok) {
        Dx += dxx;
      }
      else {
        this.evaluator.setVariable(X, xa);
      }
      dxx/=2;
    }

    this.evaluator.setVariable(X, saveX);

    return new descartesJS.R2(Dx/Math.abs(dx), vv);
  }


  /**
   *
   */
  descartesJS.Equation.prototype.extrapolateOnSingularity = function(cond, X, Y, F, v, dx) {
    var saveX = this.evaluator.getVariable(X);
    var dxx = dx/2;
    var Dx = 0;
    var vv = v;
    var ok;
    var vva;

    while (Math.abs(dxx)>1E-15) {
      this.evaluator.setVariable(X, this.evaluator.getVariable(X) +dxx);
      ok = true;

      if (this.evaluator.eval(cond) > 0) {
        try {
          vva = vv;
          vv = this.evaluator.eval(this.funExpr);

          this.evaluator.setVariable(Y, vv);

          if (this.evaluator.eval(cond) <= 0) {
            ok = false;
          }
        }
        catch (e) {
          ok = false;
        }
      }
      else {
        ok = false;
      }

      if (ok) {
        Dx += dxx;
      }
      else {
        this.evaluator.setVariable(X, this.evaluator.getVariable(X)-dxx);
      }
      dxx/=2;
    }

    if (Dx == 0) {
      dxx = dx/2;
      Dx = dx;
      vv = v;

      while (Math.abs(dxx)>1E-15) {
        this.evaluator.setVariable(X, this.evaluator.getVariable(X)-dxx);

        var ok = true;

        if (this.evaluator.eval(cond) > 0) {
          try {
            vv = this.evaluator.eval(this.funExpr);
          }
          catch (e) {
            ok = false;
          }
        }
        else {
          ok = false;
        }

        if (ok) {
          Dx += -dxx;
        }
        else {
          this.evaluator.setVariable(X, this.evaluator.getVariable(X)+dxx);
        }
        dxx/=2;
      }
    }

    this.evaluator.setVariable(X, saveX);

    return new descartesJS.R2(Dx/Math.abs(dx), vv);
  }

  /**
   *
   */
  descartesJS.Equation.prototype.Singularity = function(e, X, F, a, va, b, vb, minmax) {
    if (isNaN(vb) || isNaN(va) || isNaN(minmax.y) || isNaN(minmax.x)) {
      return 2;
    }
    if (a >= b) {
      return 2;
    }
    var saveX = this.evaluator.getVariable(X);
    var disc = 0;

    try {
      if ( (Math.abs(b-a) < 1E-15) ||
           ( (Math.abs(b-a) < 1E-12) && (Math.abs(vb-va) > Math.abs(e)) )
         ) {
        this.evaluator.setVariable(X, saveX);
        return 1;
      }

      var ab2 = (a+b)/2;
      this.evaluator.setVariable(X, ab2);

      var auxv = NaN;

      try {
        auxv = this.evaluator.eval(this.funExpr);
      }
      catch (e) {
        return 2;
      }

      if (isNaN(auxv)) {
        return 5;
      }

      if (Math.abs(vb-va)>e) {  // detectar saltos
        var epsilon = 1E-12;
        this.evaluator.setVariable(X, a-epsilon);
        var _v = this.evaluator.eval(this.funExpr);
        var _D = (va-_v)/epsilon;

        this.evaluator.setVariable(X, b+epsilon);
        var v_ = this.evaluator.eval(this.funExpr);
        var D_ = (v_-vb)/epsilon;
        var Dj = (vb-va)/(b-a);

        if ( (Math.abs(D_) < 10) || (Math.abs(_D) < 10) ) {
          if ( (D_ >= 0 && _D >= 0) || (D_ <= 0 && _D <= 0) ) {
            if (4*Math.abs(D_) < Math.abs(Dj)) {
              this.evaluator.setVariable(X, saveX);
              return 2;
            }
          }
        }
      }

      if (isNaN(minmax.x) || isNaN(minmax.y) || (isNaN(auxv))){
        return 2;
      }
      else if (!((minmax.x <= auxv) && (auxv <= minmax.y))) {
        this.evaluator.setVariable(X, ab2);
        minmax.x = Math.min(va, auxv);
        minmax.y = Math.max(va, auxv);
        var s1 = this.Singularity(e/2, X, F, a, va, ab2, auxv, minmax);

          this.evaluator.setVariable(X, b);
          minmax.x = Math.min(vb, auxv);
          minmax.y = Math.max(vb, auxv);
          var s2 = this.Singularity(e/2, X, F, ab2, auxv, b, vb, minmax);

          disc = Math.max(s1, s2);
        }
      }
    catch (exc) {
      disc = 1;
    }

    this.evaluator.setVariable(X, saveX)

    return disc;
  }

  /**
   * Auxiliary function for draw an equation of y
   * @param {CanvasRenderingContext2D} ctx rendering context on which the equation is drawn
   * @param {String} fill the fill color of the equation
   * @param {String} stroke the stroke color of the equation
   */
  descartesJS.Equation.prototype.drawAuxFun = function(ctx, fill, stroke) {
    savex = this.evaluator.parser.getVariable("x");
    savey = this.evaluator.parser.getVariable("y");
    descartesJS.rangeOK = 1;

    var X = "x";
    var Y = "y";

    if (this.of_y) {
      X = "y";
      Y = "x";
    }

    var F = 0;
    var cond = (this.drawif);
    var width = this.evaluator.eval(this.width);

    var defa = false;
    var singa = 0;
    var Or = new descartesJS.R2((this.space.w/2+this.space.Ox), (this.space.h/2+this.space.Oy));
    var y0 = (this.of_y) ? Or.ix() : Or.iy();

    var y = 0;
    var ya = 0;
    var x = 0;
    var xa = 0;

    var dx = 1/this.space.scale;
    var Xr = dx*((this.of_y) ? (-this.space.h+Or.y) : -Or.x);
    var va = 0;

    if (this.abs_coord) {
      Xr = 0;
      dx = 1;
    }

    var def;
    var sing;
    var v;
    var min;
    var max;
    var minmax;
    var nya;
    var pn;
    var pa;

    var condWhile = (this.of_y) ? this.space.h+2 : this.space.w+2;
    while (x <= condWhile) {
      def = true;
      sing = 0;
      this.evaluator.setVariable(X, Xr);

      try {
        v = this.evaluator.eval(this.funExpr);

        // if (!isNaN(v) && (Math.abs(v) > 1e-6)) {
        if (!isNaN(v)) {
          this.evaluator.setVariable(Y, v);

          if ((this.evaluator.eval(this.drawif) > 0) && (descartesJS.rangeOK)) {
            if (defa) {
              min = Math.min(va, v);
              max = Math.max(va, v);
              minmax = new descartesJS.R2(min, max);

              sing = this.Singularity(dx, X, F, Xr-dx, va, Xr, v, minmax);

              if (sing === 0) {
                if (va <= v) {
                  va = minmax.x;
                  v =  minmax.y;
                }
                else {
                  v = minmax.x;
                  va = minmax.y;
                }

                nya = parseInt( (this.of_y) ? this.XX(width, va, this.abs_coord) : this.YY(width, va, this.abs_coord) );
                if (this.abs_coord) {
                  y = Math.round(v);
                }
                else {
                  y = parseInt( (this.of_y) ? this.XX(width, v, this.abs_coord) : this.YY(width, v, this.abs_coord) );
                }

                // fill the equation (fill minus)
                if ((this.fillM) && (y>y0)) {
                  ctx.lineWidth = 1;
                  ctx.strokeStyle = this.fillM.getColor();
                  ctx.beginPath();
                  // Line(g[i],width,x,y0+1,x,y,of_y);
                  if (this.of_y) {
                    ctx.moveTo(y0+1, this.space.h-x+.5);
                    ctx.lineTo(y, this.space.h-x+.5);
                  }
                  else {
                    ctx.moveTo(x+.5, y0+1);
                    ctx.lineTo(x+.5, y);
                  }

                  ctx.stroke();
                }
                // fill maximus
                if ((this.fillP) && (y<y0)) {
                  ctx.lineWidth = 1;
                  ctx.strokeStyle = this.fillP.getColor();
                  // Line(g[i],width,x,y0-1,x,y,of_y);
                  ctx.beginPath();
                  if (this.of_y) {
                    ctx.moveTo(y0-1, this.space.h-x+.5);
                    ctx.lineTo(y, this.space.h-x+.5);
                  }
                  else {
                    ctx.moveTo(x+.5, y0-1);
                    ctx.lineTo(x+.5, y);
                  }
                  ctx.stroke();
                }

                ctx.lineWidth = width;
                ctx.strokeStyle = stroke.getColor();

                ctx.beginPath();
                // Line(g[i],width,xa,nya,x,y,of_y);
                if (this.of_y) {
                  ctx.moveTo(nya+.5, this.space.h-xa);
                  ctx.lineTo(y+.5, this.space.h-x);
                }
                else {
                  ctx.moveTo(xa+.5, nya);
                  ctx.lineTo(x+.5, y);
                }
                ctx.stroke();
              }
              // sing === 1
              else if (sing === 1) {
                this.evaluator.setVariable(X, Xr-dx);
                pn = this.extrapolate(cond, X, Y, F, va, dx);
                y = ( (this.of_y) ? this.XX(width, pn.y, this.abs_coord) : this.YY(width, pn.y, this.abs_coord) );
                //
                ctx.lineWidth = width;
                ctx.strokeStyle = stroke.getColor();
                
                ctx.beginPath();
                // Line(g[i],width,xa,ya, xa+(int)Math.round(pn.x),y,of_y);
                if (this.of_y) {
                  ctx.moveTo(ya+.5, this.space.h-xa);
                  ctx.lineTo(y+.5, this.space.h-xa+Math.round(pn.x));
                }
                else {
                  ctx.moveTo(xa+.5, ya);
                  ctx.lineTo(xa+Math.round(pn.x)+.5, y);
                }

                this.evaluator.setVariable(X, Xr);
                pa = this.extrapolate(cond, X, Y, F, v, -dx);
                ya = ( (this.of_y) ? this.XX(width, pa.y, this.abs_coord) : this.YY(width, pa.y, this.abs_coord) );
                y = ( (this.of_y) ? this.XX(width, v, this.abs_coord) : this.YY(width, v, this.abs_coord) );

                //
                ctx.lineWidth = width;
                ctx.strokeStyle = stroke.getColor();
                
                ctx.beginPath();
                // Line(g[i],width,x+(int)Math.round(pa.x),ya, x,y,of_y);
                if (this.of_y) {
                  ctx.moveTo(ya+.5, this.space.h-x);
                  ctx.lineTo(y+.5, this.space.h-x);
                }
                else {
                  ctx.moveTo(x+.5, ya);
                  ctx.lineTo(x+.5, y);
                }
                ctx.stroke();
              }
              // sing === 2
              else if (sing === 2) {
                y = ( (this.of_y) ? this.XX(width, v, this.abs_coord) : this.YY(width, v, this.abs_coord) );

                //
                ctx.lineWidth = width;
                ctx.strokeStyle = stroke.getColor();
                
                ctx.beginPath();
                // Line(g[i],width,x,y,x,y,of_y);
                if (this.of_y) {
                  ctx.moveTo(ya+.5, this.space.h-x);
                  ctx.lineTo(y+.5, this.space.h-x);
                }
                else {
                  ctx.moveTo(x+.5, ya);
                  ctx.lineTo(x+.5, y);
                }
                ctx.stroke();
              }
            }
            // defa === false; extrapolate forward
            else {
              pa = this.extrapolateOnSingularity(cond, X, Y, F, v, -dx);

              ya = (this.of_y) ? this.XX(width, pa.y, this.abs_coord) : this.YY(width, pa.y, this.abs_coord);
              y  = ( (this.of_y) ? this.XX(width, v, this.abs_coord) : this.YY(width, v, this.abs_coord) );

              //
              // Line(g[i],width,x+(int)Math.round(pa.x),ya,x,y,of_y);
              ctx.lineWidth = width;
              ctx.strokeStyle = stroke.getColor();
              
              ctx.beginPath();

              if (this.of_y) {
                ctx.moveTo(ya, this.space.h-(x+Math.round(pa.x))+.5);
                ctx.lineTo(y,  this.space.h-x+.5);
              }
              else {
                ctx.moveTo(x+Math.round(pa.x), ya);
                ctx.lineTo(x, y);
              }
              ctx.stroke();
            }

            va = v;
          }

          else {
            def = false;
          }
        }
      }
      catch(e) {
        def = false;
      }

      if (defa && !def) {
        this.evaluator.setVariable(X, Xr-dx);
        this.evaluator.setVariable(Y, va);

        pn = this.extrapolate(cond, X, Y, F, va, dx);
        y = parseInt( (this.of_y) ? this.XX(width, pn.y, this.abs_coord) : this.YY(width, pn.y, this.abs_coord) );

        if ((this.evaluator.eval(this.drawif) > 0) && (descartesJS.rangeOK)) {
          //
          // Line(g[i],width,xa,ya,xa+(int)Math.round(pn.x),y,of_y);
          ctx.lineWidth = width;
          ctx.strokeStyle = stroke.getColor();
          
          ctx.beginPath();
          if (this.of_y) {
            ctx.moveTo(ya, this.space.h-(xa+Math.round(pn.x))+.5);
            ctx.lineTo(y, this.space.h-(xa+Math.round(pn.x))+.5);
          }
          else {
            ctx.moveTo((xa+Math.round(pn.x))+.5, ya);
            ctx.lineTo((xa+Math.round(pn.x))+.5, y);
          }
          ctx.stroke();
        }

        this.evaluator.setVariable(X, Xr);
      }

      defa = def;
      singa = sing;
      Xr += dx;
      ya = y;
      xa = x++;
    }

    this.evaluator.parser.setVariable("x", savex);
    this.evaluator.parser.setVariable("y", savey);
  }

  /**
   * Register a text field in case the equation expression is editable
   */
  descartesJS.Equation.prototype.registerTextField = function() {
    var textField = document.createElement("input");
    textField.value = this.expresionString;
    textField.disabled = !(this.editable);

    var self = this;
    oncontextmenu = function (evt) { return false; };
    textField.onkeydown = function(evt) {
      if (evt.keyCode == 13) {
        self.expresion = self.evaluator.parser.parse(this.value);
        self.parseExpression();
        self.parent.update();
      }
    }

    this.parent.editableRegion.textFields.push(textField);
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var mathRound = Math.round;

  var evaluator;
  var para;
  var space;
  var tmpLineWidth;
  var tempParam;
  var expr;
  var radianAngle;
  var cosTheta;
  var senTheta;
  var tmpRotX;
  var tmpRotY;

  var lineDesp = .5;
  var POS_LIMIT = 1000000;

  /**
   * A Descartes curve
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the curve
   */
  descartesJS.Curve = function(parent, values) {
    /**
     * parameter for drawing a curve
     * type {String}
     * @private
     */
    this.parameter = "t";

    /**
     * the interval of the curve
     * type {Node}
     * @private
     */
    this.parameter_interval = parent.evaluator.parser.parse("[0,1]");

    /**
     * the number of steps of the curve
     * type {Node}
     * @private
     */
    this.parameter_steps = parent.evaluator.parser.parse("8");

    /**
     * the stroke width of the graph
     * type {Number}
     * @private
     */
    this.width = parent.evaluator.parser.parse("1");

    /**
     * the condition and the color of the fill
     * type {String}
     * @private
     */
    this.fill = "";

    // call the parent constructor
    descartesJS.Graphic.call(this, parent, values);

    // Descartes 2 visible
    this.visible = ((this.parent.version === 2) && (this.visible == undefined)) ? true : this.visible;
    if (this.visible) {
      this.registerTextField();
    }
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Curve, descartesJS.Graphic);

  /**
   * Update the curve
   */
  descartesJS.Curve.prototype.update = function() {
    evaluator = this.evaluator;

    para = evaluator.eval(this.parameter_interval);

    this.paraInf = para[0][0]; // the first value of the first expression
    this.paraSup = para[0][1]; // the second value of the first expression

    this.pSteps = evaluator.eval(this.parameter_steps);
    this.paraSep = (this.pSteps > 0) ? Math.abs(this.paraSup - this.paraInf)/this.pSteps : 0;
  }

  /**
   * Draw the curve
   */
  descartesJS.Curve.prototype.draw = function(){
    // call the draw function of the father (uber instead of super as it is reserved word)
    this.uber.draw.call(this, this.fill, this.color);
  }

  /**
   * Draw the trace of the curve
   */
  descartesJS.Curve.prototype.drawTrace = function() {
    // call the drawTrace function of the father (uber instead of super as it is reserved word)
    this.uber.drawTrace.call(this, this.fill, this.trace);
  }

  /**
   * Auxiliary function for draw a curve
   * @param {CanvasRenderingContext2D} ctx rendering context on which the curve is drawn
   * @param {String} fill the fill color of the curve
   * @param {String} stroke the stroke color of the curve
   */
  descartesJS.Curve.prototype.drawAux = function(ctx, fill, stroke){
    evaluator = this.evaluator;
    space = this.space;

    // the width of a line can not be 0 or negative
    tmpLineWidth = mathRound( evaluator.eval(this.width) );
    ctx.lineWidth = (tmpLineWidth > 0) ? tmpLineWidth : 0.000001;

    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = stroke.getColor();

    tempParam = evaluator.getVariable(this.parameter);

    ctx.beginPath();

    evaluator.setVariable(this.parameter, this.paraInf);

    expr = evaluator.eval(this.expresion);
    this.exprX = mathRound( (this.abs_coord) ? expr[0][0] : space.getAbsoluteX(expr[0][0]) );
    this.exprY = mathRound( (this.abs_coord) ? expr[0][1] : space.getAbsoluteY(expr[0][1]) );

    // MACRO //
    // rotate the elements in case the graphic is part of a macro
    if (this.rotateExp) {
      radianAngle = descartesJS.degToRad(evaluator.eval(this.rotateExp));
      cosTheta = Math.cos(radianAngle);
      senTheta = Math.sin(radianAngle);

      tmpRotX = expr[0][0]*cosTheta - expr[0][1]*senTheta;
      tmpRotY = expr[0][0]*senTheta + expr[0][1]*cosTheta;
      this.exprX = mathRound( (this.abs_coord) ? tmpRotX : space.getAbsoluteX(tmpRotX) );
      this.exprY = mathRound( (this.abs_coord) ? tmpRotY : space.getAbsoluteY(tmpRotY) );
    }
    // MACRO //

    ctx.moveTo(this.exprX+lineDesp, this.exprY+lineDesp);
    for(var i=1; i<=this.pSteps; i++) {
      evaluator.setVariable( this.parameter, (this.paraInf+(i*this.paraSep)) );

      expr = evaluator.eval(this.expresion);
      this.exprX = mathRound( (this.abs_coord) ? expr[0][0] : space.getAbsoluteX(expr[0][0]) );
      this.exprY = mathRound( (this.abs_coord) ? expr[0][1] : space.getAbsoluteY(expr[0][1]) );
  
      // MACRO //
      // rotate the elements in case the graphic is part of a macro
      if (this.rotateExp) {
        tmpRotX = expr[0][0]*cosTheta - expr[0][1]*senTheta;
        tmpRotY = expr[0][0]*senTheta + expr[0][1]*cosTheta;
        this.exprX = mathRound( (this.abs_coord) ? tmpRotX : space.getAbsoluteX(tmpRotX) );
        this.exprY = mathRound( (this.abs_coord) ? tmpRotY : space.getAbsoluteY(tmpRotY) );  
      }
      // MACRO //

      if ( !isNaN(this.exprX) && !isNaN(this.exprY) && (this.exprX > -POS_LIMIT) && (this.exprX < POS_LIMIT) && (this.exprY > -POS_LIMIT) && (this.exprY < POS_LIMIT) ) {
        ctx.lineTo(this.exprX+lineDesp, this.exprY+lineDesp);
      }
    }

    if (this.fill) {
      ctx.fillStyle = fill.getColor();
      ctx.fill("evenodd");
    }

    this.dashStyle();
    ctx.stroke();

    // restor the dash style
    ctx.setLineDash([]);

    evaluator.setVariable(this.parameter, tempParam);
  }

  /**
   * Register a text field in case the curve expression is editable
   */
  descartesJS.Curve.prototype.registerTextField = function() {
    var textField = document.createElement("input");
    textField.value = this.expresionString;
    textField.disabled = !(this.editable);

    var self = this;
    textField.oncontextmenu = function (evt) { return false; };
    textField.onkeydown = function(evt) {
      if (evt.keyCode == 13) {
      self.expresion = self.evaluator.parser.parse(this.value);
      self.parent.update();
      }
    }

    this.parent.editableRegion.textFields.push(textField);
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var PI2 = Math.PI*2;
  var mathRound = Math.round;

  var evaluator;
  var space;
  var expr;
  var radianAngle;
  var cosTheta;
  var senTheta;
  var tmpRotX;
  var tmpRotY;
  var coordX;
  var coordY;
  var range;
  var size;
  var desp;
  var tmp;

  /**
   * A Descartes sequence
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the sequence
   */
  descartesJS.Sequence = function(parent, values) {
    /**
     * width of the point
     * type {Node}
     * @private
     */
    this.size = parent.evaluator.parser.parse("2");

    this.range = parent.evaluator.parser.parse("[1, 100]");

    // call the parent constructor
    descartesJS.Graphic.call(this, parent, values);

    // Descartes 2 visible
    this.visible = ((this.parent.version === 2) && (this.visible == undefined)) ? true : this.visible;
    if (this.visible) {
      this.registerTextField();
    }
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Sequence, descartesJS.Graphic);

  /**
   * Update the sequence
   */
  descartesJS.Sequence.prototype.update = function() {
    evaluator = this.evaluator;

    expr = evaluator.eval(this.expresion);
    this.exprX = expr[0][0]; // the first value of the first expression
    this.exprY = expr[0][1]; // the second value of the first expression

    // rotate the elements in case the graphic is part of a macro
    if (this.rotateExp) {
      radianAngle = descartesJS.degToRad(evaluator.eval(this.rotateExp));
      cosTheta = Math.cos(radianAngle);
      senTheta = Math.sin(radianAngle);

      tmpRotX = this.exprX*cosTheta - this.exprY*senTheta;
      tmpRotY = this.exprX*senTheta + this.exprY*cosTheta;
      this.exprX = tmpRotX;
      this.exprY = tmpRotY;
    }

    range = evaluator.eval(this.range);
    this.rangeInf = range[0][0];
    this.rangeMax = range[0][1];
  }

  /**
   * Draw the sequence
   */
  descartesJS.Sequence.prototype.draw = function() {
    // call the draw function of the father (uber instead of super as it is reserved word)
    this.uber.draw.call(this, this.color, this.color);
  }

  /**
   * Draw the trace of the sequence
   */
  descartesJS.Sequence.prototype.drawTrace = function() {
    // call the drawTrace function of the father (uber instead of super as it is reserved word)
    this.uber.drawTrace.call(this, this.trace, this.trace);
  }

  /**
   * Auxiliary function for draw a sequence
   * @param {CanvasRenderingContext2D} ctx rendering context on which the sequence is drawn
   * @param {String} fill the fill color of the sequence
   */
  descartesJS.Sequence.prototype.drawAux = function(ctx, fill) {
    evaluator = this.evaluator;
    space = this.space;

    size = Math.ceil(evaluator.eval(this.size)-.4);
    desp = size;

    ctx.fillStyle = fill.getColor();

    ctx.beginPath();

    if (this.rangeInf > this.rangeMax) {
      tmp = this.rangeInf;
      this.rangeInf = this.rangeMax;
      this.rangeMax = tmp;
    }

    var tmpValue = evaluator.getVariable("n");
    for (var i=this.rangeInf, l=this.rangeMax; i<=l; i++) {
      evaluator.setVariable("n", i);

      expr = evaluator.eval(this.expresion);
      this.exprX = expr[0][0];
      this.exprY = expr[0][1];

      coordX = mathRound( (this.abs_coord) ? this.exprX : space.getAbsoluteX(this.exprX) );
      coordY = mathRound( (this.abs_coord) ? this.exprY : space.getAbsoluteY(this.exprY) );

      ctx.beginPath();
      ctx.arc(coordX, coordY, size, 0, PI2, true);
      ctx.fill()
    }

    ctx.fill();

    // draw the text of the sequence
    if (this.text != [""]) {
      this.fontSize = Math.max( 5, evaluator.eval(this.font_size) );
      this.font = this.font_style + " " + this.fontSize + "px " + this.font_family;

      this.uber.drawText.call(this, ctx, this.text, coordX+desp, coordY-desp, this.color, this.font, "start", "alphabetic", evaluator.eval(this.decimals), this.fixed, true);
    }

    evaluator.setVariable("n", tmpValue);
  }

  /**
   * Register a text field in case the equation expression is editable
   */
  descartesJS.Sequence.prototype.registerTextField = function() {
    var textField = document.createElement("input");
    textField.value = this.expresionString;
    textField.disabled = !(this.editable);

    var self = this;
    oncontextmenu = function (evt) { return false; };
    textField.onkeydown = function(evt) {
      if (evt.keyCode == 13) {
        self.expresion = self.evaluator.parser.parse(this.value);
        self.parent.update();
      }
    }

    this.parent.editableRegion.textFields.push(textField);
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var PI2 = Math.PI*2;
  var mathRound = Math.round;

  var evaluator;
  var space;
  var expr;
  var radianAngle;
  var cosTheta;
  var senTheta;
  var tmpRotX;
  var tmpRotY;
  var coordX;
  var coordY;
  var size;
  var desp;

  /**
   * A Descartes point
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the point
   */
  descartesJS.Point = function(parent, values) {
    /**
     * width of the point
     * type {Node}
     * @private
     */
    this.size = parent.evaluator.parser.parse("2");

    // call the parent constructor
    descartesJS.Graphic.call(this, parent, values);

    this.text = new descartesJS.TextObject(this, this.text);
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Point, descartesJS.Graphic);

  /**
   * Update the point
   */
  descartesJS.Point.prototype.update = function() {
    evaluator = this.evaluator;

    expr = evaluator.eval(this.expresion);

    this.exprX = expr[0][0]; // the first value of the first expression
    this.exprY = expr[0][1]; // the second value of the first expression

    // rotate the elements in case the graphic is part of a macro
    if (this.rotateExp) {
      radianAngle = descartesJS.degToRad(evaluator.eval(this.rotateExp));
      cosTheta = Math.cos(radianAngle);
      senTheta = Math.sin(radianAngle);

      tmpRotX = this.exprX*cosTheta - this.exprY*senTheta;
      tmpRotY = this.exprX*senTheta + this.exprY*cosTheta;
      this.exprX = tmpRotX;
      this.exprY = tmpRotY;
    }
  }

  /**
   * Draw the point
   */
  descartesJS.Point.prototype.draw = function() {
    // call the draw function of the father (uber instead of super as it is reserved word)
    this.uber.draw.call(this, this.color, this.color);
  }

  /**
   * Draw the trace of the point
   */
  descartesJS.Point.prototype.drawTrace = function() {
    // call the drawTrace function of the father (uber instead of super as it is reserved word)
    this.uber.drawTrace.call(this, this.trace, this.trace);
  }

  /**
   * Auxiliary function for draw a point
   * @param {CanvasRenderingContext2D} ctx rendering context on which the point is drawn
   * @param {String} fill the fill color of the point
   */
  descartesJS.Point.prototype.drawAux = function(ctx, fill){
    evaluator = this.evaluator;
    space = this.space;

    size = mathRound(evaluator.eval(this.size));
    desp = size+1;

    ctx.fillStyle = fill.getColor();

    coordX = mathRound( (this.abs_coord) ? this.exprX : space.getAbsoluteX(this.exprX) );
    coordY = mathRound( (this.abs_coord) ? this.exprY : space.getAbsoluteY(this.exprY) );

    ctx.beginPath();
    ctx.arc(coordX, coordY, size, 0, PI2, true);
    ctx.fill()

    // draw the text of the text
    if (this.text.hasContent) {
      this.text.draw(ctx, fill, coordX, coordY);
    }
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var mathRound = Math.round;
  var PI2 = Math.PI*2;

  var evaluator;
  var space;
  var points;
  var radianAngle;
  var cosTheta;
  var senTheta;
  var tmpRotX;
  var tmpRotY;
  var tmpLineWidth;
  var desp;
  var midpX;
  var midpY;
  var size;
  var lineDesp;
  var coordX;
  var coordY;
  var coordX1;
  var coordY1;

  /**
   * A Descartes segment
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the segment
   */
  descartesJS.Segment = function(parent, values) {
    /**
     * the stroke width of the graph
     * type {Number}
     * @private
     */
    this.width = parent.evaluator.parser.parse("1");

    /**
     * width of the point
     * type {Node}
     * @private
     */
    this.size = parent.evaluator.parser.parse("2");

    // call the parent constructor
    descartesJS.Graphic.call(this, parent, values);

    this.text = new descartesJS.TextObject(this, this.text);
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Segment, descartesJS.Graphic);

  /**
   * Update the segment
   */
  descartesJS.Segment.prototype.update = function() {
    evaluator = this.evaluator;

    points = evaluator.eval(this.expresion);
    this.endPoints = [];

    for(var i=0, l=points.length; i<l; i++){
      this.endPoints[i] = {x: points[i][0], y: points[i][1]};
    }

    // MACRO //
    // rotate the elements in case the graphic is part of a macro
    if (this.rotateExp) {
      radianAngle = descartesJS.degToRad(evaluator.eval(this.rotateExp));
      cosTheta = Math.cos(radianAngle);
      senTheta = Math.sin(radianAngle);

      for (var i=0, l=this.endPoints.length; i<l; i++) {
        tmpRotX = this.endPoints[i].x*cosTheta - this.endPoints[i].y*senTheta;
        tmpRotY = this.endPoints[i].x*senTheta + this.endPoints[i].y*cosTheta;
        this.endPoints[i].x = tmpRotX;
        this.endPoints[i].y = tmpRotY;
      }
    }
    // MACRO //
  }

  /**
   * Draw the segment
   */
  descartesJS.Segment.prototype.draw = function() {
    // call the draw function of the father (uber instead of super as it is reserved word)
    this.uber.draw.call(this, this.color, this.color);
  }

  /**
   * Draw the trace of the segment
   */
  descartesJS.Segment.prototype.drawTrace = function() {
    // call the drawTrace function of the father (uber instead of super as it is reserved word)
    this.uber.drawTrace.call(this, this.trace, this.trace);
  }

  /**
   * Auxiliary function for draw a segment
   * @param {CanvasRenderingContext2D} ctx rendering context on which the segment is drawn
   * @param {String} fill the fill color of the segment
   * @param {String} stroke the stroke color of the segment
   */
  descartesJS.Segment.prototype.drawAux = function(ctx, fill, stroke){
    evaluator = this.evaluator;
    space = this.space;

    // the width of a line can not be 0 or negative
    tmpLineWidth = mathRound( evaluator.eval(this.width) );
    ctx.lineWidth = (tmpLineWidth > 0) ? tmpLineWidth : 0.000001;

    size = evaluator.eval(this.size);
    if (size < 0) {
      size = 0;
    }

    ctx.fillStyle = fill.getColor();
    ctx.strokeStyle = stroke.getColor();
    ctx.lineCap = "round";

    desp = 10+ctx.lineWidth;

    lineDesp = (ctx.lineWidth%2 == 0) ? 0 : 0.5;

    if (this.abs_coord) {
      coordX =  mathRound(this.endPoints[0].x);
      coordY =  mathRound(this.endPoints[0].y);
      coordX1 = mathRound(this.endPoints[1].x);
      coordY1 = mathRound(this.endPoints[1].y);
    } else {
      coordX =  mathRound(space.getAbsoluteX(this.endPoints[0].x));
      coordY =  mathRound(space.getAbsoluteY(this.endPoints[0].y));
      coordX1 = mathRound(space.getAbsoluteX(this.endPoints[1].x));
      coordY1 = mathRound(space.getAbsoluteY(this.endPoints[1].y));
    }

    ctx.beginPath();
    ctx.moveTo(coordX+lineDesp, coordY+lineDesp);
    ctx.lineTo(coordX1+lineDesp, coordY1+lineDesp);

    this.dashStyle();
    ctx.stroke();

    if (size > 0) {
      ctx.beginPath();
      ctx.arc(coordX, coordY, size, 0, PI2, true);
      ctx.arc(coordX1, coordY1, size, 0, PI2, true);
      ctx.fill();
    }

    // restor the dash style
    ctx.setLineDash([]);

    // draw the text of the segment
    if (this.text.hasContent) {
      midpX = parseInt((coordX + coordX1)/2) -3;
      midpY = parseInt((coordY + coordY1)/2) +3;
      this.text.draw(ctx, stroke, midpX, midpY);
    }
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathFloor = Math.floor;
  var mathRound = Math.round;

  var evaluator;
  var points;
  var radianAngle;
  var cosTheta;
  var senTheta;
  var tmpRotX;
  var tmpRotY;
  var space;
  var midpX;
  var midpY;
  var desp;
  var width1;
  var width2;
  var scale;
  var vlength;
  var coordX;
  var coordY;
  var coordX1;
  var coordY1;
  var spear;

  /**
   * A Descartes arrow
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the arrow
  */
  descartesJS.Arrow = function(parent, values) {
    /**
     * the stroke width of the graph
     * type {Number}
     * @private
     */
    this.width = parent.evaluator.parser.parse("5");

    /**
     * width of the point
     * type {Node}
     * @private
     */
    this.size = parent.evaluator.parser.parse("2");

    /**
     * the size of the spear (arrow)
     * type {Node}
     * @private
     */
    this.spear = parent.evaluator.parser.parse("8");

    /**
     * the color of the arrow
     * type {String}
     * @private
     */
    this.arrow = new descartesJS.Color("ee0022");

    // call the parent constructor
    descartesJS.Graphic.call(this, parent, values);

    this.text = new descartesJS.TextObject(this, this.text);
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Arrow, descartesJS.Graphic);

  /**
   * Update the arrow
   */
  descartesJS.Arrow.prototype.update = function() {
    evaluator = this.evaluator;

    points = evaluator.eval(this.expresion);
    this.endPoints = [];

    for(var i=0, l=points.length; i<l; i++){
      this.endPoints[i] = {x: points[i][0], y: points[i][1]};
    }

    // rotate the elements in case the graphic is part of a macro
    if (this.rotateExp) {
      radianAngle = descartesJS.degToRad(evaluator.eval(this.rotateExp));
      cosTheta = Math.cos(radianAngle);
      senTheta = Math.sin(radianAngle);

      for (var i=0, l=this.endPoints.length; i<l; i++) {
        tmpRotX = this.endPoints[i].x*cosTheta - this.endPoints[i].y*senTheta;
        tmpRotY = this.endPoints[i].x*senTheta + this.endPoints[i].y*cosTheta;
        this.endPoints[i].x = tmpRotX;
        this.endPoints[i].y = tmpRotY;
      }
    }

  }

  /**
   * Draw the arrow
   */
  descartesJS.Arrow.prototype.draw = function() {
    // call the draw function of the father (uber instead of super as it is reserved word)
    this.uber.draw.call(this, this.arrow, this.color);
  }

  /**
   * Draw the trace of the arrow
   */
  descartesJS.Arrow.prototype.drawTrace = function() {
    // call the drawTrace function of the father (uber instead of super as it is reserved word)
    this.uber.drawTrace.call(this, this.arrow, this.trace);
  }

  /**
   * Auxiliary function for draw an arrow
   * @param {CanvasRenderingContext2D} ctx rendering context on which the arrow is drawn
   * @param {String} fill the fill color of the arrow
   * @param {String} stroke the stroke color of the arrow
   */
  descartesJS.Arrow.prototype.drawAux = function(ctx, fill, stroke){
    evaluator = this.evaluator;
    space = this.space;

    desp = 10 + evaluator.eval(this.size);
    width1 = evaluator.eval(this.width);
    if (width1 < 0) {
      width1 = 0;
    }

    width2 = Math.ceil(width1/2);
    scale = space.scale;

    this.vect = new descartesJS.Vector2D(this.endPoints[1].x-this.endPoints[0].x, this.endPoints[1].y-this.endPoints[0].y);
    vlength = this.vect.vectorLength();
    this.angle = this.vect.angleBetweenVectors(descartesJS.Vector2D.AXIS_X);

    ctx.fillStyle = fill.getColor();
    ctx.strokeStyle = stroke.getColor();
    ctx.lineWidth = 2.0;

    if (this.abs_coord) {
      coordX =  mathRound(this.endPoints[0].x);
      coordY =  mathRound(this.endPoints[0].y);

      coordX1 = mathRound(this.endPoints[1].x);
      coordY1 = mathRound(this.endPoints[1].y);
    } else {
      coordX =  mathRound(space.getAbsoluteX(this.endPoints[0].x));
      coordY =  mathRound(space.getAbsoluteY(this.endPoints[0].y));

      coordX1 = mathRound(space.getAbsoluteX(this.endPoints[1].x));
      coordY1 = mathRound(space.getAbsoluteY(this.endPoints[1].y));
    }

    var spear = evaluator.eval(this.spear);
    if (spear < 0) {
      spear = 0
    }

    ctx.save();
    ctx.translate(coordX, coordY, vlength);

    if (this.abs_coord) {
      if (((this.vect.x >= 0) && (this.vect.y >= 0)) || ((this.vect.x <= 0) && (this.vect.y >= 0))) {
        ctx.rotate(this.angle)
      } else {
        ctx.rotate(-this.angle)
      }
    } else {
      vlength = vlength*scale;

      if (((this.vect.x >= 0) && (this.vect.y >= 0)) || ((this.vect.x <= 0) && (this.vect.y >= 0))) {
        ctx.rotate(-this.angle)
      } else {
        ctx.rotate(this.angle)
      }
    }

    ctx.beginPath();
    ctx.moveTo(-width2,                         MathFloor(-width2));
    ctx.lineTo(MathFloor(vlength-spear-width1), MathFloor(-width2));
    ctx.lineTo(MathFloor(vlength-2*spear),      MathFloor(-spear-width2));
    ctx.lineTo(MathFloor(vlength),              0);
    ctx.lineTo(MathFloor(vlength-2*spear),      MathFloor(spear+width2));
    ctx.lineTo(MathFloor(vlength-spear-width1), MathFloor(width2));
    ctx.lineTo(-width2,                         MathFloor(width2));

    ctx.closePath();
    ctx.stroke();
    ctx.fill();
    ctx.restore();

    // draw the text of the arrow
    if (this.text.hasContent) {
      midpX = parseInt((coordX + coordX1)/2) -3;
      midpY = parseInt((coordY + coordY1)/2) +3;
      this.text.draw(ctx, stroke, midpX, midpY);
    }
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var mathRound = Math.round;

  var evaluator;
  var space;
  var points;
  var radianAngle;
  var cosTheta;
  var senTheta;
  var tmpRotX;
  var tmpRotY;
  var tmpLineWidth;
  var lineDesp;
  var coordX;
  var coordY;

  /**
   * A Descartes polygon
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the polygon
   */
  descartesJS.Polygon = function(parent, values) {
    /**
     * the stroke width of the graph
     * type {Number}
     * @private
     */
    this.width = parent.evaluator.parser.parse("1");

    /**
     * the condition and the color of the fill
     * type {String}
     * @private
     */
    this.fill = "";

    // call the parent constructor
    descartesJS.Graphic.call(this, parent, values);

    this.endPoints = [];
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Polygon, descartesJS.Graphic);

  /**
   * Update polygon
   */
  descartesJS.Polygon.prototype.update = function() {
    evaluator = this.evaluator;

    points = evaluator.eval(this.expresion);

    for(var i=0, l=points.length; i<l; i++){
      this.endPoints[i] = { x: points[i][0], y: points[i][1] };
    }

    // rotate the elements in case the graphic is part of a macro
    if (this.rotateExp) {
      radianAngle = descartesJS.degToRad(evaluator.eval(this.rotateExp));
      cosTheta = Math.cos(radianAngle);
      senTheta = Math.sin(radianAngle);

      for (var i=0, l=this.endPoints.length; i<l; i++) {
        tmpRotX = this.endPoints[i].x*cosTheta - this.endPoints[i].y*senTheta;
        tmpRotY = this.endPoints[i].x*senTheta + this.endPoints[i].y*cosTheta;
        this.endPoints[i].x = tmpRotX;
        this.endPoints[i].y = tmpRotY;
      }
    }
  }

  /**
   * Draw the polygon
   */
  descartesJS.Polygon.prototype.draw = function() {
    // call the draw function of the father (uber instead of super as it is reserved word)
    this.uber.draw.call(this, this.fill, this.color);
  }

  /**
   * Draw the trace of the polygon
   */
  descartesJS.Polygon.prototype.drawTrace = function() {
    // call the drawTrace function of the father (uber instead of super as it is reserved word)
    this.uber.drawTrace.call(this, this.trace, this.trace);
  }

  /**
   * Auxiliary function for draw a polygon
   * @param {CanvasRenderingContext2D} ctx rendering context on which the polygon is drawn
   * @param {String} fill the fill color of the polygon
   * @param {String} stroke the stroke color of the polygon
   */
  descartesJS.Polygon.prototype.drawAux = function(ctx, fill, stroke) {
    evaluator = this.evaluator;
    space = this.space;

    // the width of a line can not be 0 or negative
    tmpLineWidth = mathRound( evaluator.eval(this.width) );
    ctx.lineWidth = (tmpLineWidth > 0) ? tmpLineWidth : 0.000001;

    ctx.strokeStyle = stroke.getColor();
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    lineDesp = (tmpLineWidth > 0) ? .5 : 0;

    coordX = mathRound( (this.abs_coord) ? this.endPoints[0].x : space.getAbsoluteX(this.endPoints[0].x) );
    coordY = mathRound( (this.abs_coord) ? this.endPoints[0].y : space.getAbsoluteY(this.endPoints[0].y) );

    ctx.beginPath();
    ctx.moveTo(coordX+lineDesp, coordY+lineDesp);

    for(var i=1, l=this.endPoints.length; i<l; i++) {
      coordX = mathRound( (this.abs_coord) ? this.endPoints[i].x : space.getAbsoluteX(this.endPoints[i].x) );
      coordY = mathRound( (this.abs_coord) ? this.endPoints[i].y : space.getAbsoluteY(this.endPoints[i].y) );
      
      ctx.lineTo(coordX+lineDesp, coordY+lineDesp);
    }

    // draw the fill
    if (this.fill) {
      ctx.fillStyle = fill.getColor();
      ctx.fill();
    }

    this.dashStyle();
    // draw the stroke
    ctx.stroke();

    // restore the dash style
    ctx.setLineDash([]);
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var mathRound = Math.round;
  var mathMin = Math.min;
  var mathMax = Math.max;
  var mathAbs = Math.abs;

  var evaluator;
  var space;
  var radianAngle;
  var cosTheta;
  var senTheta;
  var tmpRotX;
  var tmpRotY;
  var tmpLineWidth;
  var lineDesp;
  var x, y, w, h, r, sign;

  /**
   * A Descartes Rectangle
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the Rectangle
   */
  descartesJS.Rectangle = function(parent, values) {
    /**
     * the stroke width of the graph
     * type {Number}
     * @private
     */
    this.width = parent.evaluator.parser.parse("1");

    /**
     * the condition and the color of the fill
     * type {String}
     * @private
     */
    this.fill = "";

    /**
     */
    this.border_radius = parent.evaluator.parser.parse("0");

    // call the parent constructor
    descartesJS.Graphic.call(this, parent, values);

    this.endPoints = [];
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Rectangle, descartesJS.Graphic);

  /**
   * Update Rectangle
   */
  descartesJS.Rectangle.prototype.update = function() {
    evaluator = this.evaluator;
    
    expr = evaluator.eval(this.expresion);
    this.exprX = expr[0][0]; // the first value of the first expression
    this.exprY = expr[0][1]; // the second value of the first expression
    this.w = 150;
    this.h = 100;

    // rotate the elements in case the graphic is part of a macro
    if (this.rotateExp) {
      radianAngle = descartesJS.degToRad(evaluator.eval(this.rotateExp));
      cosTheta = Math.cos(radianAngle);
      senTheta = Math.sin(radianAngle);

      tmpRotX = this.exprX*cosTheta - this.exprY*senTheta;
      tmpRotY = this.exprX*senTheta + this.exprY*cosTheta;
      this.exprX = tmpRotX;
      this.exprY = tmpRotY;
    }

    // configuration of the form (x,y,ew,eh)
    if (expr[0].length >= 4) {
      this.w = expr[0][2];
      this.h = expr[0][3];
    }

    // configuration of the form (x,y)(ew,eh)
    if ((expr[1]) && (expr[1].length == 2)) {
      this.w = expr[1][0];
      this.h = expr[1][1];
    }

    this.w = mathMax(0, this.w);
    this.h = mathMax(0, this.h);
  }

  /**
   * Draw the Rectangle
   */
  descartesJS.Rectangle.prototype.draw = function() {
    // call the draw function of the father (uber instead of super as it is reserved word)
    this.uber.draw.call(this, this.fill, this.color);
  }

  /**
   * Draw the trace of the Rectangle
   */
  descartesJS.Rectangle.prototype.drawTrace = function() {
    // call the drawTrace function of the father (uber instead of super as it is reserved word)
    this.uber.drawTrace.call(this, this.fill, this.trace, "trace");
  }

  /**
   * Auxiliary function for draw a Rectangle
   * @param {CanvasRenderingContext2D} ctx rendering context on which the Rectangle is drawn
   * @param {String} fill the fill color of the Rectangle
   * @param {String} stroke the stroke color of the Rectangle
   */
  descartesJS.Rectangle.prototype.drawAux = function(ctx, fill, stroke, msg) {
    evaluator = this.evaluator;
    space = this.space;

    // the width of a line can not be 0 or negative
    tmpLineWidth = mathRound( evaluator.eval(this.width) );
    ctx.lineWidth = (tmpLineWidth > 0) ? tmpLineWidth : 0.000001;

    ctx.strokeStyle = stroke.getColor();
    ctx.lineCap = "round";
    ctx.lineJoin = "miter";

    lineDesp = (tmpLineWidth > 0) ? 0.5 : 0;

    x = mathRound( (this.abs_coord) ? this.exprX : space.getAbsoluteX(this.exprX) ) +lineDesp;
    y = mathRound( (this.abs_coord) ? this.exprY : space.getAbsoluteY(this.exprY) ) +lineDesp;
    w = (this.abs_coord) ? this.w : this.w*space.scale;
    h = (this.abs_coord) ? this.h : -this.h*space.scale;
    r = mathMin( mathMax(0, evaluator.eval(this.border_radius)), mathAbs(w)*0.5, mathAbs(h)*0.5 );
    sign = (this.abs_coord) ? 1 : -1;

    ctx.beginPath();
    if (r !== 0) {
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + sign*r);
      ctx.lineTo(x + w, y + h - sign*r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - sign*r);
      ctx.lineTo(x, y + sign*r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }
    else {
      ctx.moveTo(x, y);
      ctx.lineTo(x + w, y);
      ctx.lineTo(x + w, y + h);
      ctx.lineTo(x, y + h);
    }
    ctx.closePath();
    
    // draw the fill
    if (this.fill) {
      ctx.fillStyle = fill.getColor();
      ctx.fill();
    }

    this.dashStyle();
    // draw the stroke
    ctx.stroke();

    // restore the dash style
    ctx.setLineDash([]);
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var mathRound = Math.round;
  var mathMin   = Math.min;
  var mathMax   = Math.max;
  var mathAcos  = Math.acos;
  var mathSqrt  = Math.sqrt;
  var mathPI    = Math.PI;
  var math_PI_2 = mathPI/2;
  var math_2_PI = 2*mathPI;

  var evaluator;
  var expr;
  var macroAngle;
  var cosTheta;
  var senTheta;
  var tmpRotX;
  var tmpRotY;
  var iniAng;
  var endAng;
  var u1;
  var u2;
  var v1;
  var v2;
  var w1;
  var w2;
  var angulo1;
  var angulo2;
  var tmpAngulo1;
  var tmpAngulo2;
  var space;
  var coordX;
  var coordY;
  var radius;
  var tempAng;
  var clockwise;
  var tmpLineWidth;

  /**
   * A Descartes arc
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the arc
   */
  descartesJS.Arc = function(parent, values) {
    /**
     * the stroke width of the graph
     * type {Number}
     * @private
     */
    this.width = parent.evaluator.parser.parse("1");

    /**
     * the condition and the color of the fill
     * type {String}
     * @private
     */
    this.fill = "";

    /**
     * center of an arc
     * type {Node}
     * @private
     */
    this.center = parent.evaluator.parser.parse("(0,0)");

    /**
     * radius of an arc
     * type {Node}
     * @private
     */
    this.radius = parent.evaluator.parser.parse("1");

    /**
     * initial angle or vector of an arc
     * type {Node}
     * @private
     */
    this.init = "0";


    /**
     * final angle or vector of an arc
     * type {Node}
     * @private
     */
    this.end = "90";

    // call the parent constructor
    descartesJS.Graphic.call(this, parent, values);

    if (this.init.match(/^_\(/)) {
      this.initFlag = true;
      this.init = this.init.substring(1);
    }
    if (this.end.match(/^_\(/)) {
      this.endFlag = true;
      this.end = this.end.substring(1);
    }

    this.initExpr = parent.evaluator.parser.parse(this.init);
    this.endExpr = parent.evaluator.parser.parse(this.end);

    this.text = new descartesJS.TextObject(this, this.text);
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Arc, descartesJS.Graphic);

  /**
   * Update the arc
   */
  descartesJS.Arc.prototype.update = function() {
    evaluator = this.evaluator;

    expr = evaluator.eval(this.center);
    this.exprX = expr[0][0]; // the first value of the first expression
    this.exprY = expr[0][1]; // the second value of the first expression

    macroAngle = 0;

    // MACRO //
    // rotate the elements in case the graphic is part of a macro
    if (this.rotateExp) {
      macroAngle = descartesJS.degToRad(evaluator.eval(this.rotateExp));
      cosTheta = Math.cos(macroAngle);
      senTheta = Math.sin(macroAngle);

      tmpRotX = this.exprX*cosTheta - this.exprY*senTheta;
      tmpRotY = this.exprX*senTheta + this.exprY*cosTheta;
      this.exprX = tmpRotX;
      this.exprY = tmpRotY;
    }
    // MACRO //

    var initVal = evaluator.eval(this.initExpr);
    var endVal  = evaluator.eval(this.endExpr);

    // if the expression of the initial and final angle are parenthesized expressions
    if ( (/^(\(|\[)expr(\)|\])$/i).test(this.initExpr.type) && (/^(\(|\[)expr(\)|\])$/i).test(this.endExpr.type) ) {
      u1 = initVal[0][0];
      u2 = initVal[0][1];
      v1 = endVal[0][0];
      v2 = endVal[0][1];

      // arc expressed with points in the space
      if (!this.vectors) {
        if (this.abs_coord) {
          u1 =  u1 - this.exprX;
          u2 = -u2 + this.exprY;
          v1 =  v1 - this.exprX;
          v2 = -v2 + this.exprY;
        }
        else {
          u1 = u1 - this.exprX;
          u2 = u2 - this.exprY;
          v1 = v1 - this.exprX;
          v2 = v2 - this.exprY;
        }
      }
      // arc expressed with vectors
      else {
        if (this.abs_coord) {
          u2 = -u2;
          v2 = -v2;
        }
      }

      w1 = 1;
      w2 = 0;

      // find the angles
      angulo1 = (u1 == 0) ? ((u2 < 0) ? 3*math_PI_2 : math_PI_2) : mathAcos( (u1*w1)/mathSqrt(u1*u1+u2*u2) );
      angulo2 = (v1 == 0) ? ((v2 < 0) ? 3*math_PI_2 : math_PI_2) : mathAcos( (v1*w1)/mathSqrt(v1*v1+v2*v2) );
      angulo1 += macroAngle;
      angulo2 += macroAngle;

      // change considering the quadrant for the first angle
      if ((u1 > 0) && (u2 > 0) && this.abs_coord) {
        angulo1 = math_2_PI-angulo1;
      }
      if ((u1 > 0) && (u2 < 0) && !this.abs_coord) {
        angulo1 = math_2_PI-angulo1;
      }
      if ((u1 < 0) && (u2 < 0) && !this.abs_coord) {
        angulo1 = math_2_PI-angulo1;
      }
      if ((u1 < 0) && (u2 > 0) && this.abs_coord) {
        angulo1 = math_2_PI-angulo1;
      }

      // change considering the quadrant for the second angle
      if ((v1 > 0) && (v2 > 0) && this.abs_coord) {
        angulo2 = math_2_PI-angulo2;
      }
      if ((v1 > 0) && (v2 < 0) && !this.abs_coord) {
        angulo2 = math_2_PI-angulo2;
      }
      if ((v1 < 0) && (v2 < 0) && !this.abs_coord) {
        angulo2 = math_2_PI-angulo2;
      }
      if ((v1 < 0) && (v2 > 0) && this.abs_coord) {
        angulo2 = math_2_PI-angulo2;
      }

      if (this.initFlag) {
        tmpAngulo1 = angulo1;
        angulo1 = angulo2;
        angulo2 = tmpAngulo1;
      }
      else {
        // always choose the angles in order from lowest to highest
        tmpAngulo1 = mathMin(angulo1, angulo2);
        tmpAngulo2 = mathMax(angulo1, angulo2);
        angulo1 = tmpAngulo1;
        angulo2 = tmpAngulo2;

        // if the internal angle if greater than PI and the angle is in absolute coordinates
        if (((angulo2 - angulo1) > mathPI) && this.abs_coord) {
          angulo1 = tmpAngulo2;
          angulo2 = tmpAngulo1;
        }
        // if the internal angle if less than PI and the angle is in relative coordinates
        if (((angulo2 - angulo1) <= mathPI) && !this.abs_coord) {
          angulo1 = tmpAngulo2;
          angulo2 = tmpAngulo1;
        }
      }

      this.iniAng = angulo1;
      this.endAng = angulo2;

      this.drawPoints = true;
    }
    // arc expressed with angles
    else {
      this.iniAng = descartesJS.degToRad(initVal) +macroAngle;
      this.endAng = descartesJS.degToRad(endVal)  +macroAngle;
      this.drawAngle = true;
    }

  }

  /**
   * Draw the arc
   */
  descartesJS.Arc.prototype.draw = function() {
    // call the draw function of the father (uber instead of super as it is reserved word)
    this.uber.draw.call(this, this.fill, this.color);
  }

  /**
   * Draw the trace of the arc
   */
  descartesJS.Arc.prototype.drawTrace = function() {
    // call the drawTrace function of the father (uber instead of super as it is reserved word)
    this.uber.drawTrace.call(this, this.fill, this.trace);
  }

  /**
   * Auxiliary function for draw an arc
   * @param {CanvasRenderingContext2D} ctx rendering context on which the arc is drawn
   * @param {String} fill the fill color of the arc
   * @param {String} stroke the stroke color of the arc
   */
  descartesJS.Arc.prototype.drawAux = function(ctx, fill, stroke) {
    evaluator = this.evaluator;
    space = this.space;

    radius = evaluator.eval(this.radius);
    if (radius < 0) {
      radius = 0;
    }

    // the width of a line can not be 0 or negative
    tmpLineWidth = mathRound( evaluator.eval(this.width) );
    ctx.lineWidth = (tmpLineWidth > 0) ? tmpLineWidth : 0.000001;

    ctx.lineCap = "round";
    ctx.strokeStyle = stroke.getColor();

    // draw the arc when especified in angles
    if (this.drawAngle) {
      if (this.abs_coord) {
        coordX = mathRound(this.exprX);
        coordY = mathRound(this.exprY);
      }
      else {
        coordX = mathRound(space.getAbsoluteX(this.exprX));
        coordY = mathRound(space.getAbsoluteY(this.exprY));
        radius = radius*space.scale;
        this.iniAng = -this.iniAng;
        this.endAng = -this.endAng;
      }

      if (this.iniAng > this.endAng) {
        tempAng = this.iniAng;
        this.iniAng = this.endAng;
        this.endAng = tempAng;
      }
    }
    // draw the arc when especified with points
    else if (this.drawPoints) {
      if (this.abs_coord) {
        coordX = mathRound(this.exprX);
        coordY = mathRound(this.exprY);
      }
      else {
        coordX = mathRound(space.getAbsoluteX(this.exprX));
        coordY = mathRound(space.getAbsoluteY(this.exprY));
        radius = radius*space.scale;
        this.iniAng = -this.iniAng;
        this.endAng = -this.endAng;
      }
    }

    if (this.fill) {
      ctx.fillStyle = fill.getColor();
      ctx.beginPath();
      ctx.moveTo(coordX, coordY);
      ctx.arc(coordX, coordY, radius, this.iniAng, this.endAng, clockwise);
      ctx.fill();
    }

    ctx.beginPath();
    ctx.arc(coordX, coordY, radius, this.iniAng, this.endAng, clockwise);
    this.dashStyle();
    ctx.stroke();

    // draw the text of the arc
    if (this.text.hasContent) {
      this.text.draw(ctx, this.color, coordX, coordY);
    }
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var evaluator;
  var expr;
  var radianAngle;
  var cosTheta;
  var senTheta;
  var tmpRotX;
  var tmpRotY;

  var width;
  var height;
  var textLine;
  var w;
  var newText;

  var restText;
  var resultText;
  var tempText;
  var charAt;
  var lastIndex;
  var decimals;

  var tmpString;

  var fsize;
  var posX;
  var posY;

  /**
   * A Descartes text
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the text
   */
  descartesJS.Text = function(parent, values) {
    /**
     * the stroke width of the graph
     * type {Number}
     * @private
     */
    this.width = parent.evaluator.parser.parse("0");

    // call the parent constructor
    descartesJS.Graphic.call(this, parent, values);
    
    // alignment
    if (!this.align) this.align = "left";
    // anchor
    if (!this.anchor) this.anchor = "top_left";

    this.text = new descartesJS.TextObject(this, this.text);
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Text, descartesJS.Graphic);

  /**
   * Update the text
   */
  descartesJS.Text.prototype.update = function() {
    evaluator = this.evaluator;

    expr = evaluator.eval(this.expresion);
    this.exprX = expr[0][0]; // the first value of the first expression
    this.exprY = expr[0][1]; // the second value of the first expression

    // rotate the elements in case the graphic is part of a macro
    if (this.rotateExp) {
      radianAngle = descartesJS.degToRad(evaluator.eval(this.rotateExp));
      cosTheta = Math.cos(radianAngle);
      senTheta = Math.sin(radianAngle);

      tmpRotX = this.exprX*cosTheta - this.exprY*senTheta;
      tmpRotY = this.exprX*senTheta + this.exprY*cosTheta;
      this.exprX = tmpRotX;
      this.exprY = tmpRotY;
    }
  }

  /**
   * Draw the text
   */
  descartesJS.Text.prototype.draw = function() {
    // call the draw function of the father (uber instead of super as it is reserved word)
    this.uber.draw.call(this, this.color);
  }

  /**
   * Draw the trace of the text
   */
  descartesJS.Text.prototype.drawTrace = function() {
    // call the drawTrace function of the father (uber instead of super as it is reserved word)
    this.uber.drawTrace.call(this, this.trace);
  }

  /**
   * Auxiliary function for draw a text
   * @param {CanvasRenderingContext2D} ctx rendering context on which the text is drawn
   * @param {String} fill the fill color of the text
   * @param {String} stroke the stroke color of the text
   */
  descartesJS.Text.prototype.drawAux = function(ctx, fill) {
    if (this.abs_coord) {
      posX = parseInt(this.exprX);
      posY = parseInt(this.exprY);
    }
    else {
      posX = parseInt( this.space.getAbsoluteX(this.exprX) );
      posY = parseInt( this.space.getAbsoluteY(this.exprY) );
    }

    this.text.draw(ctx, fill, posX, posY);
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var mathRound = Math.round;

  var evaluator;
  var expr;
  var radianAngle;
  var cosTheta;
  var senTheta;
  var tmpRotX;
  var tmpRotY;
  var imgFile;
  var space;
  var despX;
  var despY;
  var coordX;
  var coordY;
  var rotation;

  var w;
  var h;


  /**
   * A Descartes image
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the image
   */
  descartesJS.Image = function(parent, values) {
    /**
     * the file name of the graphic
     * type {String}
     * @private
     */
    this.file = "";

    /**
     * the rotation of an image
     * type {Node}
     * @private
     */
    this.inirot = parent.evaluator.parser.parse("0");

    // call the parent constructor
    descartesJS.Graphic.call(this, parent, values);

    this.img = new Image();

    this.scaleX = 1;
    this.scaleY = 1;

    this.ratio = parent.ratio;

    this.update();
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Image, descartesJS.Graphic);

  /**
   * Update the image
   */
  descartesJS.Image.prototype.update = function() {
    evaluator = this.evaluator;

    expr = evaluator.eval(this.expresion);
    this.exprX = expr[0][0]; // the first value of the first expression
    this.exprY = expr[0][1]; // the second value of the first expression

    // rotate the elements in case the graphic is part of a macro
    if (this.rotateExp) {
      radianAngle = descartesJS.degToRad(evaluator.eval(this.rotateExp));
      cosTheta = Math.cos(radianAngle);
      senTheta = Math.sin(radianAngle);

      tmpRotX = this.exprX*cosTheta - this.exprY*senTheta;
      tmpRotY = this.exprX*senTheta + this.exprY*cosTheta;
      this.exprX = tmpRotX;
      this.exprY = tmpRotY;
    }

    // configuration of the form (x,y,ew,eh)
    if (expr[0].length >= 4) {
      this.centered = true;
      this.scaleX = expr[0][2];
      this.scaleY = expr[0][3];
    }

    // configuration of the form (x,y)(ew,eh)
    if ((expr[1]) && (expr[1].length == 2)) {
      this.centered = true;
      this.scaleX = expr[1][0];
      this.scaleY = expr[1][1];
    }

    if (this.scaleX == 0) {
      this.scaleX = 0.00001;
    }
    if (this.scaleY == 0) {
      this.scaleY = 0.00001;
    }

    var self = this;
    imgFile = evaluator.eval(this.file);
    if ((imgFile) || (imgFile == "")) {
      this.img = this.parent.getImage(imgFile);
      this.img.addEventListener("load", function(evt) {
        self.space.update(true);
      });
    }
  }

  /**
   * Draw the image
   */
  descartesJS.Image.prototype.draw = function() {
    // call the draw function of the father (uber instead of super as it is reserved word)
    this.uber.draw.call(this);
  }

  /**
   * Draw the trace of the image
   */
  descartesJS.Image.prototype.drawTrace = function() {
    // call the drawTrace function of the father (uber instead of super as it is reserved word)
    this.uber.drawTrace.call(this);
  }

  /**
   * Auxiliary function for draw an image
   * @param {CanvasRenderingContext2D} ctx rendering context on which the image is drawn
   */
  descartesJS.Image.prototype.drawAux = function(ctx) {
    evaluator = this.evaluator;
    space = this.space;

    if ( (this.img) && (this.img.ready) && (this.img.complete) ) {
      w = this.img.width;
      h = this.img.height;

      // if the images is a space image
      if (this.img.canvas) {
        w = mathRound( w/this.ratio );
        h = mathRound( h/this.ratio );
      }

      despX = (this.centered) ? 0 : mathRound(w/2);
      despY = (this.centered) ? 0 : mathRound(h/2);

      coordX = mathRound( (this.abs_coord) ? this.exprX : space.getAbsoluteX(this.exprX) );
      coordY = mathRound( (this.abs_coord) ? this.exprY : space.getAbsoluteY(this.exprY) );
      rotation = descartesJS.degToRad(-evaluator.eval(this.inirot));

      ctx.save();
      ctx.translate(coordX+despX, coordY+despY);
      ctx.rotate(rotation);

      if (this.opacity) {
        ctx.globalAlpha = evaluator.eval(this.opacity);
      }

      // draw image
      ctx.scale(this.scaleX, this.scaleY);
      ctx.drawImage(this.img, -w/2, -h/2, w, h);

      // reset the transformations
      ctx.restore();
    }
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var expr;
  var x;
  var y;
  var pixelStack;
  var currentPixel;
  var startColor;
  var index;
  var count;

  /**
   * A Descartes fill
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the fill
   */
  descartesJS.Fill = function(parent, values) {
    // call the parent constructor
    descartesJS.Graphic.call(this, parent, values);
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Fill, descartesJS.Graphic);

  /**
   * Update the fill
   */
  descartesJS.Fill.prototype.update = function() {
    expr = this.evaluator.eval(this.expresion);

    this.exprX = expr[0][0]; // the first value of the first expression
    this.exprY = expr[0][1]; // the second value of the first expression
  }

  /**
   * Draw the fill
   */
  descartesJS.Fill.prototype.draw = function() {
    // call the draw function of the father (uber instead of super as it is reserved word)
    this.uber.draw.call(this, this.color, this.color);
  }

  /**
   * Draw the trace of the fill
   */
  descartesJS.Fill.prototype.drawTrace = function() {
    // call the drawTrace function of the father (uber instead of super as it is reserved word)
    this.uber.drawTrace.call(this, this.trace, this.trace);
    // console.log("hola")
  }

  /**
   * Auxiliary function for draw a fill
   * @param {CanvasRenderingContext2D} ctx rendering context on which the fill is drawn
   * @param {String} fill the fill color of the fill
   */
  descartesJS.Fill.prototype.drawAux = function(ctx, fill) {
    // update the color components of the fill color
    fill.getColor();
    imageData = ctx.getImageData(0, 0, this.space.w, this.space.h);

    if (this.abs_coord) {
      x = parseInt(this.exprX);
      y = parseInt(this.exprY);
    }
    else {
      x = parseInt( this.space.getAbsoluteX(this.exprX) );
      y = parseInt( this.space.getAbsoluteY(this.exprY) );
    }

    if ((x < 0) || (y < 0) || (x >= this.space.w) || (y >= this.space.h)) {
      return;
    }

    pixelStack = [[x, y]];

    startColor = getPixel(imageData, x, y);
    count = 0;

    while(pixelStack.length > 0) {
      count++;
      currentPixel = pixelStack.pop();
      x = currentPixel[0];
      y = currentPixel[1];

      if (equalColor(startColor, getPixel(imageData, x, y))) {
        // asign the color
        setPixel(imageData, x, y, fill);

        // add the next pixel to the stack
        if (x > 0) {
          pixelStack.push([x-1, y]);
        }
        if (x < imageData.width-1) {
          pixelStack.push([x+1, y]);
        }
        pixelStack.push([x, y-1]);
        pixelStack.push([x, y+1]);
      }

      //exit safe
      if (count >= this.space.w*this.space.h*3) {
        break;
      }
    }

    ctx.putImageData(imageData, 0, 0);
  }

  /**
   *
   */
  function getPixel(imageData, x, y) {
    index = (x + y*imageData.width) *4;

    return { r: imageData.data[index],
             g: imageData.data[index+1],
             b: imageData.data[index+2],
             a: imageData.data[index+3]
           }
  }

  /**
   *
   */
  function setPixel(imageData, x, y, color) {
    index = (x + y * imageData.width) * 4;
    imageData.data[index+0] = color.r;
    imageData.data[index+1] = color.g;
    imageData.data[index+2] = color.b;
    imageData.data[index+3] = color.a*255;
  }

  /**
   *
   */
  function equalColor(c1, c2) {
    return (c1.r === c2.r) && (c1.g === c2.g) && (c1.b === c2.b) && (c1.a === c2.a);
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS, babel) {
  if (descartesJS.loadLib) { return descartesJS; }

  var regExpType = new String("-text-image-point-polygon-arc-segment-arrow-macro-curve-equation-sequence-rectangle-fill-");
  
  var regExpImage = /[\w\.\-//]*(\.png|\.jpg|\.gif|\.svg)/gi;
  var expr;

  /**
   * A Descartes macro
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the macro
   */
  descartesJS.Macro = function(parent, values) {
    /**
     * the expression for determine the position of the graphic
     * type {Node}
     * @private
     */
    this.hasExpresion = false;

    /**
     * the macro rotation
     * type {Node}
     * @private
     */
    this.inirot = parent.evaluator.parser.parse("0");

    /**
     * the macro position
     * type {Node}
     * @private
     */
    this.inipos = parent.evaluator.parser.parse("(0,0)");

    // call the parent constructor
    descartesJS.Graphic.call(this, parent, values);

    // traverse the values to replace the defaults values of the object
    for (var propName in values) {
      if (propName == "expresion") {
        this.hasExpresion = true;
      }

      // verify the own properties of the object
      if (values.hasOwnProperty(propName)) {
        this[propName] = values[propName];
      }
    }

    this.graphics = [];

    var lessonParser = parent.lessonParser;
    var tokenizer = new descartesJS.Tokenizer();

    // if the expression is empty
    if (!this.hasExpresion) {
      return;
    }

    // if the macro name was not specified as a string, then adds single quotes to turn it into string
    if ( !(this.expresion.charAt(0) === "'")) {
      this.expresion = "'" + this.expresion + "'";
    }
    this.expresion = this.evaluator.parser.parse(this.expresion);

    var filename = this.evaluator.eval(this.expresion);
    var response;

    if (filename) {
      // the macro is embeded in the webpage
      var macroElement = document.getElementById(filename);

      if ((macroElement) && (macroElement.type == "descartes/macro")) {
        response = macroElement.text;
      }
      // the macro is in an external file
      else {
        response = descartesJS.openExternalFile(filename);
      }
    }

    var indexOfEqual;
    var tmpIniti;
    var tmpResponse;

    // if it was posible to read the macro
    if (response) {
      tmpResponse = ( response.replace(/&aacute;/g, "\u00e1").replace(/&eacute;/g, "\u00e9").replace(/&iacute;/g, "\u00ed").replace(/&oacute;/g, "\u00f3").replace(/&uacute;/g, "\u00fa").replace(/&Aacute;/g, "\u00c1").replace(/&Eacute;/g, "\u00c9").replace(/&Iacute;/g, "\u00cd").replace(/&Oacute;/g, "\u00d3").replace(/&Uacute;/g, "\u00da").replace(/&ntilde;/g, "\u00f1").replace(/&Ntilde;/g, "\u00d1").replace(/\&gt;/g, ">").replace(/\&lt;/g, "<").replace(/\&amp;/g, "&").replace(/\r/g, "") ).split("\n");

      // maintain only the lines that have information for the macro
      response = [];

      for(var i=0, l=tmpResponse.length; i<l; i++) {
        if (tmpResponse[i].trim()) {
          indexOfEqual = tmpResponse[i].indexOf("=");
          if(indexOfEqual !== -1) {
            var tmpSplitLine = lessonParser.split(tmpResponse[i]);
            for (var iT=0,lT=tmpSplitLine.length; iT<lT; iT++) {
              if ((tmpSplitLine[iT]) && (tmpSplitLine.length >1)) {
                if ((babel[tmpSplitLine[iT][0]] === "id") || (babel[tmpSplitLine[iT][0]] === "type")) {
                  response.push(tmpSplitLine);
                  break;
                }
              }
            }
          }
        }
      }

      var respText;
      var babelResp;
      var dotIndex;
      var tmpTokens;
      var tmpTokensRespText;
      var isID;
      // add the macro name as a prefix, only in some expressions
      for (var i=0, l=response.length; i<l; i++) {
        respText = response[i] || [];

        isID = ((respText) && (respText[0]) && (respText[0][0] === "id"));

        for (var j=0, k=respText.length; j<k; j++) {
          // if the parameters have a dot
          dotIndex = respText[j][0].indexOf(".");
          if ((dotIndex !== -1) && (!isID)) {
            babelResp = babel[respText[j][0].substring(dotIndex+1)];
            respText[j][0] = this.name + "." + respText[j][0];
          }
          else {
            babelResp = babel[respText[j][0]];
          }

          // if the expressions are different from this, then the cycle continues and is not replaced nothing
          if ( (babelResp === "font") ||
               (babelResp === "font_family") ||
               (((babelResp === "fill") || (babelResp === "color") || (babelResp === "border") || (babelResp === "arrow")) && (respText[j][1].charAt(0) !== "(")) ||
               ((babelResp === "file") && (respText[j][1].match(regExpImage))) ||
               ((babelResp !== "id") && (babel[respText[j][1]] !== undefined))
             ) {
              if (babelResp !== "radius") {
                continue;
              }
          }

          // is a text
          if (babelResp == "text") {
            // if the text is rtf must processing it diferent
            if (respText[j][1].match(/\{\\rtf1/)) {
              var textTemp = respText[j][1];

              //////////////////////////////////////////////////////////////////////////////////////////////////////////////
              var self = this;

              // function to replace expresions
              var funReplace = function(str, m1) {
                var tokens = tokenizer.tokenize(m1.replace(/\&squot;/g, "'"));

                for (var t=0, lt=tokens.length; t<lt; t++) {
                  if ((tokens[t].type == "identifier")  && (!descartesJS.reservedIds.match("-" + tokens[t].value + "-"))) {
                    tokens[t].value = self.name + "." + tokens[t].value;
                  }
                }

                var prefix = (str.match(/^\\expr/)) ? "\\expr " : "\\decimals ";

                return prefix + tokenizer.flatTokens(tokens);
              }
              //////////////////////////////////////////////////////////////////////////////////////////////////////////////

              textTemp = textTemp.replace(/\\expr ([a-zA-Z_0-9\u00C0-\u021B+*/%|&^#!?:()><.'\+\-]*)/gi, funReplace);
              textTemp = textTemp.replace(/\\decimals ([a-zA-Z_0-9\u00C0-\u021B+*/%|&^#!?:()><.'\+\-]*)/gi, funReplace);

              respText[j][1] = textTemp;
            }
            // simple text
            else {
              tmpTokensRespText = lessonParser.parseText(respText[j][1]).textElementsMacros;

              for (var ttrt=0, lttrt=tmpTokensRespText.length; ttrt<lttrt; ttrt++) {
                tmpTokens = tokenizer.tokenize(tmpTokensRespText[ttrt].replace(/\&squot;/g, "'"));

                for (var tt=0, ltt=tmpTokens.length; tt<ltt; tt++) {
                  if ((tmpTokens[tt].type === "identifier") && (!descartesJS.reservedIds.match("-" + tmpTokens[tt].value + "-"))) {
                    tmpTokens[tt].value = this.name + "." + tmpTokens[tt].value;
                  }
                }
                tmpTokens = (tokenizer.flatTokens(tmpTokens)).replace(/&squot;/g, "'").replace(/'\+\(/g, "[").replace(/\)\+'/g, "]");

                tmpTokensRespText[ttrt] = tmpTokens.substring(1, tmpTokens.length-1);
              }

              respText[j][1] = tmpTokensRespText.join("");
            }
          }
          // the token is not a text
          else {
            var tmpTokensArray = respText[j][1].replace(/\&squot;/g, "'").split(";");

            for (var tmpI=0, tmpL=tmpTokensArray.length; tmpI<tmpL; tmpI++) {
              tmpTokens = tokenizer.tokenize(tmpTokensArray[tmpI].replace(/\\n/g, ";"));

              for (var t=0, lt=tmpTokens.length; t<lt; t++) {
                if ((tmpTokens[t].type === "identifier") && (!descartesJS.reservedIds.match("-" + tmpTokens[t].value + "-"))) {
                  tmpTokens[t].value = this.name + "." + tmpTokens[t].value;
                }
              }

              tmpTokensArray[tmpI] = tokenizer.flatTokens(tmpTokens);
            }

            respText[j][1] = tmpTokensArray.join(";");
          }
        }
      }

      var tempResp;
      var isGraphic;

      // flat the expresions to obtain a string
      for (var i=0, l=response.length; i<l; i++) {
        if (response[i][0]) {
          tempResp = "";
          isGraphic = false;

          for (var j=0, k=response[i].length; j<k; j++) {
            // if the object has a type and is of the graphic type, then is a graphic object
            if ( (babel[response[i][j][0]] === "type") && (regExpType.match("-" + babel[response[i][j][1]] + "-")) ) {
              isGraphic = true;
            }
            tempResp = tempResp + response[i][j][0] + "='" + response[i][j][1] + "' ";
          }

          response[i] = tempResp + ((isGraphic) ? " space='" + this.spaceID + "'" : "");

          // build and add the graphic elements to the space
          if (isGraphic) {
            //agregar algo mas para indicar que se viene de un macro
            this.graphics.push( lessonParser.parseGraphic(response[i], this.abs_coord, this.background, this.inirot) );
          }
          // build and add the axiliaries to the scene
          else {
            lessonParser.parseAuxiliar(response[i]);
          }
        }
      }
    }
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Macro, descartesJS.Graphic);

  /**
   * Update the macro
   */
  descartesJS.Macro.prototype.update = function() {
    expr = this.evaluator.eval(this.inipos);
    this.iniPosX = expr[0][0];
    this.iniPosY = expr[0][1];
  }

  /**
   * Auxiliary function for draw a macro
   * @param {CanvasRenderingContext2D} ctx rendering context on which the macro is drawn
   */
  descartesJS.Macro.prototype.drawAux = function(ctx) {
    for (var i=0, l=this.graphics.length; i<l; i++) {
      if (this.graphics[i]) {
        ctx.save();

        if (this.graphics[i].abs_coord) {
          ctx.translate(this.iniPosX, this.iniPosY);
        }
        else {
          ctx.translate(this.iniPosX*this.space.scale, -this.iniPosY*this.space.scale);
        }

        this.graphics[i].draw();

        // reset the transformations
        // ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.restore();
      }
    }
  }

  return descartesJS;
})(descartesJS || {}, babel);
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathSqrt = Math.sqrt;
  var MathSin = Math.sin;
  var MathCos = Math.cos;

  var len;
  var s;
  var c;
  var a00;
  var a01;
  var a02;
  var a03;
  var a10;
  var a11;
  var a12;
  var a13;
  var a20;
  var a21;
  var a22;
  var a23;
  var a30;
  var a31;
  var a32;
  var a33;
  var b00;
  var b01;

  descartesJS.norm3D = function(v) {
    return MathSqrt(v.x * v.x + v.y * v.y + v.z * v.z);
  }

  descartesJS.normalize3D = function(v) {
    len = descartesJS.norm3D(v);

    if (len === 0) {
      return { x: 0, 
               y: 0, 
               z: 0 
             };
    }
    else if (len === 1) {
      return { x: v.x, 
               y: v.y, 
               z: v.z 
             };
    }
    
    len = 1/len;

    return { x: v.x*len, 
             y: v.y*len, 
             z: v.z*len 
           };   
  }

  descartesJS.dotProduct3D = function(v1, v2) {
    return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;    
  }

  descartesJS.crossProduct3D = function(v1, v2) {
    return { x: v1.y*v2.z - v1.z*v2.y,
             y: v1.z*v2.x - v1.x*v2.z,
             z: v1.x*v2.y - v1.y*v2.x
           };
  }

  descartesJS.scalarProduct3D = function(v, s) {
    return { x: v.x*s, 
             y: v.y*s,
             z: v.z*s
           };
  }

  descartesJS.subtract3D = function(v1, v2) {
    return { x: v1.x - v2.x,
             y: v1.y - v2.y,
             z: v1.z - v2.z
           };
  }

  descartesJS.add3D = function(v1, v2) {
    return { x: v1.x + v2.x,
             y: v1.y + v2.y,
             z: v1.z + v2.z
           };
  }

  descartesJS.equals3DEpsilon = function(p1, p2, epsilon) {
    return (Math.abs(p1.x-p2.x) <= epsilon) && 
           (Math.abs(p1.y-p2.y) <= epsilon) && 
           (Math.abs(p1.z-p2.z) <= epsilon);
  }


  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
  descartesJS.Vector4D = function(x, y, z, w) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = w || 0;
    this.adjustDec();
  }

  var pres = 1000000000;
  descartesJS.Vector4D.prototype.adjustDec = function() {
    this.x = parseInt(this.x*pres)/pres;
    this.y = parseInt(this.y*pres)/pres;
    this.z = parseInt(this.z*pres)/pres;
  }

  descartesJS.Matrix4x4 = function( a00, a01, a02, a03,
                                    a10, a11, a12, a13,
                                    a20, a21, a22, a23,
                                    a30, a31, a32, a33
                                   ) {
    this.a00 = a00 || 0;
    this.a01 = a01 || 0;
    this.a02 = a02 || 0;
    this.a03 = a03 || 0;
    this.a10 = a10 || 0;
    this.a11 = a11 || 0;
    this.a12 = a12 || 0;
    this.a13 = a13 || 0;
    this.a20 = a20 || 0;
    this.a21 = a21 || 0;
    this.a22 = a22 || 0;
    this.a23 = a23 || 0;
    this.a30 = a30 || 0;
    this.a31 = a31 || 0;
    this.a32 = a32 || 0;
    this.a33 = a33 || 0;
  }

  descartesJS.Matrix4x4.prototype.setIdentity = function() {
    this.a00 = 1;
    this.a01 = 0;
    this.a02 = 0;
    this.a03 = 0;
    
    this.a10 = 0;
    this.a11 = 1;
    this.a12 = 0;
    this.a13 = 0;
    
    this.a20 = 0;
    this.a21 = 0;
    this.a22 = 1;
    this.a23 = 0;

    this.a30 = 0;
    this.a31 = 0;
    this.a32 = 0;
    this.a33 = 1;
    
    return this;
  }

  descartesJS.Matrix4x4.prototype.multiplyVector4 = function(v) {
    return new descartesJS.Vector4D(v.x * this.a00 + v.y * this.a10 + v.z * this.a20 + v.w * this.a30,
                                    v.x * this.a01 + v.y * this.a11 + v.z * this.a21 + v.w * this.a31,
                                    v.x * this.a02 + v.y * this.a12 + v.z * this.a22 + v.w * this.a32,
                                    v.x * this.a03 + v.y * this.a13 + v.z * this.a23 + v.w * this.a33
                                   );
  }

  descartesJS.Matrix4x4.prototype.translate = function(v) {
    return new descartesJS.Matrix4x4(this.a00, this.a01, this.a02, this.a03,
                                     this.a10, this.a11, this.a12, this.a13,
                                     this.a20, this.a21, this.a22, this.a23,
                                     this.a00 * v.x + this.a10 * v.y + this.a20 * v.z + this.a30, this.a01 * v.x + this.a11 * v.y + this.a21 * v.z + this.a31, this.a02 * v.x + this.a12 * v.y + this.a22 * v.z + this.a32, this.a03 * v.x + this.a13 * v.y + this.a23 * v.z + this.a33
                                    );
  }

  descartesJS.Matrix4x4.prototype.rotateX = function(angle) {
    s = MathSin(angle);
    c = MathCos(angle);
    
    a10 = this.a10;
    a11 = this.a11;
    a12 = this.a12;
    a13 = this.a13;
    a20 = this.a20;
    a21 = this.a21;
    a22 = this.a22;
    a23 = this.a23;
    
    return new descartesJS.Matrix4x4(this.a00, this.a01, this.a02, this.a03,
                                     a10 *  c + a20 * s, a11 *  c + a21 * s, a12 *  c + a22 * s, a13 *  c + a23 * s,
                                     a10 * -s + a20 * c, a11 * -s + a21 * c, a12 * -s + a22 * c, a13 * -s + a23 * c,
                                     this.a30, this.a31, this.a32, this.a33
                                    );
  }
  
  descartesJS.Matrix4x4.prototype.rotateY = function(angle) {
    s = MathSin(angle);
    c = MathCos(angle);
    
    a00 = this.a00;
    a01 = this.a01;
    a02 = this.a02;
    a03 = this.a03;
    a20 = this.a20;
    a21 = this.a21;
    a22 = this.a22;
    a23 = this.a23;
    
    return new descartesJS.Matrix4x4(a00 * c + a20 * -s, a01 * c + a21 * -s, a02 * c + a22 * -s, a03 * c + a23 * -s,
                                     this.a10, this.a11, this.a12, this.a13, 
                                     a00 * s + a20 * c, a01 * s + a21 * c, a02 * s + a22 * c, a03 * s + a23 * c,
                                     this.a30, this.a31, this.a32, this.a33
                                    );
  }

  descartesJS.Matrix4x4.prototype.rotateZ = function(angle) {  
    s = MathSin(angle);
    c = MathCos(angle);
    
    a00 = this.a00;
    a01 = this.a01;
    a02 = this.a02;
    a03 = this.a03;
    a10 = this.a10;
    a11 = this.a11;
    a12 = this.a12;
    a13 = this.a13;
    
    return new descartesJS.Matrix4x4(a00 *  c + a10 * s, a01 *  c + a11 * s, a02 *  c + a12 * s, a03 *  c + a13 * s,
                                     a00 * -s + a10 * c, a01 * -s + a11 * c, a02 * -s + a12 * c, a03 * -s + a13 * c,
                                     this.a20, this.a21, this.a22, this.a23,
                                     this.a30, this.a31, this.a32, this.a33
                                    );
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathFloor = Math.floor;
  var Math2PI = 2*Math.PI;
  var lineCap = "round";
  var lineJoin = "round";

  var v1;
  var v2;
  var evaluator;
  var verticalDisplace;
  var horizontalDisplace;
  var pointDisplace;
  var theText;

  var tempParam;

  var epsilon = 0.00000001;

  var i;
  var l;
  var d;

  var tmpVertices;


  /**
   * 3D primitive (vertex, face, text, edge)
   * @constructor
   */
  descartesJS.Primitive3D = function (values, space) {
    this.space = space;

    // traverse the values to replace the defaults values of the object
    for (var propName in values) {
      // verify the own properties of the object
      if (values.hasOwnProperty(propName)) {
        this[propName] = values[propName];
      }
    }

    this.projVert = [];
    this.spaceVertices = [];

    this.newProjVert = [];
    this.newSpaceVert = [];

    // asign the corresponding drawing function
    if (this.type === "vertex") {
      this.draw = drawVertex;
    }
    else if (this.type === "face") {
      this.normal = getNormal(this.vertices[0], this.vertices[1], this.vertices[2]);
      this.draw = drawFace;
    }
    else if (this.type === "text") {
      this.draw = drawPrimitiveText;
    }
    else if (this.type === "edge") {
      this.draw = drawEdge;
    }

    // overwrite the computeDepth function if the primitive is a text
    if (this.isText) {
      this.computeDepth = function() {
        this.normal = { x: 0, y: 0, z: 0 };
        this.projVert = this.vertices;
        this.depth = this.vertices[0].z;
        this.average = this.vertices[0];
      }
    }
  }

  /**
   * Compute a transformation to the vertices
   * @param
   */
  descartesJS.Primitive3D.prototype.computeDepth = function(space) {
    this.space = space;

    this.average = { x: 0, y: 0, z: 0 };

    // remove repeated vertices
    this.removeDoubles();

    this.normal = { x: 0, y: 1, z: 0 };
    this.direction = { x: 1, y: 0, z: 0 };

    // apply the camera rotation
    for (i=0, l=this.vertices.length; i<l; i++) {
      this.spaceVertices[i] = space.rotateVertex(this.vertices[i]);
      this.average.x += this.spaceVertices[i].x;
      this.average.y += this.spaceVertices[i].y;
      this.average.z += this.spaceVertices[i].z;
    }
    this.average = descartesJS.scalarProduct3D(this.average, 1/l);
    this.average_proy = space.project(this.average);
    this.depth = descartesJS.norm3D(descartesJS.subtract3D(space.eye, this.average));

    // triangles and faces
    if (this.vertices.length > 2) {
      this.normal = getNormal(this.spaceVertices[0], this.spaceVertices[1], this.spaceVertices[2]);
    }

    // project and store the vertices in the projVert array
    for (i=0, l=this.vertices.length; i<l; i++) {
      this.newSpaceVert[i] = this.spaceVertices[i];
      this.projVert[i] = this.newProjVert[i] = space.project(this.spaceVertices[i]);
    }

    // // triangles and faces
    if (this.vertices.length > 2) {
      this.direction = getNormal(this.projVert[0], this.projVert[1], this.projVert[2]).z;
    }

    //////////////////////////////////////////////////
    this.minDistanceToEye =  Infinity;
    this.maxDistanceToEye = -Infinity;
    this.minx =  Infinity;
    this.maxx = -Infinity;
    this.miny =  Infinity;
    this.maxy = -Infinity;
    
    for (i=0, l=this.vertices.length; i<l; i++) {
      d = descartesJS.norm3D(descartesJS.subtract3D(this.spaceVertices[i], space.eye));
      this.minDistanceToEye = Math.min(this.minDistanceToEye, d);
      this.maxDistanceToEye = Math.max(this.maxDistanceToEye, d);
    }
    for (i=0, l=this.vertices.length; i<l; i++) {
      if (this.minx > this.projVert[i].x) {
        this.minx = this.projVert[i].x;
      }
      if (this.maxx < this.projVert[i].x) {
        this.maxx = this.projVert[i].x;
      }

      if (this.miny > this.projVert[i].y) {
        this.miny = this.projVert[i].y;
      }
      if (this.maxy < this.projVert[i].y) {
        this.maxy = this.projVert[i].y;
      }
    }
  }

  /**
   *
   */
  descartesJS.Primitive3D.prototype.removeDoubles = function() {
    if (this.type !== "edge") {
      tmpVertices = [];
      for (i=0, l=this.vertices.length; i<l; i++) {
        if ( (Math.abs(this.vertices[i].x - this.vertices[(i+1)%l].x) > epsilon) ||
             (Math.abs(this.vertices[i].y - this.vertices[(i+1)%l].y) > epsilon) ||
             (Math.abs(this.vertices[i].z - this.vertices[(i+1)%l].z) > epsilon) ||
             (Math.abs(this.vertices[i].w - this.vertices[(i+1)%l].w) > epsilon)

        ) {
          tmpVertices.push(this.vertices[i]);
        }
      }

      if (tmpVertices.length === 0) {
        tmpVertices.push(this.vertices[0]);
      }

      this.vertices = tmpVertices;
    }
  }

  /**
   *
   */
  function drawVertex(ctx) {
    ctx.textNode = null;

    if (parseInt(this.size) !== 0) {
      ctx.lineWidth = 1;
      ctx.fillStyle = this.backColor;
      ctx.strokeStyle = this.frontColor;

      ctx.beginPath();
      ctx.arc(this.projVert[0].x, this.projVert[0].y, this.size, 0, Math2PI);
      ctx.fill();
      ctx.stroke();
    }
  }

  /**
   *
   */
  function drawFace(ctx, space) {
    ctx.textNode = null;

    ctx.lineCap = lineCap;
    ctx.lineJoin = lineJoin;
    ctx.lineWidth = 0.4;

    // set the path to draw
    ctx.beginPath();
    ctx.moveTo(this.projVert[0].x, this.projVert[0].y);
    for (i=1, l=this.projVert.length; i<l; i++) {
      ctx.lineTo(this.projVert[i].x, this.projVert[i].y);
    }
    ctx.closePath();

    // color render
    if (this.model === "color") {
      ctx.fillStyle = (this.direction < 0) ? this.backColor : this.frontColor;
      ctx.strokeStyle = ctx.fillStyle;

      ctx.stroke();
      ctx.fill();
    }
    // light and metal render
    else if ( (this.model === "light") || (this.model === "metal") ) {
      ctx.fillStyle = space.computeColor( ((this.direction < 0) ? this.backColor : this.frontColor), this, (this.model === "metal"));
      ctx.strokeStyle = ctx.fillStyle;

      ctx.stroke();
      ctx.fill();
    }
    // wireframe render
    else if (this.model === "wire") {
      ctx.lineWidth = 1.25;
      ctx.strokeStyle = this.frontColor;
      ctx.stroke();
    }

    // draw the edges
    if ((this.edges) && (this.model !== "wire")) {
      ctx.lineWidth = 1;
      ctx.strokeStyle = this.edges;
      ctx.stroke();
    }
  }

  /**
   *
   */
  function drawPrimitiveText(ctx) {
    // awful hack to help the editor's pstricks exporter
    ctx.textNode = null;
    ctx.oldTextNode = "_a1b2c3_";
    // end awful hack

    tempParam = this.evaluator.getVariable(this.family);
    this.evaluator.setVariable(this.family, this.familyValue);
    this.fontSize = Math.max( 5, this.evaluator.eval(this.font_size) );
    this.font = this.font_style + " " + this.fontSize + "px " + this.font_family;

    this.drawText(ctx, this.text, this.projVert[0].x, this.projVert[0].y, this.frontColor, this.font, "left", "alphabetic", this.decimals, this.fixed, true);

    this.evaluator.setVariable(this.family, tempParam);
  }

  /**
   *
   */
  function drawEdge(ctx) {
    ctx.textNode = null;

    ctx.lineCap = lineCap;
    ctx.lineJoin = lineJoin;
    ctx.lineWidth = this.lineWidth;
    ctx.strokeStyle = this.frontColor;

    // set the path to draw
    ctx.beginPath();
    ctx.moveTo(this.projVert[0].x, this.projVert[0].y);
    ctx.lineTo(this.projVert[1].x, this.projVert[1].y);

    // set the line dash
    if (this.lineDash === "dot") {
      ctx.lineCap = "butt";
      ctx.setLineDash([ctx.lineWidth, ctx.lineWidth])
    }
    else if (this.lineDash === "dash") {
      ctx.lineCap = "butt";
      ctx.setLineDash([ctx.lineWidth*4, ctx.lineWidth*3])
    }
    else if (this.lineDash === "dash_dot") {
      ctx.lineCap = "butt";
      ctx.setLineDash([ctx.lineWidth*4, ctx.lineWidth*2, ctx.lineWidth, ctx.lineWidth*2])
    }
    else {
      ctx.setLineDash([]);
    }

    ctx.stroke();
  }

  /**
   * Draw the text of the graphic
   * @param {CanvasRenderingContext2D} ctx the context render to draw
   * @param {String} text the text to draw
   * @param {Number} x the x position of the text
   * @param {Number} y the y position of the text
   * @param {String} fill the fill color of the graphic
   * @param {String} font the font of the text
   * @param {String} align the alignment of the text
   * @param {String} baseline the baseline of the text
   * @param {Number} decimals the number of decimals of the text
   * @param {Boolean} fixed the number of significant digits of the number in the text
   * @param {Boolean} displaceY a flag to indicate if the text needs a displace in the y position
   */
  descartesJS.Primitive3D.prototype.drawText = function(ctx, text, x, y, fill, font, align, baseline, decimals, fixed, displaceY) {
    evaluator = this.evaluator;
    ctx.textNode = text;

    //
    var offset_dist = evaluator.eval(this.offset_dist);
    var offset_angle = -descartesJS.degToRad( evaluator.eval(this.offset_angle) );
    x += offset_dist*Math.cos(offset_angle);
    y += offset_dist*Math.sin(offset_angle);
    ctx.textNode.pos = { x:x, y:y };
    //
   
    if (text.hasContent) {
      // update the metrics, the true means that the text isn't draw
      text.draw(ctx, fill, x, y, true);
      
      pointDisplace = (this.fromPoint) ? text.textNodes.metrics.w/2 : 0;
      verticalDisplace = (this.fromPoint) ? text.textNodes.metrics.h/2 : 0;

      // text 
      text.draw(ctx, fill, x -pointDisplace, y -verticalDisplace);
    }
  }

  /**
   *
   */
  descartesJS.Primitive3D.prototype.splitFace = function(p) {
    if (this.intersects(p)) {
      var i1 = i2 = null;
      var ix1 = ix2 = 0;
      var oneIsInterior;
      var j1;
      var j2;
      var inter;
      var J;
      var j;
      var k;
      var P = this.vertices;
      var pP = p.vertices;

      for (var i=0, l=pP.length; i<l; i++) {
        inter = this.intersection( pP[i], pP[(i+1)%l] );

        if (inter !== null) {
          if (i1 === null) {
            i1 = inter;
            ix1 = i;
            if (pP.length === 2) {
              i2 = i1;
              break;
            }
          }
          else if (!descartesJS.equals3DEpsilon(inter, i1, epsilon)) {
            i2 = inter;
            ix2 = i;
            break;
          }
        }
      }

      if ((i1 !== null) && (i2 !== null)) {
        oneIsInterior = this.isInterior(i1) || this.isInterior(i2);
        j1 = null;
        j2 = null;

        if ((!oneIsInterior) && (pP.length >= 3)) {
          for (var j=0, k=P.length; j<k; j++) {
            inter = p.intersection( this.vertices[j], this.vertices[(j+1)%k] );
            if (inter !== null) {
              if (j1 === null) {
                j1 = inter;
              }
              else if (!descartesJS.equals3DEpsilon(inter, j1, epsilon)) {
                j2 = inter;
                break;
              }
            }
          }
        }

        if ( (oneIsInterior) || ((j1 !== null) && (j2 !== null) && (p.isInterior(j1)) && (p.isInterior(j2))) ) {
          var splitted = true;
          var P0 = pP;
          var V = null;
          var v = null;

          if (P0.length === 2) {
            if (descartesJS.equals3DEpsilon(i1, P0[0], epsilon) || descartesJS.equals3DEpsilon(i1, P0[1], epsilon)) {
              splitted = false;
            }
            else {
              V = [];
              V[0] = P0[0];
              V[1] = i1;
              v = [];
              v[0] = i1;
              v[1] = P0[1]
            }
          }
          else {
            V = [];
            v = [];
            J=0;
            j=0;
            k=0;

            for (var i=0; i<P0.length; i++) {
              if (i < ix1) {
                V[J++] = P0[i];
                // V[J++] = new descartesJS.Vector4D(P0[i].x, P0[i].y, P0[i].z, 1);
              }
              else if (i == ix1) {
                V[J++] = P0[i];
                V[J++] = i1;
                v[j++] = i1;
                // V[J++] = new descartesJS.Vector4D(P0[i].x, P0[i].y, P0[i].z, 1);
                // V[J++] = new descartesJS.Vector4D(i1.x, i1.y, i1.z, 1);
                // v[j++] = new descartesJS.Vector4D(i1.x, i1.y, i1.z, 1);
              }
              else if (i < ix2) {
                v[j++] = P0[i];
                // v[j++] = new descartesJS.Vector4D(P0[i].x, P0[i].y, P0[i].z, 1);
              }
              else if (i == ix2) {
                v[j++] = P0[i];
                v[j++] = i2;
                V[J++] = i2;
                // v[j++] = new descartesJS.Vector4D(P0[i].x, P0[i].y, P0[i].z, 1);
                // v[j++] = new descartesJS.Vector4D(i2.x, i2.y, i2.z, 1);
                // V[J++] = new descartesJS.Vector4D(i2.x, i2.y, i2.z, 1);
              }
              else {
                V[J++] = P0[i];
                // V[J++] = new descartesJS.Vector4D(P0[i].x, P0[i].y, P0[i].z, 1);
              }
            }
          }

          if (splitted) {
            var fa = [];
            fa[0] = new descartesJS.Primitive3D( { vertices: V,
                                                   type: "face",
                                                   frontColor: p.frontColor,
                                                   backColor: p.backColor,
                                                   edges: p.edges,
                                                   model: p.model
                                                  },
                                                  this.space );
            fa[0].removeDoubles()
            fa[0].normal = p.normal;

            fa[1] = new descartesJS.Primitive3D( { vertices: v,
                                                   type: "face",
                                                   frontColor: p.frontColor,
                                                   backColor: p.backColor,
                                                   edges: p.edges,
                                                   model: p.model
                                                  },
                                                  this.space );
            fa[1].removeDoubles()
            fa[1].normal = p.normal;


            if (fa[0].vertices.length > 2) {
              if (fa[1].vertices.length > 2) {
                return fa;
              }
              else {
                return [fa[0]];
              }
            }
            else {
              if (fa[1].vertices.length > 2) {
                return [fa[1]];
              }
              else {
                return [p];
              }
            }

            // return fa;
          }
        }
      }
    }

    return [p];
  }

  /**
   * check if two faces has an intersection
   */
  descartesJS.Primitive3D.prototype.intersects = function(p) {
    return this.intersectsPlane(p) && p.intersectsPlane(this);
  }

  /**
   * check if two planes intersects
   */
  descartesJS.Primitive3D.prototype.intersectsPlane = function(p) {
    var di;
    var d;
    var d0;
    var P = this.vertices;
    var pP = p.vertices;

    if (P.length > 0) {
      d = descartesJS.dotProduct3D(pP[0], p.normal);
      d0 = descartesJS.dotProduct3D(P[0], p.normal);

      if (Math.abs(d-d0) < epsilon) {
        return true;
      }
      for (var i=1, l=P.length; i<l; i++) {
        di = descartesJS.dotProduct3D(P[i], p.normal);

        if ( (Math.abs(d-di) < epsilon) || (di>d && d0<d) || (di<d && d0>d) ) {
          return true;
        }
      }
    }
    return false;
  } 

  /**
   *
   */
  descartesJS.Primitive3D.prototype.intersection = function(p1, p2) {
    var P = this.vertices;

    if (P.length > 0) {
      var p12 = descartesJS.subtract3D(p2, p1);
      var den = descartesJS.dotProduct3D(p12, this.normal);
      if (den !== 0) {
        var t = descartesJS.dotProduct3D( descartesJS.subtract3D(P[0], p1), this.normal ) / den;

        if ((-epsilon < t) && (t < 1+epsilon)) {
          return descartesJS.add3D(p1, descartesJS.scalarProduct3D(p12, t));
        }
      }
    }

    return null;
  }

  /**
   *
   */
  descartesJS.Primitive3D.prototype.isInterior = function(r) {
    var P = this.vertices;

    if (P.length > 0) {
      var D = 0;
      var u = descartesJS.subtract3D(P[0], r);

      for (var i=0, l=P.length; i<l; i++) {
        var v = descartesJS.subtract3D(P[(i+1)%l], r);
        var D1 = descartesJS.dotProduct3D( descartesJS.crossProduct3D(u, v), this.normal );

        if (Math.abs(D1) < epsilon) {
          if (descartesJS.dotProduct3D(u, v) < 0) {
            return true;
          }
        }
        else {
          if (((D < 0) && (D1 > 0)) || ((D > 0) && (D1 < 0))) {
            return false;
          }
          u = v;
          D = D1;
        }
      }
    }

    return true;
  }

  /**
   *
   */
  function getNormal(u1, u2, u3) {
    return descartesJS.normalize3D( 
      descartesJS.crossProduct3D(
        descartesJS.subtract3D(u1, u2), 
        descartesJS.subtract3D(u1, u3)
      ) 
    );
  }

//********************************************************************************************************************

  var v;
  var p;
  var ray;
  var state;
  var k;
  
  /**
   *
   */
  descartesJS.Primitive3D.prototype.inFrontOf = function(V, F, epsilon) {
    if (this.minDistanceToEye >= F.maxDistanceToEye || this.maxx <= F.minx || this.minx >= F.maxx || this.maxy <= F.miny || this.miny >= F.maxy) {
      return false;
    }

    for (state=0; state<3; state++) {
      v = null;

      if (state === 0) {
        v = this.intersections(F);
      }
      else if (state === 1) {
        v = F.verticesContainedIn(this);
      }
      else {
        v = this.verticesContainedIn(F);
      }
// console.log("state=", state, "v=", v)
// return;
      if ((v != null) && (v.length > 0)) {
// console.log("--------", state, "--------")
        for (k=0; k<v.length; k++) {
          V.push(v[k]);
        }

        for (i=0, l=v.length; i<l; i++) {
          p = v[i];
          ray = this.space.rayFromEye(p.x, p.y);
          
          try {
            t = this.distanceToEyeAlong(ray) - F.distanceToEyeAlong(ray);

// console.log(p.x, ",", p.y, v[i], "t=", t)
            
            if (t <= -epsilon) {
              return true;
            }
            else if (t >= epsilon) {
              return false;
            }
          }
          catch(e) {
            // console.log("Error: inFrontOf");
            // return false;
          }
        }
      }
    }
    return false;
  }

  /**
   *
   */
  descartesJS.Primitive3D.prototype.intersections = function(F) {
    var V = [];
    var pi;
    var qi;
    var pj;
    var qj;
    var ip;
    var newIP = new descartesJS.R2();

    // var P = this.spaceVertices;
    // var FP = F.spaceVertices;
    // var pr = this.projVert;
    // var Fpr = F.projVert;

    var P = this.newSpaceVert;
    var FP = F.newSpaceVert;
    var pr = this.newProjVert;
    var Fpr = F.newProjVert;


    for (var i=0, l=P.length; i<l; i++) {
      pi = P[i];
      qi = P[(i+1)%l];
      for (var j=0, Fl=FP.length; j<Fl; j++) {
        pj = FP[j];
        qj = FP[(j+1)%Fl];

        if ( (pi!=pj) && (pi!=qj)  && (qi!=pj) && (qi!=qj) ) {
          ip = newIP.intersection(pr[i], pr[(i+1)%l], Fpr[j], Fpr[(j+1)%Fl]);
          if (ip != null) {
            V.push(ip);
          }
        }
      }
    }

    return V;
  }

  /**
   *
   */
  descartesJS.Primitive3D.prototype.distanceToEyeAlong = function(ray) {
    var den = descartesJS.dotProduct3D(this.normal, ray);

    if (Math.abs(den) > 0.000001) {
      var normalToEye = descartesJS.dotProduct3D( descartesJS.subtract3D(this.average, this.space.eye), this.normal );
      return normalToEye/den;
    }
    throw new Exception("Face is invisible");
  }

  /**
   *
   */
  descartesJS.Primitive3D.prototype.verticesContainedIn = function(F) {
    var V = [];
    // var P = this.spaceVertices;
    // var pr = this.projVert;

    var P = this.newSpaceVert;
    var pr = this.newProjVert;

    for (var i=0, l=P.length; i<l; i++) { 
      if (!F.isVertex(P[i]) && F.appearsToContain(pr[i])) {
        V.push(pr[i]);
      }
    }
    return V;
  }

  /**
   *
   */
  descartesJS.Primitive3D.prototype.appearsToContain = function(p) {
    var D = 0;
    var D1;
    // var P = this.spaceVertices;
    // var pr = this.projVert;
    
    var P = this.newSpaceVert;
    var pr = this.newProjVert;

    for (var i=0, l=P.length; i<l; i++) {
      D1 = ((pr[i].x-p.x)*(pr[(i+1)%l].y-p.y))-((pr[(i+1)%l].x-p.x)*(pr[i].y-p.y));

      if (D != 0) {
        if (Math.abs(D1)<epsilon) {
          if (Math.abs(pr[i].x-pr[(i+1)%l].x)>epsilon) {
            return (Math.min(pr[i].x,pr[(i+1)%l].x)<=p.x+epsilon && p.x<=Math.max(pr[i].x,pr[(i+1)%l].x)+epsilon);
          } else if (Math.abs(pr[i].y-pr[(i+1)%l].y)>epsilon) {
            return (Math.min(pr[i].y,pr[(i+1)%l].y)<=p.y+epsilon && p.y<=Math.max(pr[i].y,pr[(i+1)%l].y)+epsilon);
          }
        }
        else if ( (D>0 && D1<0) || (D<0 && D1>0) ) {
          return false;
        }
      }
      D=D1;
    }
    return true;
  }

  /**
   *
   */
  descartesJS.Primitive3D.prototype.isVertex = function(p) {
    // var P = this.spaceVertices;
    var P = this.newSpaceVert;

    for (var i=0, l=P.length; i<l; i++) {
      if (descartesJS.equals3DEpsilon(p, P[i], epsilon)) {
        return true;
      }
    }
    return false;
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var translate = {x:0, y:0, z:0};

  var evaluator;
  var expr;
  var tempParam;
  var theText;
  var verticalDisplace;

  var tmpVertex;
  var lastIndexOfSpace;

  var degToRad = descartesJS.degToRad;

  /**
   * Descartes 3D graphics
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the graphic
   */
  descartesJS.Graphic3D = function(parent, values) {
    /**
     * Descartes application
     * type {DescartesApp}
     * @private
     */
    this.parent = parent;

    /**
     * object for parse and evaluate expressions
     * type {Evaluator}
     * @private
     */
    this.evaluator = parent.evaluator;

    var parser = parent.evaluator.parser;

    /**
     * identifier of the space that belongs to the graphic
     * type {String}
     * @private
     */
    this.spaceID = "E0";

    /**
     * the condition for determining whether the graph is drawn in the background
     * type {Boolean}
     * @private
     */
    this.background = false;

    /**
     * type of the graphic
     * type {String}
     * @private
     */
    this.type = "";

    /**
     * the primary color of the graphic
     * type {String}
     * @private
     */
    this.color = new descartesJS.Color("eeffaa");

    /**
     * the back face color of the graphic
     * type {Node}
     * @private
     */
    this.backcolor = new descartesJS.Color("6090a0");

    this.Nu = this.evaluator.parser.parse("7");
    this.Nv = this.evaluator.parser.parse("7");

    /**
     * the condition to draw the graphic
     * type {Node}
     * @private
     */
    this.drawif = parser.parse("1");

    /**
     * the condition for determine whether the graphic is in absolute coordinates
     * type {Boolean}
     * @private
     */
    this.abs_coord = false;

    /**
     * the condition and parameter name for family of the graphic
     * type {String}
     * @private
     */
    this.family = "";

    /**
     * the interval of the family
     * type {Node}
     * @private
     */
    this.family_interval = parser.parse("[0,1]");

    /**
     * the number of steps of the family
     * type {Node}
     * @private
     */
    this.family_steps = parser.parse("8");

    /**
     * info font
     * type {String}
     * @private
     */
    this.font = "Monospaced,PLAIN,12";

    /**
     * the condition for determining whether the text of the graph is fixed or not
     * type {Boolean}
     * @private
     */
    this.fixed = true;

    /**
     * text of the graphic
     * type {String}
     * @private
     */
    this.text = "";

    /**
     * the number of decimal of the text
     * type {Node}
     * @private
     */
    this.decimals = parser.parse("2");

    /**
     * the init rotation of the graphic
     * type {Node}
     * @private
     */
    this.inirot = "(0,0,0)";
    this.inirotEuler = false;

    /**
     * the init position of a graphic
     * type {Node}
     * @private
     */
    this.inipos = parser.parse("(0,0,0)");

    /**
     * the init rotation of the graphic
     * type {Node}
     * @private
     */
    this.endrot = "(0,0,0)";
    this.endrotEuler = false;

    /**
     * the init position of a graphic
     * type {Node}
     * @private
     */
    this.endpos = parser.parse("(0,0,0)");

    /**
     * the ilumination model
     * type {String}
     * @private
     */
    this.model = "color";

    // traverse the values to replace the defaults values of the object
    for (var propName in values) {
      // verify the own properties of the object
      if (values.hasOwnProperty(propName)) {
        this[propName] = values[propName];
      }
    }

    if ((this.expresion == undefined) && (this.type != "macro")) {
      this.expresion = parser.parse("(0,0)");
    }

    // get the space of the graphic
    this.space = this.getSpace();

    // get the canvas
    this.canvas = (this.background) ? this.space.backCanvas : this.space.canvas;
    this.ctx = this.canvas.getContext("2d");

    //
    // get a Descartes font
    this.font_str = this.font;
    this.font = descartesJS.convertFont(this.font);
    // get the font size
    this.fontSize = this.font.match(/([\d\.]+)px/);
    this.fontSize = (this.fontSize) ? parseFloat(this.fontSize[1]) : 10;

    this.font_style = descartesJS.getFontStyle(this.font_str.split(",")[1]);
    if ((typeof this.bold === "boolean") || (typeof this.italics === "boolean")) {
      if (this.bold && !this.italics) {
        this.font_style = "Bold ";
      }
      else if (!this.bold && this.italics) {
        this.font_style = "Italic ";
      }
      else if (this.bold && this.italics) {
        this.font_style = "Italic Bold ";
      }
      else if (!this.bold && !this.italics) {
        this.font_style = " ";
      }
    }
    if (!this.font_family) {
      this.font_family = this.font_str.split(",")[0];
    }
    this.font_family = descartesJS.getFontName(this.font_family);
    if (typeof this.font_size === "undefined") {
      this.font_size = parent.evaluator.parser.parse(this.fontSize.toString());
    }
    //
    
    // euler rotations
    if (this.inirot.match("Euler")) {
      this.inirot = this.inirot.replace("Euler", "");
      this.inirotEuler = true;
    }
    if (this.endrot.match("Euler")) {
      this.endrot = this.endrot.replace("Euler", "");
      this.endrotEuler = true;
    }

    this.inirot = parser.parse(this.inirot);
    this.endrot = parser.parse(this.endrot);

    // auxiliary matrices
    this.inirotM   = new descartesJS.Matrix4x4();
    this.inirotM_X = new descartesJS.Matrix4x4();
    this.inirotM_Y = new descartesJS.Matrix4x4();
    this.inirotM_Z = new descartesJS.Matrix4x4();
    this.iniposM   = new descartesJS.Matrix4x4();

    this.endrotM   = new descartesJS.Matrix4x4();
    this.endrotM_X = new descartesJS.Matrix4x4();
    this.endrotM_Y = new descartesJS.Matrix4x4();
    this.endrotM_Z = new descartesJS.Matrix4x4();
    this.endposM   = new descartesJS.Matrix4x4();
  }

  /**
   * Get the space to which the graphic belongs
   * return {Space} return the space to which the graphic belongs
   */
  descartesJS.Graphic3D.prototype.getSpace = function() {
    var spaces = this.parent.spaces;
    var space_i;

    // find in the spaces
    for (var i=0, l=spaces.length; i<l; i++) {
      space_i = spaces[i];
      if (space_i.id == this.spaceID) {
        return space_i;
      }
    }

    // if do not find the identifier, return the first space
    return spaces[0];
  }

  /**
   * Get the family values of the graphic
   */
  descartesJS.Graphic3D.prototype.getFamilyValues = function() {
    evaluator = this.evaluator;
    expr = evaluator.eval(this.family_interval);
    this.familyInf = expr[0][0];
    this.familySup = expr[0][1];
    this.fSteps = Math.round(evaluator.eval(this.family_steps));
    this.family_sep = (this.fSteps > 0) ? (this.familySup - this.familyInf)/this.fSteps : 0;
  }

  /**
   *
   */
  descartesJS.Graphic3D.prototype.buildFamilyPrimitives = function() {
    evaluator = this.evaluator;

    // update the family values
    this.getFamilyValues();

    // save the last value of the family parameter
    tempParam = evaluator.getVariable(this.family);

    if (this.fSteps >= 0) {
      // build the primitives of the family
      for(var i=0, l=this.fSteps; i<=l; i++) {
        // update the value of the family parameter
        evaluator.setVariable(this.family, this.familyInf+(i*this.family_sep));

        this.familyValue = this.familyInf+(i*this.family_sep);

        // if the condition to draw is true then update and draw the graphic
        if ( evaluator.eval(this.drawif) ) {
          this.buildPrimitives();
        }
      }
    }

    evaluator.setVariable(this.family, tempParam);
  }

  /**
   * Update the 3D graphic
   */
  descartesJS.Graphic3D.prototype.update = function() {
    this.primitives = [];

    if (this.evaluator.eval(this.drawif)) {
      // build the primitives of a single object
      if (!this.family) {
        this.buildPrimitives();
      }
    }

    // build the primitives of the family
    if (this.family) {
      this.buildFamilyPrimitives();
    }
  }

  /**
   *
   */
  descartesJS.Graphic3D.prototype.updateMVMatrix = function() {
    tmpExpr = this.evaluator.eval(this.inirot);
    if (this.inirotEuler) {
      this.inirotM = this.inirotM.setIdentity();
      this.inirotM = this.inirotM.rotateZ(degToRad(tmpExpr[0][0])); //Z
      this.inirotM = this.inirotM.rotateX(degToRad(tmpExpr[0][1])); //X
      this.inirotM = this.inirotM.rotateZ(degToRad(tmpExpr[0][2])); //Z
    }
    else {
      this.inirotM_X = this.inirotM_X.setIdentity().rotateX(degToRad(tmpExpr[0][0])); //X
      this.inirotM_Y = this.inirotM_Y.setIdentity().rotateY(degToRad(tmpExpr[0][1])); //Y
      this.inirotM_Z = this.inirotM_Z.setIdentity().rotateZ(degToRad(tmpExpr[0][2])); //Z
    }

    tmpExpr = this.evaluator.eval(this.inipos);
    translate = { x: tmpExpr[0][0], y: tmpExpr[0][1], z: tmpExpr[0][2] };
    this.iniposM = this.iniposM.setIdentity().translate(translate);

    tmpExpr = this.evaluator.eval(this.endrot);
    if (this.endrotEuler) {
      this.endrotM = this.endrotM.setIdentity();
      this.endrotM = this.endrotM.rotateZ(degToRad(tmpExpr[0][0])); //Z
      this.endrotM = this.endrotM.rotateX(degToRad(tmpExpr[0][1])); //X
      this.endrotM = this.endrotM.rotateZ(degToRad(tmpExpr[0][2])); //Z
    }
    else {
      this.endrotM_X = this.endrotM_X.setIdentity().rotateX(degToRad(tmpExpr[0][0])); //X
      this.endrotM_Y = this.endrotM_Y.setIdentity().rotateY(degToRad(tmpExpr[0][1])); //Y
      this.endrotM_Z = this.endrotM_Z.setIdentity().rotateZ(degToRad(tmpExpr[0][2])); //Z
    }

    tmpExpr = this.evaluator.eval(this.endpos);
    translate = { x: tmpExpr[0][0], y: tmpExpr[0][1], z: tmpExpr[0][2] };
    this.endposM = this.endposM.setIdentity().translate(translate);
  }

  /**
   *
   */
   descartesJS.Graphic3D.prototype.transformVertex = function(v) {
    if (this.inirotEuler) {
      tmpVertex = this.inirotM.multiplyVector4(v);
    }
    else {
      tmpVertex = this.inirotM_X.multiplyVector4(v);
      tmpVertex = this.inirotM_Y.multiplyVector4(tmpVertex);
      tmpVertex = this.inirotM_Z.multiplyVector4(tmpVertex);
    }

    tmpVertex = this.iniposM.multiplyVector4(tmpVertex);

    if (this.endrotEuler) {
      tmpVertex = this.endrotM.multiplyVector4(tmpVertex);
    }
    else {
      tmpVertex = this.endrotM_X.multiplyVector4(tmpVertex);
      tmpVertex = this.endrotM_Y.multiplyVector4(tmpVertex);
      tmpVertex = this.endrotM_Z.multiplyVector4(tmpVertex);
    }

    tmpVertex = this.endposM.multiplyVector4(tmpVertex);

    // make the rotation of the macro
    if (this.macroChildren) {
      tmpVertex = this.applyMacroTransform(tmpVertex);
    }

    //
    tmpVertex.adjustDec();
    //


    return tmpVertex;
  }

  /**
   *
   */
   descartesJS.Graphic3D.prototype.applyMacroTransform = function(v) {
    if (this.macro_inirotEuler) {
      tmpVertex = this.macro_inirotM.multiplyVector4(v);
    }
    else {
      tmpVertex = this.macro_inirotM_X.multiplyVector4(v);
      tmpVertex = this.macro_inirotM_Y.multiplyVector4(tmpVertex);
      tmpVertex = this.macro_inirotM_Z.multiplyVector4(tmpVertex);
    }

    tmpVertex = this.macro_iniposM.multiplyVector4(tmpVertex);

    if (this.macro_endrotEuler) {
      tmpVertex = this.macro_endrotM.multiplyVector4(tmpVertex);
    }
    else {
      tmpVertex = this.macro_endrotM_X.multiplyVector4(tmpVertex);
      tmpVertex = this.macro_endrotM_Y.multiplyVector4(tmpVertex);
      tmpVertex = this.macro_endrotM_Z.multiplyVector4(tmpVertex);
    }

    tmpVertex = this.macro_endposM.multiplyVector4(tmpVertex);

    return tmpVertex;
   }

  /**
   * Parse expression for curve graphic
   */
  descartesJS.Graphic3D.prototype.parseExpression = function() {
    var expr = this.expresion.split(";");
    var newExpr = [];

    for (var i=0, l=expr.length; i<l; i++) {
      if (expr[i].trim() !== "") {
        newExpr = newExpr.concat(splitExpr(expr[i]));
      }
    }

    for (var i=0, l=newExpr.length; i<l; i++) {
      newExpr[i] = this.evaluator.parser.parse( newExpr[i], true );
    }

    return newExpr;
  }

  /**
   * Split a line if has spaces
   */
  function splitExpr(expr) {
    var tmpEmprArr = [];
    var statusIgnore = 0;
    var statusEqual = 1;
    var statusId = 2;
    var status = statusIgnore;
    var charAt;
    var lastIndex = expr.length;

    for (var i=expr.length-1; i>-1; i--) {
      charAt = expr.charAt(i)

      if (status == statusIgnore) {
        if (charAt != "=") {
          continue;
        }
        else {
          status = statusEqual;
          continue;
        }
      }

      if (status == statusEqual) {
        if (charAt == " ") {
          continue;
        }
        else if ( (charAt === "<") || (charAt === ">") ) {
          status = statusIgnore;
          continue;
        }
        else {
          status = statusId;
          continue;
        }
      }

      if (status == statusId) {
        if (charAt == " ") {
          tmpEmprArr.unshift(expr.substring(i+1, lastIndex));
          lastIndex = i;
          status = statusIgnore;
          continue;
        }
      }
    }

    tmpEmprArr.unshift(expr.substring(0, lastIndex));

    return tmpEmprArr;
  }

  var tmpPrimitives;

  /**
   *
   */
  descartesJS.Graphic3D.prototype.splitFace = function(g) {
    for (var i=0, l=this.primitives.length; i<l; i++) {
      tmpPrimitives = [];

      // if the primitive is a face then try to cut the other primitives faces
      if (this.primitives[i].type === "face") {
        for (var j=0, k=g.primitives.length; j<k; j++) {

          // the primitives of g are splited and added to an array
          if (g.primitives[j].type === "face") {
            tmpPrimitives = tmpPrimitives.concat( this.primitives[i].splitFace(g.primitives[j]) );
          }
          // if the primitive is not a face, then do not split it
          else {
            tmpPrimitives.push( g.primitives[j] );
          }
        }

        g.primitives = tmpPrimitives;
      }
    }
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var PI2 = Math.PI*2;
  var evaluator;
  var expr;
  var exprX;
  var exprY;
  var exprZ;
  
  /**
   * A Descartes 3D point
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the point
   */
  descartesJS.Point3D = function(parent, values) {
    // call the parent constructor
    descartesJS.Graphic3D.call(this, parent, values);
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic3D
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Point3D, descartesJS.Graphic3D);

  /**
   * Build the primitives corresponding to the point
   */
  descartesJS.Point3D.prototype.buildPrimitives = function() {
    evaluator = this.evaluator;

    // do not apply the rotations in the model view matrix transformation
    this.updateMVMatrix();

    expr = evaluator.eval(this.expresion);
    exprX = expr[0][0];
    exprY = expr[0][1];
    exprZ = expr[0][2];

    this.primitives.push( new descartesJS.Primitive3D( { 
      vertices: [this.transformVertex( new descartesJS.Vector4D(exprX, exprY, exprZ, 1) )],
      type: "vertex",
      backColor: this.backcolor.getColor(), 
      frontColor: this.color.getColor(), 
      size: evaluator.eval(this.width)
    } ) );

    // add a text primitive only if the text has content
    if (this.text !== "") {
      this.offset_dist = this.offset_dist || evaluator.parser.parse("10");
      this.offset_angle = this.offset_angle || evaluator.parser.parse("270");

      this.primitives.push( new descartesJS.Primitive3D( { 
        vertices: [this.transformVertex( new descartesJS.Vector4D(exprX, exprY, exprZ, 1) )],
        type: "text",
        fromPoint: true,
        frontColor: this.color.getColor(), 
        font_size: this.font_size,
        font_style: this.font_style,
        font_family: this.font_family,
        decimals: evaluator.eval(this.decimals),
        fixed: this.fixed,
        evaluator: evaluator,
        text: new descartesJS.TextObject(this, this.text),
        family: this.family,
        familyValue: this.familyValue,
        offset_dist: this.offset_dist,
        offset_angle: this.offset_angle
      },
      this.space ));
    }
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var PI2 = Math.PI*2;

  var v1_x;
  var v1_y;
  var v1_z;
  var v2_x;
  var v2_y;
  var v2_z;

  var tempParamU;

  /**
   * A Descartes 3D segment
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the point
   */
  descartesJS.Segment3D = function(parent, values) {
    this.width = parent.evaluator.parser.parse("1");

    // call the parent constructor
    descartesJS.Graphic3D.call(this, parent, values);
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic3D
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Segment3D, descartesJS.Graphic3D);

  /**
   * Build the primitives corresponding to the segment
   */
  descartesJS.Segment3D.prototype.buildPrimitives = function() {
    evaluator = this.evaluator;

    // do not apply the rotations in the model view matrix transformation
    this.updateMVMatrix();

    tempParamU = evaluator.getVariable("u");
    evaluator.setVariable("u", this.Nu);

    expr = evaluator.eval(this.expresion);
    v1_x = expr[0][0];
    v1_y = expr[0][1];
    v1_z = expr[0][2];

    v2_x = expr[1][0];
    v2_y = expr[1][1];
    v2_z = expr[1][2];

    this.primitives.push( new descartesJS.Primitive3D( { vertices: [ this.transformVertex( new descartesJS.Vector4D(v1_x, v1_y, v1_z, 1) ),
                                                                     this.transformVertex( new descartesJS.Vector4D(v2_x, v2_y, v2_z, 1) )
                                                       ],
                                                         type: "edge",
                                                         lineDash: this.lineDash,
                                                         frontColor: this.color.getColor(), 
                                                         lineWidth: evaluator.eval(this.width)
                                                       },
                                                       this.space ));

    evaluator.setVariable("u", tempParamU);
  }
  
  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var evaluator;
  var tempParamU;
  var tempParamV;
  var tempParamX;
  var tempParamY;
  var tempParamZ;
  var Nu;
  var Nv;
  var vertices;
  var v;

  var ui;
  var vi;
  var ii;
  var ll;

  /**
   * A Descartes 3D surface
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the surface
   */
  descartesJS.Surface3D = function(parent, values) {
    /**
     * the parameter name for a curve
     * type {String}
     * @private
     */
    this.parameter = "t";

    /**
     * the interval of the curve parameter
     * type {Node}
     * @private
     */
    this.parameter_interval = parent.evaluator.parser.parse("[0,1]");

    /**
     * the number of steps of the curve parameter
     * type {Node}
     * @private
     */
    this.parameter_steps = parent.evaluator.parser.parse("8");

    // call the parent constructor
    descartesJS.Graphic3D.call(this, parent, values);

    this.expresion = this.parseExpression();
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic3D
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Surface3D, descartesJS.Graphic3D);
  
  /**
   * Build the primitives corresponding to the surface
   */
  descartesJS.Surface3D.prototype.buildPrimitives = function() {
    evaluator = this.evaluator;

    this.updateMVMatrix();

    // store the u and v parameter values
    tempParamX = evaluator.getVariable("x");
    tempParamY = evaluator.getVariable("y");
    tempParamZ = evaluator.getVariable("z");
    tempParamU = evaluator.getVariable("u");
    tempParamV = evaluator.getVariable("v");

    evaluator.setVariable("u", 0);
    evaluator.setVariable("v", 0);
    Nu = parseInt(evaluator.eval(this.Nu));
    Nv = parseInt(evaluator.eval(this.Nv));

    // array to store the computed vertices 
    vertices = [];

    for (ui=0; ui<=Nu; ui++) {
      evaluator.setVariable("u", ui/Nu);

      for (vi=0; vi<=Nv; vi++) {
        evaluator.setVariable("v", vi/Nv);

        // eval all the subterms in the expression
        for (ii=0, ll=this.expresion.length; ii<ll; ii++) {
          evaluator.eval(this.expresion[ii]);
        }

        vertices.push( this.transformVertex(new descartesJS.Vector4D(evaluator.getVariable("x"), evaluator.getVariable("y"), evaluator.getVariable("z"), 1)) );
      }
    }

    var tmpFrontColor = this.color.getColor();
    var tmpBackColor = this.backcolor.getColor();
    var tmpEdgeColor = (this.edges) ? this.edges.getColor() : "";

    for (ui=0; ui<Nu; ui++) {
      for (vi=0; vi<Nv; vi++) {
        v = [];
        v.push(vertices[vi + ui*Nv + ui]);        // 0
        v.push(vertices[vi+1 + ui*Nv + ui]);      // 1
        v.push(vertices[vi+2 + (ui+1)*Nv  + ui]); // 2
        v.push(vertices[vi+1 + (ui+1)*Nv  + ui]); // 3

        this.primitives.push( new descartesJS.Primitive3D( { vertices: v,
                                                             type: "face",
                                                             frontColor: tmpFrontColor,
                                                             backColor: tmpBackColor,
                                                             edges: tmpEdgeColor,
                                                             model: this.model
                                                           },
                                                          this.space ));

      }
    }

    evaluator.setVariable("x", tempParamX);
    evaluator.setVariable("y", tempParamY);
    evaluator.setVariable("z", tempParamZ);
    evaluator.setVariable("u", tempParamU);
    evaluator.setVariable("v", tempParamV);
  }  

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var v1_x;
  var v1_y;
  var v1_z;
  var v2_x;
  var v2_y;
  var v2_z;  

  /**
   * A Descartes 3D polyline
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the polygon
   */
  descartesJS.Polygon3D = function(parent, values) {

    this.width = parent.evaluator.parser.parse("1");

    // call the parent constructor
    descartesJS.Graphic3D.call(this, parent, values);
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic3D
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Polygon3D, descartesJS.Graphic3D);
  
  /**
   * Build the primitives corresponding to the polygon
   */
  descartesJS.Polygon3D.prototype.buildPrimitives = function() {
    evaluator = this.evaluator;

    // do not apply the rotations in the model view matrix transformation
    this.updateMVMatrix();

    expr = evaluator.eval(this.expresion);

    var tmpFrontColor = this.color.getColor();

    for (var i=0, l=expr.length-1; i<l; i++) {
      v1_x = expr[i][0];
      v1_y = expr[i][1];
      v1_z = expr[i][2];

      v2_x = expr[i+1][0];
      v2_y = expr[i+1][1];
      v2_z = expr[i+1][2];

      this.primitives.push( new descartesJS.Primitive3D( { vertices: [ this.transformVertex( new descartesJS.Vector4D(v1_x, v1_y, v1_z, 1) ),
                                                                       this.transformVertex( new descartesJS.Vector4D(v2_x, v2_y, v2_z, 1) )
                                                                     ],
                                                           type: "edge",
                                                           frontColor: tmpFrontColor, 
                                                           lineWidth: evaluator.eval(this.width)
                                                         },
                            this.space ));

    }
  }
  
  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var vertices;
  var Nu;
  var tempParamU;
  var tempParamX;
  var tempParamY;
  var tempParamZ;  

  /**
   * A Descartes 3D curve
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the curve
   */
  descartesJS.Curve3D = function(parent, values) {
    this.width = parent.evaluator.parser.parse("1");

    // se llama al constructor del padre
    descartesJS.Graphic3D.call(this, parent, values);
    
    this.expresion = this.parseExpression();
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic3D
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Curve3D, descartesJS.Graphic3D);
  
  /**
   * Build the primitives corresponding to the curve
   */
  descartesJS.Curve3D.prototype.buildPrimitives = function() {
    evaluator = this.evaluator;

    this.updateMVMatrix();

    // store the u and v parameter values
    tempParamX = evaluator.getVariable("x");
    tempParamY = evaluator.getVariable("y");
    tempParamZ = evaluator.getVariable("z");
    tempParamU = evaluator.getVariable("u");

    evaluator.setVariable("u", 0);
    Nu = evaluator.eval(this.Nu);

    vertices = [];

    for (var ui=0; ui<=Nu; ui++) {
      evaluator.setVariable("u", ui/Nu);

      // eval all the subterms in the expression
      for (var ii=0, ll=this.expresion.length; ii<ll; ii++) {
        evaluator.eval(this.expresion[ii]);
      }

      vertices.push( this.transformVertex(new descartesJS.Vector4D(evaluator.getVariable("x"), evaluator.getVariable("y"), evaluator.getVariable("z"), 1)) );
    }

    for (var i=0, l=vertices.length-1; i<l; i++) {
      // this.primitives.push( new descartesJS.Primitive3D( { 
      //   vertices: [ vertices[i], vertices[i+1] ],
      //   type: "edge",
      //   frontColor: this.color.getColor(), 
      //   lineWidth: evaluator.eval(this.width)
      // },
      // this.space ));

      this.primitives.push( new descartesJS.Primitive3D( { 
        vertices: [ vertices[i], vertices[i+1] ],
        type: "edge",
        frontColor: this.color.getColor(), 
        lineWidth: evaluator.eval(this.width)
      },
      this.space ));
    }

    if ((this.fill) && (vertices.length > 2)) {
      this.primitives.push( new descartesJS.Primitive3D( { 
        vertices: vertices,
        type: "face",
        frontColor: this.fill.getColor(), 
        backColor: this.fill.getColor(), 
        edges: "", 
        model: this.model
      },
      this.space ));
    }

    evaluator.setVariable("x", tempParamX);
    evaluator.setVariable("y", tempParamZ);
    evaluator.setVariable("z", tempParamY);
    evaluator.setVariable("u", tempParamU);
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var v1_x;
  var v1_y;
  var v1_z;
  var v2_x;
  var v2_y;
  var v2_z;
  var v3_x;
  var v3_y;
  var v3_z;

  /**
   * A Descartes 3D triangle
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the triangle
   */
  descartesJS.Triangle3D = function(parent, values) {
    // call the parent constructor
    descartesJS.Graphic3D.call(this, parent, values);
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic3D
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Triangle3D, descartesJS.Graphic3D);

  /**
   * Build the primitives corresponding to the triangle
   */
  descartesJS.Triangle3D.prototype.buildPrimitives = function() {
    evaluator = this.evaluator;

    this.updateMVMatrix();

    expr = evaluator.eval(this.expresion);
    v1_x = expr[0][0];
    v1_y = expr[0][1];
    v1_z = expr[0][2];

    v2_x = expr[1][0];
    v2_y = expr[1][1];
    v2_z = expr[1][2];

    v3_x = expr[2][0];
    v3_y = expr[2][1];
    v3_z = expr[2][2];

    var tmpEdgeColor = (this.edges) ? this.edges.getColor() : "";

    this.primitives.push( new descartesJS.Primitive3D( { 
      vertices: [ this.transformVertex( new descartesJS.Vector4D(v1_x, v1_y, v1_z, 1) ),
                  this.transformVertex( new descartesJS.Vector4D(v3_x, v3_y, v3_z, 1) ),
                  this.transformVertex( new descartesJS.Vector4D(v2_x, v2_y, v2_z, 1) )
                ],
      type: "face",
      frontColor: this.color.getColor(),
      backColor: this.backcolor.getColor(),
      edges: tmpEdgeColor,
      model: this.model
    },
    this.space ));

  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var v1_x;
  var v1_y;
  var v1_z;
  var v2_x;
  var v2_y;
  var v2_z;
  var vertices;

  /**
   * A Descartes 3D face
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the triangle
   */
  descartesJS.Face3D = function(parent, values) {
    // call the parent constructor
    descartesJS.Graphic3D.call(this, parent, values);
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic3D
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Face3D, descartesJS.Graphic3D);
  
  /**
   * Build the primitives corresponding to the face
   */
  descartesJS.Face3D.prototype.buildPrimitives = function() {
    evaluator = this.evaluator;

    this.updateMVMatrix();

    expr = evaluator.eval(this.expresion);

    vertices = [];

    for (var i=expr.length-1; i>=0; i--) {
      vertices.push( this.transformVertex(new descartesJS.Vector4D(expr[i][0], expr[i][1], expr[i][2], 1)) );
    }

    var tmpEdgeColor = (this.edges) ? this.edges.getColor() : "";

    this.primitives.push( new descartesJS.Primitive3D( { 
      vertices: vertices,
      type: "face",
      frontColor: this.color.getColor(), 
      backColor: this.backcolor.getColor(), 
      edges: tmpEdgeColor, 
      model: this.model
    },
    this.space ));

  }
  
  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var Nu;
  var vertices;
  var w;
  var l;
  var theta;

  /**
   * A Descartes 3D regular polygon
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the triangle
   */
  descartesJS.Polireg3D = function(parent, values) {
    this.width = parent.evaluator.parser.parse("2");
    this.length = parent.evaluator.parser.parse("2");

    // call the parent constructor
    descartesJS.Graphic3D.call(this, parent, values);
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic3D
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Polireg3D, descartesJS.Graphic3D);
  
  /**
   * Build the primitives corresponding to the regular polygon
   */
  descartesJS.Polireg3D.prototype.buildPrimitives = function() {
    evaluator = this.evaluator;

    this.updateMVMatrix();

    Nu = evaluator.eval(this.Nu);

    vertices = [this.transformVertex( new descartesJS.Vector4D(0, 0, 0, 1) )];
    w = evaluator.eval(this.width)/2;
    l = evaluator.eval(this.length)/2;
    theta = (2*Math.PI) / Nu;

    for (var i=0; i<Nu; i++) {
      vertices.push ( this.transformVertex( new descartesJS.Vector4D(w*Math.cos(theta*i), l*Math.sin(theta*i), 0, 1) ) );
    }

    var tmpFrontColor = this.color.getColor();
    var tmpBackColor = this.backcolor.getColor();
    var tmpEdgeColor = (this.edges) ? this.edges.getColor() : "";

    for (var i=0; i<Nu; i++) {
      this.primitives.push( new descartesJS.Primitive3D( { vertices: [ vertices[0],
                                                                       (i+2 <= Nu) ? vertices[i+2] : vertices[1],
                                                                       vertices[i+1]
                                                                     ],
                                                           type: "face",
                                                           frontColor: tmpFrontColor,
                                                           backColor: tmpBackColor,
                                                           edges: tmpEdgeColor,
                                                           model: this.model
                                                         },
                            this.space ));
    }

  }
  
  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var evaluator;
  var expr;
  var exprX;
  var exprY;
  var exprZ;

  /**
   * A Descartes 3D text
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the triangle
   */
  descartesJS.Text3D = function(parent, values) {
    // call the parent constructor
    descartesJS.Graphic3D.call(this, parent, values);    
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic3D
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Text3D, descartesJS.Graphic3D);
  
  /**
   * Build the primitives corresponding to the point
   */
  descartesJS.Text3D.prototype.buildPrimitives = function() {
    evaluator = this.evaluator;

    expr = evaluator.eval(this.expresion);
    exprX = expr[0][0];
    exprY = expr[0][1];
    exprZ = 0;

    this.primitives.push( new descartesJS.Primitive3D( { 
      vertices: [new descartesJS.Vector4D(exprX, exprY, exprZ, 1)],
      type:"text",
      frontColor: this.color.getColor(),
      font_size: this.font_size,
      font_style: this.font_style,
      font_family: this.font_family,
      decimals: evaluator.eval(this.decimals),
      fixed: this.fixed,
      displace: 0,
      isText: true,
      evaluator: evaluator,
      text: new descartesJS.TextObject(this, this.text),
      family: this.family,
      familyValue: this.familyValue
    },
    this.space ));

  }
  
  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS, babel) {
  if (descartesJS.loadLib) { return descartesJS; }

  var regExpType = new String("-point-segment-polygon-curve-triangle-face-polireg-surface-text-cube-box-tetrahedron-octahedron-sphere-dodecahedron-icosahedron-ellipsoid-cone-cylinder-torus-mesh-macro-");
  var regExpSurface = new String("-x-y-z-u-v-w-");
  
  var regExpImage = /[\w\.\-//]*(\.png|\.jpg|\.gif|\.svg)/gi;
  var thisGraphics_i;
  var thisGraphicsNext;
  var macros_count = 0;

  /**
   * A Descartes macro
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the macro
   */
  descartesJS.Macro3D = function(parent, values) {
    /**
     * the expression for determine the position of the graphic
     * type {Node}
     * @private
     */
    this.expresion = undefined;

    /**
     * the init rotation of the graphic
     * type {Node}
     * @private
     */
    this.inirot = "(0,0,0)";
    this.inirotEuler = false;
    
    /**
     * the init position of a graphic
     * type {Node}
     * @private
     */
    this.inipos = parent.evaluator.parser.parse("(0,0,0)");

    /**
     * the init rotation of the graphic
     * type {Node}
     * @private
     */
    this.endrot = "(0,0,0)";
    this.endrotEuler = false;

    /**
     * the init position of a graphic
     * type {Node}
     * @private
     */
    this.endpos = parent.evaluator.parser.parse("(0,0,0)");

    /**
     * 
     */
    this.name = "_descartes_empty_name_" + (macros_count++)

    // call the parent constructor
    descartesJS.Graphic.call(this, parent, values);

    // traverse the values to replace the defaults values of the object
    for (var propName in values) {
      // verify the own properties of the object
      if (values.hasOwnProperty(propName)) {
        this[propName] = values[propName];
      }
    }

    // euler rotations
    if (this.inirot.match("Euler")) {
      this.inirot = this.inirot.replace("Euler", "");
      this.inirotEuler = true;
    }
    if (this.endrot.match("Euler")) {
      this.endrot = this.endrot.replace("Euler", "");
      this.endrotEuler = true;
    }

    this.inirot = this.evaluator.parser.parse(this.inirot);
    this.endrot = this.evaluator.parser.parse(this.endrot);

    // auxiliary matrices
    this.inirotM   = new descartesJS.Matrix4x4();
    this.inirotM_X = new descartesJS.Matrix4x4();
    this.inirotM_Y = new descartesJS.Matrix4x4();
    this.inirotM_Z = new descartesJS.Matrix4x4();
    this.iniposM   = new descartesJS.Matrix4x4();

    this.endrotM   = new descartesJS.Matrix4x4();
    this.endrotM_X = new descartesJS.Matrix4x4();
    this.endrotM_Y = new descartesJS.Matrix4x4();
    this.endrotM_Z = new descartesJS.Matrix4x4();
    this.endposM   = new descartesJS.Matrix4x4();

    this.graphics = [];
    
    var lessonParser = parent.lessonParser;
    var tokenizer = new descartesJS.Tokenizer();
    
    // if the expression is empty
    if (this.expresion == undefined) {
      return;
    }

    // if the macro name was not specified as a string, then adds single quotes to turn it into string
    if ( !(this.expresion.charAt(0) === "'")) {
      this.expresion = "'" + this.expresion + "'";
    }
    this.expresion = this.evaluator.parser.parse(this.expresion);

    var filename = this.evaluator.eval(this.expresion);
    var response;

    if (filename) {
      // the macro is embeded in the webpage
      var macroElement = document.getElementById(filename);

      if ((macroElement) && (macroElement.type == "descartes/macro")) {
        response = macroElement.text;
      }
      // the macro is in an external file
      else {
        response = descartesJS.openExternalFile(filename);
        // // verify the content is a Descartes macro
        // if ( (response) && (!response.match(/tipo_de_macro/g)) ) {
        //   response = null;
        // }
      }
    }

    var indexOfEqual;
    var tmpIniti;
    var tmpResponse;

    // if it was posible to read the macro
    if (response) {
      tmpResponse = ( response.replace(/&aacute;/g, "\u00e1").replace(/&eacute;/g, "\u00e9").replace(/&iacute;/g, "\u00ed").replace(/&oacute;/g, "\u00f3").replace(/&uacute;/g, "\u00fa").replace(/&Aacute;/g, "\u00c1").replace(/&Eacute;/g, "\u00c9").replace(/&Iacute;/g, "\u00cd").replace(/&Oacute;/g, "\u00d3").replace(/&Uacute;/g, "\u00da").replace(/&ntilde;/g, "\u00f1").replace(/&Ntilde;/g, "\u00d1").replace(/\&gt;/g, ">").replace(/\&lt;/g, "<").replace(/\&amp;/g, "&").replace(/\r/g, "") ).split("\n");

      // maintain only the lines that have information for the macro
      response = [];

      for(var i=0, l=tmpResponse.length; i<l; i++) {
        indexOfEqual = tmpResponse[i].indexOf("=");

        if(indexOfEqual !== -1) {
          var tmpSplitLine = lessonParser.split(tmpResponse[i]);
          for (var iT=0,lT=tmpSplitLine.length; iT<lT; iT++) {
            if ((tmpSplitLine[iT]) && (tmpSplitLine.length >1)) {
              if ((babel[tmpSplitLine[iT][0]] === "id") || (babel[tmpSplitLine[iT][0]] === "type")) {
                response.push(tmpSplitLine);
                break;
              }
            }
          }
        }
      }

      var respText;
      var babelResp;
      var dotIndex;
      var tmpTokens;
      var tmpTokensRespText;
      var isID;
      var isSurface;

      // add the macro name as a prefix, only in some expressions
      for (var i=0, l=response.length; i<l; i++) {
        respText = response[i] || [];

        isID = ((respText) && (respText[0]) && (respText[0][0] === "id"));
        isSurface = false;

        for (var j=0, k=respText.length; j<k; j++) {
          // if the parameters have a dot
          dotIndex = respText[j][0].indexOf(".");
          if ((dotIndex !== -1) && (!isID)) {
            babelResp = babel[respText[j][0].substring(dotIndex+1)];
            respText[j][0] = this.name + "." + respText[j][0];
          }
          else {
            babelResp = babel[respText[j][0]];
          }

          if ( (babelResp === "type") && (babel[respText[j][1]] === "surface") ) {
            isSurface = true;
          }

          // if the expressions are different from this, then the cycle continues and is not replaced nothing        
          if ( (babelResp === "font") ||
               (babelResp === "font_family") ||
               (((babelResp === "fill") || (babelResp === "color") || (babelResp === "backcolor") || (babelResp === "arrow")) && (respText[j][1].charAt(0) !== "(")) ||
               ((babelResp === "file") && (respText[j][1].match(regExpImage))) ||
               ((babelResp !== "id") && (babel[respText[j][1]] !== undefined)) ||
               (isSurface && babelResp === "expresion")
             ) {
               if ((babelResp !== "width") && (babelResp !== "height") && (babelResp !== "length")) {
                continue;
               }
          }

          // is a text
          if (babelResp == "text") {
            // if the text is rtf must processing it diferent
            if (respText[j][1].match(/\{\\rtf1/)) {
              var textTemp = respText[j][1];
 
              //////////////////////////////////////////////////////////////////////////////////////////////////////////////
              var self = this;

              // function to replace expresions
              var funReplace = function(str, m1) {
                var tokens = tokenizer.tokenize(m1.replace(/\&squot;/g, "'"));
                
                for (var t=0, lt=tokens.length; t<lt; t++) {
                  if ((tokens[t].type == "identifier")  && (!descartesJS.reservedIds.match("-" + tokens[t].value + "-"))) {
                    tokens[t].value = self.name + "." + tokens[t].value;
                  }
                }
                
                var prefix = (str.match(/^\\expr/)) ? "\\expr " : "\\decimals ";

                return prefix + tokenizer.flatTokens(tokens);
              }
              //////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
              textTemp = textTemp.replace(/\\expr ([a-zA-Z_0-9\u00C0-\u021B+*/%|&^#!?:()><.'\+\-]*)/gi, funReplace);
              textTemp = textTemp.replace(/\\decimals ([a-zA-Z_0-9\u00C0-\u021B+*/%|&^#!?:()><.'\+\-]*)/gi, funReplace);
              
              respText[j][1] = textTemp;
            }
            // simple text
            else {
              // tmpTokensRespText = lessonParser.parseText(respText[j][1]).textElementsMacro3Ds;
              tmpTokensRespText = lessonParser.parseText(respText[j][1]).textElementsMacros;

              for (var ttrt=0, lttrt=tmpTokensRespText.length; ttrt<lttrt; ttrt++) {
                tmpTokens = tokenizer.tokenize(tmpTokensRespText[ttrt].replace(/\&squot;/g, "'"));

                for (var tt=0, ltt=tmpTokens.length; tt<ltt; tt++) {
                  if ((tmpTokens[tt].type === "identifier") && (!descartesJS.reservedIds.match("-" + tmpTokens[tt].value + "-"))) {
                    tmpTokens[tt].value = this.name + "." + tmpTokens[tt].value;
                  }
                }
                tmpTokens = (tokenizer.flatTokens(tmpTokens)).replace(/&squot;/g, "'").replace(/'\+\(/g, "[").replace(/\)\+'/g, "]");

                tmpTokensRespText[ttrt] = tmpTokens.substring(1, tmpTokens.length-1);
              }

              respText[j][1] = tmpTokensRespText.join("");
            }
          }
          // the token is not a text
          else {
            var tmpTokensArray = respText[j][1].replace(/\&squot;/g, "'").split(";");

            for (var tmpI=0, tmpL=tmpTokensArray.length; tmpI<tmpL; tmpI++) {
              tmpTokens = tokenizer.tokenize(tmpTokensArray[tmpI].replace(/\\n/g, ";"));

              for (var t=0, lt=tmpTokens.length; t<lt; t++) {
                if ((tmpTokens[t].type === "identifier") && (!descartesJS.reservedIds.match("-" + tmpTokens[t].value + "-"))) {
                  tmpTokens[t].value = this.name + "." + tmpTokens[t].value;
                }
              }

              tmpTokensArray[tmpI] = tokenizer.flatTokens(tmpTokens);
            }

            respText[j][1] = tmpTokensArray.join(";");
          }
        }
      }

      var tempResp;
      var isGraphic;

      // flat the expresions to obtain a string
      for (var i=0, l=response.length; i<l; i++) {
        if (response[i][0]) {
          tempResp = "";
          isGraphic = false;

          for (var j=0, k=response[i].length; j<k; j++) {
            // if the object has a type and is of the graphic3D type, then is a graphic object
            if ( (babel[response[i][j][0]] === "type") && (regExpType.match("-" + babel[response[i][j][1]] + "-")) ) {
              isGraphic = true;
            }

            tempResp = tempResp + response[i][j][0] + "='" + response[i][j][1] + "' ";
          }

          response[i] = tempResp + ((isGraphic) ? " space='" + this.spaceID + "'" : "");

          // build and add the graphic elements to the space
          if (isGraphic) {
            //agregar algo mas para indicar que se viene de un macro
            this.graphics.push( lessonParser.parse3DGraphic(response[i], this.abs_coord, this.background, this.inirot) );
          } 
          // build and add the axiliaries to the scene
          else {
            lessonParser.parseAuxiliar(response[i]);
          }
        }
      }
    }

    for (var i=0, l=this.graphics.length; i<l; i++) {
      this.graphics[i].macroChildren = true;
    }

  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Macro3D, descartesJS.Graphic);

  /**
   *
   */
  descartesJS.Macro3D.prototype.buildFamilyPrimitives = function() {
    evaluator = this.evaluator;

    // update the family values
    this.getFamilyValues();

    // save the last value of the family parameter
    var tempParam = evaluator.getVariable(this.family);

    if (this.fSteps >= 0) {
      // build the primitives of the family
      for(var i=0, l=this.fSteps; i<=l; i++) {
        // update the value of the family parameter
        evaluator.setVariable(this.family, this.familyInf+(i*this.family_sep));

        this.familyValue = this.familyInf+(i*this.family_sep);

        // if the condition to draw is true then update and draw the graphic
        if ( evaluator.eval(this.drawif) ) {
          this.updateMacro();
        }
      }
    }

    evaluator.setVariable(this.family, tempParam);
  }

  /**
   * Update the macro
   */
  descartesJS.Macro3D.prototype.update = function() {
    this.primitives = [];

    if (this.evaluator.eval(this.drawif)) {
      // build the primitives of a single object
      if (!this.family) {
        this.updateMacro();
      }
    }

    // build the primitives of the family
    if (this.family) {
      this.buildFamilyPrimitives();
    }    
  }

  /**
   * 
   */
  descartesJS.Macro3D.prototype.updateMacro = function() {
    this.updateTransformation();

    if (this.inipos) {
      var expr = this.evaluator.eval(this.inipos);
      this.iniPosX = expr[0][0];
      this.iniPosY = expr[0][1];
    }

    for (var i=0, l=this.graphics.length; i<l; i++) {
      thisGraphics_i = this.graphics[i];

      thisGraphics_i.macro_inirotEuler = this.inirotEuler;
      thisGraphics_i.macro_inirotM     = this.inirotM;
      thisGraphics_i.macro_inirotM_X   = this.inirotM_X;
      thisGraphics_i.macro_inirotM_Y   = this.inirotM_Y;
      thisGraphics_i.macro_inirotM_Z   = this.inirotM_Z;
      thisGraphics_i.macro_iniposM = this.iniposM;

      thisGraphics_i.macro_endrotEuler = this.endrotEuler;
      thisGraphics_i.macro_endrotM     = this.endrotM;
      thisGraphics_i.macro_endrotM_X   = this.endrotM_X;
      thisGraphics_i.macro_endrotM_Y   = this.endrotM_Y;
      thisGraphics_i.macro_endrotM_Z   = this.endrotM_Z;
      thisGraphics_i.macro_endposM = this.endposM;

      thisGraphics_i.update();
    }

    // split the primitives if needed
    for (var i=0, l=this.graphics.length; i<l; i++) {
      thisGraphics_i = this.graphics[i];

      if ((thisGraphics_i.split) || (this.split)) {
        for (var j=i+1; j<l; j++) {
          thisGraphicsNext = this.graphics[j];

          if ((thisGraphicsNext.split) || (this.split)) {
            thisGraphics_i.splitFace(thisGraphicsNext);
          }
        }
      }

      this.primitives = this.primitives.concat( thisGraphics_i.primitives || [] );
    }
  }

  /**
   *
   */
  descartesJS.Macro3D.prototype.updateTransformation = function() {
    tmpExpr = this.evaluator.eval(this.inirot);
    if (this.inirotEuler) {
      this.inirotM = this.inirotM.setIdentity();
      this.inirotM = this.inirotM.rotateZ(descartesJS.degToRad(tmpExpr[0][0])); //Z
      this.inirotM = this.inirotM.rotateX(descartesJS.degToRad(tmpExpr[0][1])); //X
      this.inirotM = this.inirotM.rotateZ(descartesJS.degToRad(tmpExpr[0][2])); //Z
    }
    else {
      this.inirotM_X = this.inirotM_X.setIdentity().rotateX(descartesJS.degToRad(tmpExpr[0][0])); //X
      this.inirotM_Y = this.inirotM_Y.setIdentity().rotateY(descartesJS.degToRad(tmpExpr[0][1])); //Y
      this.inirotM_Z = this.inirotM_Z.setIdentity().rotateZ(descartesJS.degToRad(tmpExpr[0][2])); //Z
    }

    tmpExpr = this.evaluator.eval(this.inipos);
    translate = { x: tmpExpr[0][0], y: tmpExpr[0][1], z: tmpExpr[0][2] };
    this.iniposM = this.iniposM.setIdentity().translate(translate);

    tmpExpr = this.evaluator.eval(this.endrot);
    if (this.endrotEuler) {
      this.endrotM = this.endrotM.setIdentity();
      this.endrotM = this.endrotM.rotateZ(descartesJS.degToRad(tmpExpr[0][0])); //Z
      this.endrotM = this.endrotM.rotateX(descartesJS.degToRad(tmpExpr[0][1])); //X
      this.endrotM = this.endrotM.rotateZ(descartesJS.degToRad(tmpExpr[0][2])); //Z
    }
    else {
      this.endrotM_X = this.endrotM_X.setIdentity().rotateX(descartesJS.degToRad(tmpExpr[0][0])); //X
      this.endrotM_Y = this.endrotM_Y.setIdentity().rotateY(descartesJS.degToRad(tmpExpr[0][1])); //Y
      this.endrotM_Z = this.endrotM_Z.setIdentity().rotateZ(descartesJS.degToRad(tmpExpr[0][2])); //Z
    }

    tmpExpr = this.evaluator.eval(this.endpos);
    translate = { x: tmpExpr[0][0], y: tmpExpr[0][1], z: tmpExpr[0][2] };
    this.endposM = this.endposM.setIdentity().translate(translate);
  }
  
  /**
   * Auxiliary function for draw a macro
   * @param {CanvasRenderingContext2D} ctx rendering context on which the macro is drawn
   */
  descartesJS.Macro3D.prototype.drawAux = function(ctx) { }

  return descartesJS;
})(descartesJS || {}, babel);/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathSin = Math.sin;
  var MathCos = Math.cos;
  var MathPI  = Math.PI;
  var Math2PI = 2*MathPI;
  var MathSqrt3 = Math.sqrt(3);
  var vec4D;

  var evaluator;
  var width;
  var height;
  var length;
  var Nu;
  var Nv;
  var v;
  var x;
  var y;
  var z;
  var theta;
  var phi;

  var R;
  var r;

  var goldenRatio = 1.6180339887;
  var width_d_goldenRatio;
  var width_m_goldenRatio;

  var tmpMatrix;

  var currentLine;
  var tempValue;
  var tempFace;

  var i;
  var l;
  var j;
  var k;


  /**
   * A Descartes 3D face
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the triangle
   */
  descartesJS.OtherGeometry = function(parent, values) {
    this.width = parent.evaluator.parser.parse("2");
    this.height = parent.evaluator.parser.parse("2");
    this.length = parent.evaluator.parser.parse("2");
    this.R = parent.evaluator.parser.parse("2");
    this.r = parent.evaluator.parser.parse("1");

    vec4D = descartesJS.Vector4D;

    // call the parent constructor
    descartesJS.Graphic3D.call(this, parent, values);

    switch (this.type) {
      case("cube"):
        this.buildGeometry = buildCube;
        break;

      case("box"):
        this.buildGeometry = buildBox;
        break;

      case("tetrahedron"):
        this.buildGeometry = buildTetrahedron;
        break;

      case("octahedron"):
        this.buildGeometry = buildOctahedron;
        break;

      case("sphere"):
        this.isSphere = true;
      case("ellipsoid"):
        this.buildGeometry = buildSphere;
        break;

      case("dodecahedron"):
        this.buildGeometry = buildDodecahedron;
        break;

      case("icosahedron"):
        this.buildGeometry = buildIcosahedron;
        break;

      case("cone"):
        this.buildGeometry = buildCone;
        break;

      case("cylinder"):
        this.buildGeometry = buildCylinder;
        break;

      case("torus"):
        this.buildGeometry = buildTorus;
        break;

      case("mesh"):
        this.fileData = descartesJS.openExternalFile(this.evaluator.eval(this.file)).split(/\r/);
        this.buildGeometry = buildMesh;
        break;
    }
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Graphic3D
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.OtherGeometry, descartesJS.Graphic3D);

  /**
   * Build the primitives corresponding to the face
   */
  descartesJS.OtherGeometry.prototype.buildPrimitives = function() {
    evaluator = this.evaluator;

    this.updateMVMatrix();

    // construct the vertices
    this.buildGeometry(evaluator.eval(this.width), evaluator.eval(this.height), evaluator.eval(this.length), evaluator.eval(this.Nu), evaluator.eval(this.Nv));

    var tmpFrontColor = this.color.getColor();
    var tmpBackColor = this.backcolor.getColor();
    var tmpEdgeColor = (this.edges) ? this.edges.getColor() : "";

    for (i=0, l=this.faces.length; i<l; i++) {
      v = [];
      for (j=0, k=this.faces[i].length; j<k; j++) {
        v.push( this.transformVertex(this.vertices[this.faces[i][j]]) );
      }

      this.primitives.push( new descartesJS.Primitive3D( { vertices: v,
                                                           type: "face",
                                                           frontColor: tmpFrontColor,
                                                           backColor: tmpBackColor,
                                                           edges: tmpEdgeColor,
                                                           model: this.model
                                                         },
                            this.space ));
    }
  }

  /**
   * Define the vertex and faces of the cube
   */
  function buildCube(width, height, length, Nu, Nv) {
    buildBox.call(this, width/MathSqrt3, width/MathSqrt3, width/MathSqrt3, Nu, Nv);
  }

  /**
   * Define the vertex and faces of the box
   */
  function buildBox(width, height, length, Nu, Nv) {
    width  = width/2;
    height = height/2;
    length = length/2;

    // if the geometry has to change
    if (this.changeGeometry(width, height, length, Nu, Nv)) {
      return;
    }

    this.vertices = [ new vec4D( width,  length,  height, 1), //0
                      new vec4D( width, -length,  height, 1), //1
                      new vec4D( width,  length, -height, 1), //2
                      new vec4D( width, -length, -height, 1), //3
                      new vec4D(-width,  length,  height, 1), //4
                      new vec4D(-width, -length,  height, 1), //5
                      new vec4D(-width,  length, -height, 1), //6
                      new vec4D(-width, -length, -height, 1)  //7
               ];

    this.faces = [[2, 3, 1, 0], [1, 5, 4, 0], [5, 7, 6, 4], [6, 7, 3, 2], [4, 6, 2, 0], [3, 7, 5, 1]];

    this.updateValues(width, height, length, Nu, Nv);

  }

  /**
   * Define the vertex and faces of the tetrahedron
   */
  function buildTetrahedron(width, height, length, Nu, Nv) {
    width = width/2;

    // if the geometry has to change
    if (this.changeGeometry(width, height, length, Nu, Nv)) {
      return;
    }

    var angle = 2*Math.PI/3;
    var x = width*2*Math.sqrt(2)/3;
    var y = 0;
    var z = -width*1/3;
    var x0 =  x*Math.cos(angle) + y*Math.sin(angle);
    var y0 = -x*Math.sin(angle) + y*Math.cos(angle);
    this.vertices = [ new vec4D( 0,   0, width, 1), //0
                      new vec4D(x0,  y0,     z, 1), //1
                      new vec4D(x0, -y0,     z, 1), //2
                      new vec4D( x,   y,     z, 1), //3
    ];

    this.faces = [[1, 3, 2], [0, 1, 2], [0, 2, 3], [0, 3, 1]];

    // this.vertices = [ new vec4D(          0,           0,       width, 1), //0
    //                   new vec4D(-0.49*width, -0.86*width, -0.32*width, 1), //1
    //                   new vec4D(-0.49*width,  0.86*width, -0.32*width, 1), //2
    //                   new vec4D(    1*width,           0, -0.32*width, 1)  //3
    //            ];

    // this.faces = [[3, 2, 1], [1, 2, 0], [2, 3, 0], [3, 1, 0]];

    this.updateValues(width, height, length, Nu, Nv);
  }

  /**
   * Define the vertex and faces of the octahedron
   */
  function buildOctahedron(width, height, length, Nu, Nv) {
    width = width/2;

    // if the geometry has to change
    if (this.changeGeometry(width, height, length, Nu, Nv)) {
      return;
    }

    this.vertices = [ new vec4D( 0,          0,  width, 1), //0
                      new vec4D( width,      0,      0, 1), //1
                      new vec4D(-width,      0,      0, 1), //2
                      new vec4D( 0,      width,      0, 1), //3
                      new vec4D( 0,     -width,      0, 1), //4
                      new vec4D( 0,          0, -width, 1)  //5
               ];

    this.faces = [[3, 1, 0], [2, 3, 0], [1, 4, 0], [4, 2, 0], [1, 3, 5], [3, 2, 5], [4, 1, 5], [2, 4, 5]];

    this.updateValues(width, height, length, Nu, Nv);
  }

  /**
   * Define the vertex and faces of the dodecahedron
   */
  function buildDodecahedron(width, height, length, Nu, Nv) {
    width = width/Math.PI;

    // if the geometry has to change
    if (this.changeGeometry(width, height, length, Nu, Nv)) {
      return;
    }

    width_d_goldenRatio = width/goldenRatio;
    width_m_goldenRatio = width*goldenRatio;

    this.vertices = [ new vec4D( width,  width,  width, 1), //0
                      new vec4D( width,  width, -width, 1), //1
                      new vec4D( width, -width,  width, 1), //2
                      new vec4D( width, -width, -width, 1), //3
                      new vec4D(-width,  width,  width, 1), //4
                      new vec4D(-width,  width, -width, 1), //5
                      new vec4D(-width, -width,  width, 1), //6
                      new vec4D(-width, -width, -width, 1), //7

                      new vec4D(0,  width_d_goldenRatio,  width_m_goldenRatio, 1), //8
                      new vec4D(0,  width_d_goldenRatio, -width_m_goldenRatio, 1), //9
                      new vec4D(0, -width_d_goldenRatio,  width_m_goldenRatio, 1), //10
                      new vec4D(0, -width_d_goldenRatio, -width_m_goldenRatio, 1), //11

                      new vec4D( width_d_goldenRatio,  width_m_goldenRatio, 0, 1), //12
                      new vec4D( width_d_goldenRatio, -width_m_goldenRatio, 0, 1), //13
                      new vec4D(-width_d_goldenRatio,  width_m_goldenRatio, 0, 1), //14
                      new vec4D(-width_d_goldenRatio, -width_m_goldenRatio, 0, 1), //15

                      new vec4D( width_m_goldenRatio, 0,  width_d_goldenRatio, 1), //16
                      new vec4D( width_m_goldenRatio, 0, -width_d_goldenRatio, 1), //17
                      new vec4D(-width_m_goldenRatio, 0,  width_d_goldenRatio, 1), //18
                      new vec4D(-width_m_goldenRatio, 0, -width_d_goldenRatio, 1)  //19
               ];

    // tmpMatrix = new descartesJS.Matrix4x4().setIdentity().rotate(-MathPI/6, new descartesJS.Vector3D(0, 1, 0));
    tmpMatrix = new descartesJS.Matrix4x4().setIdentity().rotateY(-MathPI/6);
    for (i=0, l=this.vertices.length; i<l; i++) {
      this.vertices[i] = tmpMatrix.multiplyVector4(this.vertices[i]);
    }

    this.faces = [[0, 16, 2, 10, 8], [12, 1, 17, 16, 0], [8, 4, 14, 12, 0], [2, 16, 17, 3, 13], [13, 15, 6, 10, 2], [6, 18, 4, 8, 10], [3, 17, 1, 9, 11], [13, 3, 11, 7, 15], [1, 12, 14, 5, 9], [11, 9, 5, 19, 7], [5, 14, 4, 18, 19], [6, 15, 7, 19, 18]];

    this.updateValues(width, height, length, Nu, Nv);
  }

  /**
   * Define the vertex and faces of the icosahedron
   */
  function buildIcosahedron(width, height, length, Nu, Nv) {
    width = width/3.8;

    // if the geometry has to change
    if (this.changeGeometry(width, height, length, Nu, Nv)) {
      return;
    }

    width_m_goldenRatio = width*goldenRatio;

    this.vertices = [ new vec4D(0,  width,  width_m_goldenRatio, 1), //0
                      new vec4D(0,  width, -width_m_goldenRatio, 1), //1
                      new vec4D(0, -width,  width_m_goldenRatio, 1), //2
                      new vec4D(0, -width, -width_m_goldenRatio, 1), //3

                      new vec4D( width,  width_m_goldenRatio, 0, 1), //4
                      new vec4D( width, -width_m_goldenRatio, 0, 1), //5
                      new vec4D(-width,  width_m_goldenRatio, 0, 1), //6
                      new vec4D(-width, -width_m_goldenRatio, 0, 1), //7

                      new vec4D( width_m_goldenRatio, 0,  width, 1), //8
                      new vec4D( width_m_goldenRatio, 0, -width, 1), //9
                      new vec4D(-width_m_goldenRatio, 0,  width, 1), //10
                      new vec4D(-width_m_goldenRatio, 0, -width, 1)  //11
                    ];

    this.faces = [[10, 0, 2], [0, 8, 2], [8, 5, 2], [5, 7, 2], [7, 10, 2],
                  [6, 0, 10], [11, 6, 10], [7, 11, 10], [7, 3, 11], [5, 3, 7], [9, 3, 5], [8, 9, 5], [4, 9, 8], [0, 4, 8], [6, 4, 0],
                  [11, 3, 1], [6, 11, 1], [4, 6, 1], [9, 4, 1], [3, 9, 1]];

    // tmpMatrix = new descartesJS.Matrix4x4().setIdentity().rotate(-1.029, new descartesJS.Vector3D(0, 1, 0));
    tmpMatrix = new descartesJS.Matrix4x4().setIdentity().rotateY(-1.0285);
    for (i=0, l=this.vertices.length; i<l; i++) {
      this.vertices[i] = tmpMatrix.multiplyVector4(this.vertices[i]);
    }

    this.updateValues(width, height, length, Nu, Nv);
  }

  /**
   * Define the vertex and faces of the sphere
   */
  function buildSphere(width, height, length, Nu, Nv) {
    width = width/2;

    if (this.isSphere) {
      height = width;
      length = width;
    }
    else {
      height = height/2;
      length = length/2;
    }

    // if the geometry has to change
    if (this.changeGeometry(width, height, length, Nu, Nv)) {
      return;
    }

    this.vertices = [new vec4D(0, 0, height, 1)];

    for (i=1; i<Nu; i++) {
      phi = (i*MathPI)/Nu;
      for (j=0; j<Nv; j++) {
        theta = (j*Math2PI)/Nv;

        x = width  * MathSin(phi) * MathCos(theta);
        y = length * MathSin(phi) * MathSin(theta);
        z = height * MathCos(phi);

        this.vertices.push(new vec4D(x, y, z, 1));
      }
    }
    this.vertices.push(new vec4D(0, 0, -height, 1));

    this.faces = [];
    // upper part
    for (i=0; i<Nv; i++) {
      this.faces.push([0, ((i+1)%Nv)+1, (i%Nv)+1]);
    }

    // center part
    for (i=1; i<Nu-1; i++) {
      for (j=0; j<Nv; j++) {
        this.faces.push([ j+1 +(i-1)*Nv,
                         (j+1)%Nv +1 +(i-1)*Nv,
                         (j+1)%Nv +1 +i*Nv,
                         j+1 +i*Nv
                        ]);
      }
    }

    // lower part
    for (i=0; i<Nv; i++) {
      this.faces.push([this.vertices.length-1, this.vertices.length-1-Nv +i, this.vertices.length-1-Nv +((i+1)%Nv)]);
    }

    this.updateValues(width, height, length, Nu, Nv);
  }

  /**
   * Define the vertex and faces of the cone
   */
  function buildCone(width, height, length, Nu, Nv) {
    width  = width/2;
    height = height/2;
    length = length/2;

    // if the geometry has to change
    if (this.changeGeometry(width, height, length, Nu, Nv)) {
      return;
    }

    this.vertices = [];

    for (i=0; i<Nv; i++) {
      for (j=0; j<Nu; j++) {
        x = width  * (Nv-i)/Nv * MathCos(j*Math2PI/Nu);
        y = length * (Nv-i)/Nv * MathSin(j*Math2PI/Nu);
        z = height -i*2*height/Nv;

        this.vertices.push(new vec4D(x, y, z, 1));
      }
    }
    this.vertices.push(new vec4D(0, 0, -height, 1))

    this.faces = [];

    for (i=0; i<Nv-1; i++) {
      for (j=0; j<Nu; j++) {
        this.faces.push( [j +i*Nu,
                          (j+1)%Nu +i*Nu,
                          (j+1)%Nu +(i+1)*Nu,
                          j +(i+1)*Nu
                         ]
                       );
      }
    }

    // punta
    for (i=0; i<Nu; i++) {
      this.faces.push([this.vertices.length-1, this.vertices.length-1 -Nu +i, this.vertices.length-1 -Nu +(i+1)%Nu]);
    }

    this.updateValues(width, height, length, Nu, Nv);
  }

  /**
   * Define the vertex and faces of the cone
   */
  function buildCylinder(width, height, length, Nu, Nv) {
    width  = width/2;
    height = height/2;
    length = length/2;

    // if the geometry has to change
    if (this.changeGeometry(width, height, length, Nu, Nv)) {
      return;
    }

    this.vertices = [];

    for (i=0; i<Nv+1; i++) {
      for (j=0; j<Nu; j++) {
        x = width  * MathCos(j*Math2PI/Nu);
        y = length * MathSin(j*Math2PI/Nu);
        z = height -i*2*height/Nv;

        this.vertices.push(new vec4D(x, y, z, 1));
      }
    }

    this.faces = [];

    for (i=0; i<Nv; i++) {
      for (j=0; j<Nu; j++) {
        this.faces.push( [j +i*Nu,
                          (j+1)%Nu +i*Nu,
                          (j+1)%Nu +(i+1)*Nu,
                          j +(i+1)*Nu
                         ]
                       );
      }
    }

    this.updateValues(width, height, length, Nu, Nv);
  }

  /**
   * Define the vertex and faces of a torus
   */
  function buildTorus(width, height, length, Nu, Nv) {
    width  = width/2;
    height = height/2;
    length = length/2;

    R = evaluator.eval(this.R);
    r = evaluator.eval(this.r);

    // if the geometry has to change
    if (this.changeGeometry(width, height, length, Nu, Nv)) {
      return;
    }

    this.vertices = [];

    for (i=0; i<Nv+1; i++) {
      for (j=0; j<Nu; j++) {
        x = -(R + r * MathSin(Math2PI*j/Nu)) * MathSin(Math2PI*i/Nv);
        y =  (R + r * MathSin(Math2PI*j/Nu))  * MathCos(Math2PI*i/Nv);
        z = r * MathCos(Math2PI*j/Nu);
        this.vertices.push(new vec4D(x, y, z, 1));
      }
    }
    this.faces = [];

    for (i=0; i<Nv; i++) {
      for (j=0; j<Nu; j++) {
        this.faces.push( [j +i*Nu,
                          j +(i+1)*Nu,
                          (j+1)%Nu +(i+1)*Nu,
                          (j+1)%Nu +i*Nu
                         ]
                       );
      }
    }

    this.updateValues(width, height, length, Nu, Nv);
  }

  /**
   * Define the vertex and faces of a mesh
   */
  function buildMesh() {
    this.vertices = [];
    this.faces = [];

    function toInt(x) { return parseInt(x); };
    function toFloat(x) { return parseFloat(x); };

    for (i=0, l=this.fileData.length; i<l; i++) {
      currentLine = this.fileData[i];

      if (currentLine.match(/^V\(/)) {
        tempValue = currentLine.substring(2, currentLine.length-1).split(",").map(toFloat);
        this.vertices.push( new vec4D(tempValue[0] || 0, tempValue[1] || 0, tempValue[2] || 0, 1) );
      }

      else if (currentLine.match(/^F\(/)) {
        tempValue = currentLine.substring(2, currentLine.length-1).split(",").map(toInt);
        this.faces.push(tempValue.reverse());
      }
    }
  }

  /**
   *
   */
  descartesJS.OtherGeometry.prototype.changeGeometry = function(width, height, length, Nu, Nv) {
    return (this.oldWidth  === width) && (this.oldHeight === height) && (this.oldLength === length) && (this.oldNu === Nu) && (this.oldNv === Nv);
  }

  /**
   *
   */
  descartesJS.OtherGeometry.prototype.updateValues = function(width, height, length, Nu, Nv) {
    this.oldWidth = width;
    this.oldHeight = height;
    this.oldLength = length;
    this.oldNv = Nv;
    this.oldNu = Nu;
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathMax = Math.max;
  var MathMin = Math.min;
  var MathPI = Math.PI;
  var MathCos = Math.cos;
  var MathSin = Math.sin;
  var MathAbs = Math.abs;
  var MathRound = Math.round;
  var aux;
  var q;
  var p;
  var s;
  var t;
  var cost;
  var sint;

  var A11;
  var A12;
  var B1;
  var A21;
  var A22;
  var B2;
    
  var mp;
  var Mp;
  var mq;
  var Mq;
  var Det;

  /**
   * Descartes R2
   * @constructor 
   * @param {Number} x the x position
   * @param {Number} y the y position
   */
  descartesJS.R2 = function(x, y) {
    this.x = x || 0;
    this.y = y || 0;
  }

  descartesJS.R2.prototype.set = function(x, y) {
    this.x = x || 0;
    this.y = y || 0;
    return this;
  }

  descartesJS.R2.prototype.copy = function() {
    return new descartesJS.R2(this.x, this.y);
  }
  
  descartesJS.R2.prototype.ix = function() {
    return MathRound(MathMax(MathMin(this.x, 32000), -32000));
  }

  descartesJS.R2.prototype.iy = function() {
    return MathRound(MathMax(MathMin(this.y, 32000), -32000));
  }

  descartesJS.R2.prototype.equals = function(p) {
    return ((this.x === p.x) && (this.y === p.y)); 
  }

  descartesJS.R2.prototype.norm2 = function() {
    return this.x*this.x + this.y*this.y; 
  }

  descartesJS.R2.prototype.norm = function() {
    return Math.sqrt( this.norm2() ); 
  }

  descartesJS.R2.prototype.distance = function(p) {
    q = this.copy(); 
    q.sub(p); 
    
    return q.norm(); 
  }

  descartesJS.R2.prototype.dot = function(p) {
    return this.x*p.x + this.y*p.y; 
  }

  descartesJS.R2.prototype.det = function(p) {
    return this.x*p.y - this.y*p.x; 
  }

  descartesJS.R2.prototype.mul = function(m) {
    this.x*=m;
    this.y*=m; 
  }

  descartesJS.R2.prototype.div = function(d) {
    this.x/=d;
    this.y/=d; 
  }

  descartesJS.R2.prototype.add = function(p) {
    this.x+=p.x;
    this.y+=p.y; 
  }

  descartesJS.R2.prototype.sub = function(p) {
    this.x-=p.x;
    this.y-=p.y; 
  }

  descartesJS.R2.prototype.normalize = function() {
    aux = this.norm(); 
    if (aux != 0.0) { 
      this.div(aux); 
    }
  }

  descartesJS.R2.prototype.rotR90 = function() {
    aux = this.x;
    this.x = this.y;
    this.y = -aux; 
  }

  descartesJS.R2.prototype.rotL90 = function() {
    aux = this.x;
    this.x = -this.y;
    this.y = aux;
  }

  descartesJS.R2.prototype.rot = function(t) {
    p = this.copy();
    cost = MathCos(t);
    sint = MathSin(t);
    this.x = p.x*cost - p.y*sint;
    this.y = p.x*sint + p.y*cost;
  }

  descartesJS.R2.prototype.rot = function(g) {
    this.rot(g*MathPI/180); 
  }

  descartesJS.R2.prototype.intersection = function(p1, p2, q1, q2) {
    A11 = (p2.x-p1.x);
    A12 = (q1.x-q2.x);
    B1 = q1.x-p1.x;
    
    A21 = (p2.y-p1.y);
    A22 = (q1.y-q2.y);
    B2 = q1.y-p1.y;

    Det = A11*A22-A12*A21;
    if (MathAbs(Det) > 0.000001) {
      s = ( B1*A22-B2*A12)/Det;
      t = (-B1*A21+B2*A11)/Det;
      
      if (0<=s && s<=1 && 0<=t && t<=1) {
        return new descartesJS.R2(p1.x+A11*s, p1.y+A21*s);
      } else {
        return null;
      }
    } 
    
    else if ((p2.x-q1.x)*B2 != (p2.y-q1.y)*B1) {
      return null;
    } 
    else {
      if (p1.x != p2.x) {
        mp = MathMin(p1.x, p2.x);
        Mp = MathMax(p1.x, p2.x);
        
        if (mp<=q1.x && q1.x<=Mp) {
          return q1;
        } 
        else if (mp<=q2.x && q2.x<=Mp) {
          return q2;
        }
        return null;
      } 
      else if (q1.x != q2.x) {
        mq = MathMin(q1.x, q2.x);
        Mq = MathMax(q1.x, q2.x);
        
        if (mq<=p1.x && p1.x<=Mq) {
          return p1;
        } 
        else if (mq<=p2.x && p2.x<=Mq) {
          return p2;
        }
        return null;
      } 
      else if (p1.y != p2.y) {
        mp = MathMin(p1.y, p2.y);
        Mp = MathMax(p1.y, p2.y);
        
        if (mp<=q1.y && q1.y<=Mp) {
          return q1;
        } 
        else if (mp<=q2.y && q2.y<=Mp) {
          return q2;
        }
        return null;
      } 
      else if (q1.y != q2.y) {
        mq=MathMin(q1.y, q2.y);
        Mq=MathMax(q1.y, q2.y);
        
        if (mq<=p1.y && p1.y<=Mq) {
          return p1;
        } 
        else if (mq<=p2.y && p2.y<=Mq) {
          return p2;
        }
        return null;
      } 
      else if (p1.x==q1.x && p1.y==q1.y) {
        return p1;
      } else {
        return null;
      }
    }
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var delta = 0.000001;

  var evaluator;
  var FV;
  var xa;
  var ya;
  var q;
  var newQ;
  var savex;
  var savey;

  var _unitNormal;


  /**
   * Descartes R2Newton
   * @constructor 
   * @param {Evaluator} evaluator the Descartes evaluator
   * @param {String} constraint the constraint of the R2Newton
   */
  descartesJS.R2Newton = function(evaluator, constraint) {
    this.evaluator = evaluator;
    this.constraint = constraint;
    
    if ((this.constraint.value == "==") || (this.constraint.value == "<") || (this.constraint.value == "<=") || (this.constraint.value == ">") || (this.constraint.value == ">=")) {
      
      if ((this.constraint.value == "<") || (this.constraint.value == "<=")) {
        this.sign = "menor";
      }
      
      else if ((this.constraint.value == ">") || (this.constraint.value == ">=")) {
        this.sign = "mayor";
      }
      
      else {
        this.sign = "igual"; 
      }
      
      // a constraint of the form "something = somethingElse" is converted to "someting - somethingElse = 0"
      this.constraint = this.constraint.equalToMinus();
      // evaluates onlye the left size, because the right size is 0
      this.constraint = this.constraint.childs[0];
    }

    newQ = new descartesJS.R2(0, 0);
    q = new descartesJS.R2(0, 0);
    _unitNormal = new descartesJS.R2(0, 0);
  }
  
  /**
   * 
   */
  descartesJS.R2Newton.prototype.getUnitNormal = function() {
    this.normal.normalize();
    
    return _unitNormal.set(this.normal.x, this.normal.y);
  }
  
  /**
   * 
   */
  descartesJS.R2Newton.prototype.gradient = function(q0) {
    evaluator = this.evaluator;
    
    newQ.x = 0;
    newQ.y = 0;

    savex = evaluator.getVariable("x");
    savey = evaluator.getVariable("y");

    evaluator.setVariable("x", q0.x);
    evaluator.setVariable("y", q0.y);

    this.f0 = evaluator.eval(this.constraint);
    
    evaluator.setVariable("x", evaluator.getVariable("x") + delta);

    FV = evaluator.eval(this.constraint);
   
    newQ.x = (FV-this.f0)/delta;
    newQ.x = (!isNaN(newQ.x)) ? newQ.x : Infinity;
    
    evaluator.setVariable("x", evaluator.getVariable("x") - delta);
    evaluator.setVariable("y", evaluator.getVariable("y") + delta);

    FV = evaluator.eval(this.constraint);

    newQ.y = (FV-this.f0)/delta;
    newQ.y = (!isNaN(newQ.y)) ? newQ.y : Infinity;

    evaluator.setVariable("x", savex);
    evaluator.setVariable("y", savey);
    
    return newQ;    
  }

  /**
   * 
   */
  descartesJS.R2Newton.prototype.findZero = function(q0, dist, is_graphic_control) {
    evaluator = this.evaluator;
    
    q.x = q0.x;
    q.y = q0.y;
    
    savex = evaluator.getVariable("x");
    savey = evaluator.getVariable("y");
    
    evaluator.setVariable("x", q0.x);
    evaluator.setVariable("y", q0.y);
    
    this.f0 = evaluator.eval(this.constraint);
    
    if ((this.sign === "menor") && (this.f0 <= 0)) {
      return q;
    } 
    else if ((this.sign === "mayor") && (this.f0 >= 0)) {
      return q;
    }
    
    evaluator.setVariable("x", savex);
    evaluator.setVariable("y", savey);

    for (var i=0; i<16; i++) {
      xa = q.x;
      ya = q.y;

      this.normal = this.gradient(q);

      if (this.normal.norm2() != 0) {
        this.normal.mul(-this.f0/this.normal.norm2());
      }

      q.x = xa+this.normal.x; 
      q.y = ya+this.normal.y;
      
      if (this.normal.norm() < dist) {
        if ((this.normal.x === 0) && (this.normal.y === 0)) {
          this.normal.x = q.x-q0.x;
          this.normal.y = q.y-q0.y;
        }
        return q;
      }
    }

    if (is_graphic_control) {
      return q;
    }
    else {
      return null;
    }
  }

  return descartesJS;
})(descartesJS || {});/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Descartes R2 vector
   * @constructor 
   * @param {Number} x the x component of the vector
   * @param {Number} y the y component of the vector
   */
  descartesJS.Vector2D = function(x, y) {
    this.x = x;
    this.y = y;
  }
  
  /**
   * Axis X vector
   * @const
   * @type {Vector2D}
   */ 
  descartesJS.Vector2D.AXIS_X = new descartesJS.Vector2D(1, 0);;

  /**
   * Axis Y vector
   * @const
   * @type {Vector2D}
   */ 
  descartesJS.Vector2D.AXIS_Y = new descartesJS.Vector2D(0, 1);

  /**
   * Get the lenght of a 2D vector
   * @return {Number} return the lenght of a 2D vector
   */
  descartesJS.Vector2D.prototype.vectorLength = function() {
    return Math.sqrt(this.x*this.x + this.y*this.y);
  }
  
  /**
   * Calculate the dot product of two vectors
   * @param {Vector2D} v the second vector for the calculation of the dot product
   * @return {Number} return the dot product
   */
  descartesJS.Vector2D.prototype.dotProduct = function(v) {
    return this.x*v.x + this.y*v.y;
  }
  
  /**
   * Calculate the angle between two vectors
   * @param {Vector2D} v the second vector for the calculation of the angle between two vectors
   * @return {Number} return the angle between two vectors
   */
  descartesJS.Vector2D.prototype.angleBetweenVectors = function(v) {
    return Math.acos(this.dotProduct(v)/(this.vectorLength()*v.vectorLength()));
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathFloor = Math.floor;
  var MathRound = Math.round;
  var hh;
  var di;
  var changeX;
  var changeY;
  var changeW;
  var changeH;
  var expr;

  var temporalCompare;
  var resultValue;
  var decimals;
  var indexDot;
  var subS;
  var parent;

  var canvas;
  var ctx;
  var self;
  var _left;
  var _top;
  var _width;
  var _height;

  /**
   * Descartes control
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the control
   */
  descartesJS.Control = function(parent, values) {
    /**
     * Descartes application
     * type {DescartesApp}
     * @private
     */
    this.parent = parent;
    this.evaluator = parent.evaluator;
    this.parser = parent.evaluator.parser;
    var parser = this.parser;

    /**
     * identifier
     * type {String}
     * @private
     */
    this.id = (values.type !== "graphic") ? "C" : "G";

    /**
     * type (numeric or graphic)
     * type {String}
     * @private
     */
    this.type = "";

    /**
     * interface
     * type {String}
     * @private
     */
    this.gui = "";

    /**
     * region to draw
     * type {String}
     * @private
     */
    this.region = "south";

    /**
     * space name
     * type {String}
     * @private
     */
//     this.space = "E0";

    /**
     * name
     * type {String}
     * @private
     */
//     this.name = "";

    /**
     * x position
     * type {Number}
     * @private
     */
    this.x = 0;

    /**
     * y position
     * type {Number}
     * @private
     */
    this.y = 0;

    /**
     * width
     * type {Number}
     * @private
     */
    this.w = (values.type !== "video") ? 100 : 350;

    /**
     * height
     * type {Number}
     * @private
     */
    this.h = (values.type !== "video") ? 23 : 120;

    /**
     * position and size expression
     * type {String}
     * @private
     */
    if ((values.type !== "graphic") && (values.type !== "audio") && (values.type !== "video")) {
      if (values.type !== "text") {
        this.expresion = parser.parse("(0,0,100,23)");
      } else {
        this.expresion = parser.parse("(0,0,300,200)");
        this.w = 300;
        this.h = 200;
      }
    }
    else {
      this.expresion = parser.parse("(0,0)");
    }

    /**
     * condition to use fixed notation in the number values
     * type {Boolean}
     * @private
     */
    this.fixed = (this.parent.version != 2) ? false : true;

    /**
     * condition visibility
     * type {Boolean}
     * @private
     */
    this.visible = true;

    /**
     * text color
     * type {String}
     * @private
     */
    this.color = new descartesJS.Color((this.parent.version < 4) ? "000000" : "222222");

    /**
     * control color
     * type {String}
     * @private
     */
    this.colorInt = new descartesJS.Color((values.type !== "graphic") ? "f0f8ff" : "cc0022");

    /**
     * bold text condition
     * type {String}
     * @private
     */
    this.bold = "";

    /**
     * italic text condition
     * type {String}
     * @private
     */
    this.italics = "";

    /**
     * underline text condition
     * type {String}
     * @private
     */
    this.underlined = "";

    /**
     * font size of the control
     * type {Object}
     * @private
     */
    this.font_size = (this.parent.version < 4) ? -1 : parser.parse("12");

    /**
     * action type
     * type {String}
     * @private
     */
    this.action = "";

    /**
     * parameter
     * type {String}
     * @private
     */
    this.parameter = "";

    /**
     * parameter font
     * type {String}
     * @private
     */
    this.parameterFont = "Monospace 12px";

    /**
     * draw condition
     * type {Node}
     * @private
     */
    this.drawif = parser.parse("1");

    /**
     * active condition
     * type {Node}
     * @private
     */
    this.activeif = parser.parse("1");

    /**
     * tooltip text
     * type {String}
     * @private
     */
    this.tooltip = "";

    /**
     * tooltip font
     * type {String}
     * @private
     */
    this.tooltipFont = "Monospace 12px";

    /**
     * control explanation
     * type {String}
     * @private
     */
    this.Explanation = "";

    /**
     * explanation font
     * type {String}
     * @private
     */
    this.ExplanationFont = "Monospace 12px";

    /**
     * mensage position
     * type {String}
     * @private
     */
    this.msg_pos = "";

    /**
     * conponent identifier
     * type {String}
     * @private
     */
    this.cID = "";

    /**
     * initial value (spinner)
     * type {Node}
     * @private
     */
    this.valueExpr = parser.parse("0");

    /**
     * decimal number of the text
     * type {Node}
     * @private
     */
    this.decimals = parser.parse("2");

    /**
     * lower limit
     * type {Node}
     * @private
     */
    this.min = parser.parse("-Infinity");

    /**
     * upper limit
     * type {Node}
     * @private
     */
    this.max = parser.parse("Infinity");

    /**
     * increment
     * type {Node}
     * @private
     */
    this.incr = parser.parse("0.1");

    /**
     * discrete numbers condition
     * type {Boolean}
     * @private
     */
    this.discrete = false;

    /**
     * condition to use exponential notation
     * type {Boolean}
     * @private
     */
    this.exponentialif = false;

    /**
     * z index
     * @type {Number}
     * @private
     */
    this.zIndex = -1;

    // traverse the values to replace the defaults values of the object
    for (var propName in values) {
      // verify the own properties of the object
      if (values.hasOwnProperty(propName)) {
        this[propName] = values[propName];
      }
    }

    // move the video and audio controls to the interior region
    if (((this.type === "video") || (this.type === "audio")) && (this.region !== "interior")) {
      this.region = "interior";
    }

    // ## Descartes 2 patch ## //
    if (this.name == undefined) {
      this.name = (this.parent.version == 2) ? this.id : "_nada_";
    }
    this.name = ((this.name == "_._") || (this.name == "_nada_") || (this.name == "_void_")) ? "" : this.name;

    var expr = this.evaluator.eval(this.expresion);
    this.x = MathRound(expr[0][0]);
    this.y = MathRound(expr[0][1]);
    if (expr[0].length == 4) {
      this.w = MathRound(expr[0][2]);
      this.h = MathRound(expr[0][3]);
    }

    this.actionExec = parent.lessonParser.parseAction(this);
  }

  /**
   * Init the control parameters
   */
  descartesJS.Control.prototype.init = function() { }

  /**
   * Update the control
   */
  descartesJS.Control.prototype.update = function() { }

  /**
   * Draw the control
   */
  descartesJS.Control.prototype.draw = function() { }

  /**
   * Get the space container and add the cotrol to it
   * @return {HTMLnode} return the space container asociated with the control
   */
  descartesJS.Control.prototype.getContainer = function() {
    var spaces = this.parent.spaces;
    var space_i;
    // if the control is in the interior region
    if (this.region === "interior") {
      for(var i=0, l=spaces.length; i<l; i++) {
        space_i = spaces[i];
        if (space_i.id === this.spaceID) {
          space_i.addCtr(this);
          this.zIndex = space_i.zIndex;
          this.space = space_i;
          // this.space = space_i;
          return space_i.numericalControlContainer;
        }
      }
    }
    // if the control is in the external region
    else if (this.region === "external") {
      this.parent.externalSpace.addCtr(this);
      return this.parent.externalSpace.container;
    }
    // if the control is in the scenario
    else if (this.region === "scenario") {
      // has a cID
      if (this.cID) {
        this.expresion = this.evaluator.parser.parse("(0,-1000," + this.w + "," + this.h + ")");
        this.parent.stage.stageSpace.addCtr(this);
        this.zIndex = this.parent.stage.stageSpace.zIndex;
        return this.parent.stage.stageSpace.numericalControlContainer;
      }
      else {
        return this.parent.externalSpace.container;
      }

    }
    // if the cotrol is in the north, south, east or west region
    else if ((/north|south|east|west/).test(this.region)) {
      this.parent[this.region + "Space"].controls.push(this);
      return this.parent[this.region + "Space"].container;
    }

    // if do not find a space with the identifier then return the first space
    spaces[0].addCtr(this);
    this.zIndex = spaces[0].zIndex;
    return spaces[0].numericalControlContainer;
  }

  /**
   *
   * @return {HTMLnode} return the space container asociated with the control
   */
  descartesJS.Control.prototype.addControlContainer = function(controlContainer) {
    // get the control container
    var container = this.getContainer();

    // add the container in inverse order to the space container
    if (!container.childNodes[0]) {
      container.appendChild(controlContainer);
    }
    else {
      container.insertBefore(controlContainer, container.childNodes[0]);
    }
  }

  /**
   * Update the position and size of the control
   */
  descartesJS.Control.prototype.updatePositionAndSize = function() {
    changeX = changeY = changeW = changeH = false;
    expr = this.evaluator.eval(this.expresion);

    temporalCompare = MathRound(expr[0][0]);
    changeX = MathRound(this.x) !== temporalCompare;
    this.x = temporalCompare;

    temporalCompare = MathRound(expr[0][1]);
    changeY = MathRound(this.y) !== temporalCompare;
    this.y = temporalCompare;

    if (expr[0].length === 4) {
      temporalCompare = MathRound(expr[0][2]);
      changeW = MathRound(this.w) !== temporalCompare;
      this.w = temporalCompare

      temporalCompare = MathRound(expr[0][3]);
      changeH = MathRound(this.h) !== temporalCompare;
      this.h = temporalCompare;
    }

    // if has some change, then init the control and redraw it
    if ((changeW) || (changeH) || (changeX) || (changeY)) {
      this.init(true);
      this.draw();
    }
  }

  /**
   * Format the value with the number of decimals, the exponential representation and the decimal symbol
   * @param {String} value tha value to format
   * @return {String} return the value with the format applyed
   */
  descartesJS.Control.prototype.formatOutputValue = function(value) {
    parent = this.parent;

    resultValue = value+"";
    decimals = this.evaluator.eval(this.decimals);

    indexDot = resultValue.indexOf(".");
    if ( indexDot != -1 ) {
      subS = resultValue.substring(indexDot+1);

      if (subS.length > decimals) {
        resultValue = parseFloat(resultValue).toFixed(decimals);
      }
    }

    if (this.fixed) {
      // ## patch for Descartes 2 ##
      // in a version diferente to 2, then fixed stays as it should
      // if the version is 2 but do not use exponential notation
      if ( (parent.version !== 2) || ((parent.version === 2) && (!this.exponentialif)) ) {
        resultValue = parseFloat(value).toFixed(decimals);
      }
    }

    // if the value is zero then do not show the E in the exponential notation
    if ((this.exponentialif) && (parseFloat(resultValue) != 0)) {
      // ## patch for Descartes 2 ##
      // in the version 2 do not show the decimals
      if ((this.fixed) && (parent.version !== 2)) {
        resultValue = parseFloat(resultValue).toExponential(decimals);
      }
      else {
        resultValue = parseFloat(resultValue).toExponential();
      }
      resultValue = resultValue.toUpperCase().replace("+", "");
    }

    return resultValue.replace(".", parent.decimal_symbol);
  }

  /**
   *
   */
  descartesJS.Control.prototype.updateAndExecAction = function() {
    // update the controls
    this.parent.updateControls();

    // if the action is init, release the click
    if (this.action === "init") {
      this.click = false;
    }
    // execute the acction
    this.actionExec.execute();

    // update again the controls
    this.parent.updateControls();

    // if the action is animate then do not update the scene
    if (this.action !== "animate") {
      // update the scene
      this.parent.update();
    }

    // update again the controls
    this.parent.updateControls();
  }

  /**
   * Create a linear gradient for the background
   * @param {Number} w es el ancho del canvas sobre el cual se quiere crear el gradiente lineal
   * @param {Number} h es el alto del canvas sobre el cual se quiere crear el gradiente lineal
   */
  descartesJS.Control.prototype.createGradient = function(w, h) {
    this.linearGradient = this.ctx.createLinearGradient(0, 0, 0, h);
    hh = h*h;

    for (var i=0; i<h; i++) {
      di = MathFloor(i-(35*h)/100);
      this.linearGradient.addColorStop(i/h, "rgba(0,0,0,"+ ((di*di*192)/hh)/255 +")");
    }
  }
  /**
   *
   */
  descartesJS.Control.prototype.createCSSGradient = function(h) {
    var gradientStr = "linear-gradient(";
    hh = h*h;

    for (var i=0; i<h; i++) {
      di = MathFloor(i-(35*h)/100);
      gradientStr += "rgba(0,0,0,"+ ((di*di*200)/hh)/255 +") "+ (i*100/(h-1)) +"%,";
    }
    gradientStr = gradientStr.substring(0, gradientStr.length-1);

    return gradientStr + ")";
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathFloor = Math.floor;
  var MathAbs = Math.abs;

  var evaluator;
  var btn;
  var ctx;
  var expr;
  var font_size;
  var name;
  var imageSrc;
  var image;
  var despX;
  var despY;
  var txtW;
  // var hasTouchSupport;
  var delay = 1000;

  var _image_pos_x;
  var _image_pos_y;
  var _text_pos_x;
  var _text_pos_y;

  var gifPattern = /[\w\.\-//]*(\.gif)/gi;

  var container;

  var checkOver;
  var checkClick;
  var checkActive;
  var checkDrawIf;
  var checkName;
  var checkImageSrc;
  var checkBackColor;
  var checkTextColor;
  var checkImageReady;

  var prefix;
  var sufix;
  var imageOverSrc;
  var imageDownSrc;
  var imageOver;
  var imageDown;

  /**
   * Descartes button control
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the button control
   */
  descartesJS.Button = function(parent, values) {
    /**
     * image file name
     * type {String}
     * @private
     */
    this.imageSrc = "";

    /**
     * image
     * type {Image}
     * @private
     */
    this.image = new Image();

    /**
     * over image
     * type {Image}
     * @private
     */
    this.imageOver = new Image();

    /**
     * down image
     * type {Image}
     * @private
     */
    this.imageDown = new Image();

    this.flat = false;
    this.borderColor = false;
    this.text_align = "center_center";
    this.image_align = "center_center";
    this.font_family = "arial";

    // call the parent constructor
    descartesJS.Control.call(this, parent, values);

    this.font_family = descartesJS.getFontName(this.font_family);

    this.ratio = parent.ratio;

    if (this.font_size === -1) {
      this.fontSizeNotSet = true;
    }

    if (this.borderColor) {
      this.borderColor = new descartesJS.Color(this.borderColor);
    }
    this.text_align = this.text_align.split("_");
    this.image_align = this.image_align.split("_");

    // modification to change the name of the button with an expression
    if ((this.name.charAt(0) === "[") && (this.name.charAt(this.name.length-1) === "]")) {
      this.name = this.parser.parse(this.name.substring(1, this.name.length-1));
    }
    else {
      this.name = this.parser.parse("'" + this.name + "'");
    }

    var tmpParam;
    this.classContainer = (this.cssClass) ? (" " + this.cssClass+" ") : "";
    if (this.imageSrc.trim().match("^_STYLE_")) {
      this.customStyle = true;
      this.btnStyle = [];
      this.conStyle = [];
      this.conStyle.textBorder = 3;

      tmpParam = this.imageSrc.trim().substring(8).split("|");
      var tempo;
      var isRGB;
      for (var i=0, l=tmpParam.length; i<l; i++) {
        tempo = tmpParam[i];
        isRGB = tempo.match(/rgb/g);
        if (tempo.match("class=")) {
          this.classContainer = " " + tempo.substring(6);
        }
        else if (tempo.match("border=")) {
          this.btnStyle.push( { type: "border-style", value: "solid" } );
          this.btnStyle.push( { type: "border-width", value: tempo.substring(7).trim() + "px" } );
        }
        else if (tempo.match("borderRadius=")) {
          this.btnStyle.push( { type: "border-radius", value: tempo.substring(13).trim() + "px" } );
          this.conStyle.push( { type: "border-radius", value: tempo.substring(13).trim() + "px" } );
        }
        else if (tempo.match("borderColor=")) {
          this.btnStyle.push( { type: "border-color", value: ((isRGB)?"":"#") + tempo.substring(12).trim() } );
        }
        else if (tempo.match("overColor=")) {
          this.conStyle.overColor = ((isRGB)?"":"#") + tempo.substring(10).trim();
        }
        else if (tempo.match("downColor=")) {
          this.conStyle.downColor = ((isRGB)?"":"#") + tempo.substring(10).trim();
        }
        else if (tempo.match("font=")) {
          this.conStyle.font = tempo.substring(5).trim().toLowerCase();
        }
        else if (tempo.match("inactiveColor=")) {
          this.conStyle.inactiveColor = ((isRGB)?"":"#") + tempo.substring(14).trim();
        }
        else if (tempo.match("inactiveColorBorder=")) {
          this.conStyle.inactiveColorBorder = ((isRGB)?"":"#") + tempo.substring(20).trim();
        }
        else if (tempo.match("shadowTextBlur=")) {
          this.conStyle.shadowTextBlur = parseFloat(tempo.substring(15).trim());
        }
        else if (tempo.match("shadowTextOffsetX=")) {
          this.conStyle.shadowTextOffsetX = parseFloat(tempo.substring(18).trim());
        }
        else if (tempo.match("shadowTextOffsetY=")) {
          this.conStyle.shadowTextOffsetY = parseFloat(tempo.substring(18).trim());
        }
        else if (tempo.match("shadowTextColor=")) {
          this.conStyle.shadowTextColor = ((isRGB)?"":"#") + tempo.substring(16).trim();
        }
        else if (tempo.match("shadowBoxBlur=")) {
          this.conStyle.shadowBoxBlur = parseFloat(tempo.substring(14).trim());
        }
        else if (tempo.match("shadowBoxOffsetX=")) {
          this.conStyle.shadowBoxOffsetX = parseFloat(tempo.substring(17).trim());
        }
        else if (tempo.match("shadowBoxOffsetY=")) {
          this.conStyle.shadowBoxOffsetY = parseFloat(tempo.substring(17).trim());
        }
        else if (tempo.match("shadowBoxColor=")) {
          this.conStyle.shadowBoxColor = ((isRGB)?"":"#") + tempo.substring(15).trim();
        }
        else if (tempo.match("shadowInsetBoxBlur=")) {
          this.conStyle.shadowInsetBoxBlur = parseFloat(tempo.substring(19).trim());
        }
        else if (tempo.match("shadowInsetBoxOffsetX=")) {
          this.conStyle.shadowInsetBoxOffsetX = parseFloat(tempo.substring(22).trim());
        }
        else if (tempo.match("shadowInsetBoxOffsetY=")) {
          this.conStyle.shadowInsetBoxOffsetY = parseFloat(tempo.substring(22).trim());
        }
        else if (tempo.match("shadowInsetBoxColor=")) {
          this.conStyle.shadowInsetBoxColor = ((isRGB)?"":"#") + tempo.substring(20).trim();
        }
        else if (tempo.match("textBorder=")) {
          this.conStyle.textBorder = parseFloat(tempo.substring(11).trim());
        }
      }
      this.imageSrc = "vacio.gif";
    }

    // color expression of the form _COLORES_ffffff_000000_P_22 specified in the image field
    // the first color is the background color
    // the second color is the text color
    // the last number is the font size
    if (this.imageSrc.match("_COLORES_")) {
      tmpParam       = this.imageSrc.split("_");
      this.colorInt  = new descartesJS.Color(tmpParam[2]);
      this.color     = new descartesJS.Color(tmpParam[3]);
      this.font_size = this.parser.parse(tmpParam[5]);
      this.imageSrc  = "";
    }

    if (this.imageSrc.charAt(0) == '[') {
      this.imageSrc = this.parser.parse(this.imageSrc.substring(1, this.imageSrc.length-1));
    }
    else {
      this.imageSrc = this.parser.parse("'" + this.imageSrc + "'");
    }

    // if the button has an image then load it and try to load the over and down images
    var imageSrc = this.evaluator.eval(this.imageSrc).toString().trim();

    if (imageSrc != "") {
      var prefix = imageSrc.substr(0, imageSrc.lastIndexOf("."));
      var sufix  = imageSrc.substr(imageSrc.lastIndexOf("."));

      // empty image, i.e. reference to vacio.gif
      if (imageSrc.toLowerCase().match(/vacio.gif$/)) {
        this.imageSrc = this.parser.parse("'vacio.gif'");
        this.image.ready = 1;

        // ## Descartes 3 patch ##
        // if the image is empty then the name of the button is not displayed
        if (this.parent.version === 3) {
          this.name = this.parser.parse('');
        }
        // ## Descartes 3 ##

        this.emptyImage = { ready: true };
        imageSrc = this.parser.parse("'vacio.gif'");
      }
      // the image is not empty
      else {
        this.image = this.parent.getImage(imageSrc);

        // if the name is empty, do not try to get over and down images
        if (prefix) {
          this.imageOver = this.parent.getImage(prefix + "_over" + sufix);
          this.imageDown = this.parent.getImage(prefix + "_down" + sufix);
        }
      }
    }

    this.container = document.createElement("div");
    this.container.setAttribute("class", "DescartesButtonContainer" + this.classContainer);
    this.container.setAttribute("id", this.id);
    this.container.setAttribute("style", "width:" + this.w + "px; height:" + this.h + "px; left:" + this.x + "px; top:" + this.y + "px; z-index:" + this.zIndex + ";");

    // create the btn and the rendering context
    this.btn = document.createElement("canvas");
    this.btn.width  = this.w *this.ratio;
    this.btn.height = this.h *this.ratio;
    this.btn.setAttribute("style", "position:absolute; left:0; top:0; width:" + this.w +"px; height:" + this.h + "px; -webkit-box-sizing:border-box; -moz-box-sizing:border-box; box-sizing:border-box;");
    this.ctx = this.btn.getContext("2d");
    this.ctx.imageSmoothingEnabled = false;

    this.container.appendChild(this.btn);

    this.addControlContainer(this.container);

    // register the mouse and touch events
    this.addEvents();

    // init the button parameters
    this.init();
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Control
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Button, descartesJS.Control);

  /**
   * Init the button
   */
  descartesJS.Button.prototype.init = function(force) {
    evaluator = this.evaluator;
    container = this.container;
    btn = this.btn;
    ctx = this.ctx;
    expr = evaluator.eval(this.expresion);
    this.x = expr[0][0];
    this.y = expr[0][1];
    if (expr[0].length == 4) {
      this.w = parseInt(expr[0][2]);
      this.h = parseInt(expr[0][3]);
    }
    //
    btn.width  = this.w *this.ratio;
    btn.height = this.h *this.ratio;
    btn.setAttribute("style", "position:absolute; left:0; top:0; width:" + this.w +"px; height:" + this.h + "px; -webkit-box-sizing:border-box; -moz-box-sizing:border-box; box-sizing:border-box;");
    container.setAttribute("style", "width:" + this.w + "px; height:" + this.h + "px; left:" + this.x + "px; top:" + this.y + "px; z-index:" + this.zIndex + "; display:block;");
    //

    //
    if (this.btnStyle) {
      for (var i=0, l=this.btnStyle.length; i<l; i++) {
        btn.style[this.btnStyle[i].type] = this.btnStyle[i].value;
      }
    }
    if (this.conStyle) {
      for (var i=0, l=this.conStyle.length; i<l; i++) {
        container.style[this.conStyle[i].type] = this.conStyle[i].value;
      }

      if (this.conStyle.shadowBoxColor) {
        var hShadow = this.conStyle.shadowBoxOffsetX || 0;
        var wShadow = this.conStyle.shadowBoxOffsetY || 2;
        var blur = this.conStyle.shadowBoxBlur || 2;
        var spread = 1;
        container.style.boxShadow = hShadow + "px " + wShadow + "px " + blur + "px " + spread + "px " + this.conStyle.shadowBoxColor;
      }
      if (this.conStyle.shadowInsetBoxColor) {
        var hShadow = this.conStyle.shadowInsetBoxOffsetX || 0;
        var wShadow = this.conStyle.shadowInsetBoxOffsetY || -2;
        var blur = this.conStyle.shadowInsetBoxBlur || 1;
        var spread = 1;
        btn.style.boxShadow = hShadow + "px " + wShadow + "px " + blur + "px " + spread + "px " + this.conStyle.shadowInsetBoxColor + " inset";
      }
      if (this.conStyle.shadowTextColor) {
        ctx.shadowBlur = this.conStyle.shadowTextBlur || 1;
        ctx.shadowOffsetX = this.conStyle.shadowTextOffsetX || 0;
        ctx.shadowOffsetY = this.conStyle.shadowTextOffsetY || 2;
        ctx.shadowColor = this.conStyle.shadowTextColor;
      }
    }
    //

    if (this.fontSizeNotSet) {
      this.font_size = evaluator.parser.parse(descartesJS.getFieldFontSize(this.h) +"");
    }
    this.fs_evaluated = evaluator.eval(this.font_size);

    // create the background gradient
    this.createGradient(this.w, this.h);

    container.style.display = (evaluator.eval(this.drawif) > 0) ? "block" : "none";

    ////
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.lineJoin = "round";
    ctx.font = this.italics + " " + this.bold + " " + this.fs_evaluated + "px " + this.font_family;

    if (this.customStyle) {
      if (this.conStyle.font == "serif") {
        ctx.font = this.italics + " " + this.bold + " " + this.fs_evaluated + "px " + this.font_family;
      }
      else if (this.conStyle.font == "monospace") {
        ctx.font = this.italics + " " + this.bold + " " + this.fs_evaluated + "px " + descartesJS.monospace_font;
      }
    }
    // container.setAttribute("data-color", this.colorInt.getColor());
    this.draw(force);
  }

  /**
   * Update the button
   */
  descartesJS.Button.prototype.update = function() {
    evaluator = this.evaluator;
    container = this.container;
    btn = this.btn;

    // check if the control is active and visible
    this.activeIfValue = (evaluator.eval(this.activeif) > 0);
    this.drawIfValue = (evaluator.eval(this.drawif) > 0);

    var cond = (this.space) ? this.space.drawIfValue : true;

    // hide or show the button control
    if ( cond && this.drawIfValue ) {
      container.style.display = "block";
      this.draw();

      container.style.cursor = btn.style.cursor = (this.activeIfValue) ? "pointer" : "not-allowed";
      // container.setAttribute("data-active", ((this.activeIfValue) ? "true" : "false"));
 
      // update the position and size
      this.updatePositionAndSize();
    }
    else {
      container.style.display = "none";
      this.buttonClick = false;
    }
  }

  /**
   * Draw the button
   */
  descartesJS.Button.prototype.draw = function(force) {
    container = this.container;
    evaluator = this.evaluator;
    btn = this.btn;
    ctx = this.ctx;

    name = evaluator.eval(this.name);
    imageSrc = this.evaluator.eval(this.imageSrc).toString().trim();

    if (!force) {
      checkOver = (this.over === this.oldOver);
      checkClick = (this.buttonClick === this.oldButtonClick);
      checkActive = (this.activeIfValue === this.oldActiveIfValue);
      checkDrawIf = (this.drawIfValue === this.oldDrawIfValue);
      checkName = (name === this.oldName);
      checkImageSrc = (imageSrc === this.oldImageSrc);
      checkBackColor = (this.colorInt.getColor() === this.oldBackColor);
      checkTextColor = (this.color.getColor() === this.oldTextColor);
checkImageReady = (this.image.ready === this.oldImageReady);

      this.oldOver = this.over;
      this.oldButtonClick = this.buttonClick;
      this.oldActiveIfValue = this.activeIfValue;
      this.oldDrawIfValue = this.drawIfValue;
      this.oldName = name;
      this.oldImageSrc = imageSrc;
      this.oldBackColor = this.colorInt.getColor();
      this.oldTextColor = this.color.getColor();
this.oldImageReady = this.image.ready;

      if (checkOver && checkClick && checkActive && checkDrawIf && checkName && checkImageSrc && checkBackColor && checkTextColor && checkImageReady) {
        return;
      };
    }

    ctx.save();
 	  ctx.setTransform(this.ratio, 0, 0, this.ratio, 0, 0);

    font_size = this.fs_evaluated;
    container.setAttribute("data-name", name);

    if (imageSrc) {
      image = (imageSrc === "vacio.gif") ? this.emptyImage : this.parent.getImage(imageSrc);

      prefix = imageSrc.substr(0, imageSrc.lastIndexOf("."));
      sufix  = imageSrc.substr(imageSrc.lastIndexOf("."));

      imageOverSrc = prefix + "_over" + sufix;
      imageDownSrc = prefix + "_down" + sufix;
      imageOver = (imageSrc === "vacio.gif") ? this.emptyImage : this.parent.getImage(imageOverSrc);
      imageDown = (imageSrc === "vacio.gif") ? this.emptyImage : this.parent.getImage(imageDownSrc);
    }
    else {
      image = this.emptyImage;
      imageOver = this.emptyImage;
      imageDown = this.emptyImage;
    }

    ctx.clearRect(0, 0, this.w, this.h);

    // text displace when the button is pressed
    despX = despY = 0;
    if (this.buttonClick) {
      despX = despY = 1;
    }

    //////////////////////////////////////////////////////////
    // text position
    //////////////////////////////////////////////////////////
    // horizontal text align
    if (this.text_align[1] == "center") {
      _text_pos_x = MathFloor(this.w/2 + despX)-.5;
    }
    else if (this.text_align[1] == "left") {
      txtW = ctx.measureText(name).width;
      _text_pos_x = txtW/2 + 5 + despX;
    }
    else if (this.text_align[1] == "right") {
      txtW = ctx.measureText(name).width;
      _text_pos_x = this.w - txtW/2 + despX -5;
    }

    // vertical text align
    if (this.text_align[0] == "center") {
      _text_pos_y = MathFloor(this.h/2 + despY)-.5;
    }
    else if (this.text_align[0] == "top") {
      _text_pos_y = font_size/2 + despY +4;
    }
    else if (this.text_align[0] == "bottom") {
      _text_pos_y = this.h - font_size/2 + despY -3;
    }


    //////////////////////////////////////////////////////////
    // image position
    //////////////////////////////////////////////////////////
    if (image) {
      // horizontal image align
      if (this.image_align[1] == "center") {
        _image_pos_x = parseInt((this.w-image.width)/2)+despX;
      }
      else if (this.image_align[1] == "left") {
        _image_pos_x = despX;
      }
      else if (this.image_align[1] == "right") {
        _image_pos_x = this.w-image.width +despX;
      }

      // verticall image align
      if (this.image_align[0] == "center") {
        _image_pos_y = parseInt((this.h-image.height)/2)+despY;
      }
      else if (this.image_align[0] == "top") {
        _image_pos_y = despY;
      }
      else if (this.image_align[0] == "bottom") {
        _image_pos_y = this.h - image.height +despY;
      }      
    }

    ////////////////////////////////////////////////////////////////////////////////////////
    // the image is ready
    if ((image) && (image.ready)) {
      if ( (image !== this.emptyImage) && (image.complete) ) {
        // check if is a gif image
        if ( imageSrc.match(gifPattern) ) {
          this.btn.style.backgroundRepeat = "no-repeat";
          this.btn.style.backgroundImage = "url('" + imageSrc + "')";
          this.btn.style.backgroundPosition = (_image_pos_x) + "px " + (_image_pos_y) + "px";
        }
        else {
          // se dibuja el fondo, incluso con la imagen
          if ((this.image_align[0] != "center") || (this.image_align[1] != "center")) {
            container.style.backgroundColor = this.colorInt.getColor();
          }
          ctx.drawImage(image, _image_pos_x, _image_pos_y);
        }
      }
      else if ((this.emptyImage) && (this.customStyle)) {
        container.style.backgroundColor = this.colorInt.getColor();
      }
    }
    // the image is not ready or the button do not have a image
    else {
      container.style.backgroundColor = this.colorInt.getColor();

      // add the gradient and border when not flat
      if (!this.flat) {
        if (!this.buttonClick) {
          descartesJS.drawLine(ctx, this.w-1, 0, this.w-1, this.h, "rgba(0,0,0,0.5)");
          descartesJS.drawLine(ctx, 0, 0, 0, this.h, "rgba(0,0,0,0.09)");
          descartesJS.drawLine(ctx, 1, 0, 1, this.h, "rgba(0,0,0,0.03)");
        }

        ctx.fillStyle = this.linearGradient;
        ctx.fillRect(0, 0, this.w, this.h);
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////
    // over image
    if (this.activeIfValue) {
      if ( (imageOver !== this.emptyImage) && (this.over) && (imageOver.ready) && (imageOver.complete) ) {
        if ( imageOverSrc.match(gifPattern) ) {
          this.btn.style.backgroundImage = "url('" + imageOverSrc + "')";
          this.btn.style.backgroundPosition = (_image_pos_x) + "px " + (_image_pos_y) + "px";
        }
        else {
          ctx.drawImage(imageOver, _image_pos_x, _image_pos_y);
        }
      }
      else if ((this.customStyle) && (this.conStyle.overColor) && (this.over)) {
        container.style.backgroundColor = this.conStyle.overColor;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////
    // down image
    if (this.activeIfValue) {
      if ( (imageDown !== this.emptyImage) && (this.buttonClick) && (imageDown.ready) && (imageDown.complete) ) {
        // container.style.backgroundImage = "url('" + imageDownSrc + "')";
        // container.style.backgroundPosition = (_image_pos_x) + "px " + (_image_pos_y) + "px";
        if ( imageDownSrc.match(gifPattern) ) {
          this.btn.style.backgroundImage = "url('" + imageDownSrc + "')";
          this.btn.style.backgroundPosition = (_image_pos_x) + "px " + (_image_pos_y) + "px";
        }
        else {
          ctx.drawImage(imageDown, _image_pos_x, _image_pos_y);
        }
      }
      else if ((this.customStyle) && (this.conStyle.downColor) && (this.buttonClick)) {
        container.style.backgroundColor = this.conStyle.downColor;
      }
    }
    else if ((this.buttonClick) && (!image)) {
      ctx.fillStyle = "rgba(0,0,0,0.09)";
      ctx.fillRect(0, 0, this.w, this.h);
    }

    ////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////
    ctx.fillStyle = this.color.getColor();

    if (this.customStyle) {
      if ((this.conStyle.shadowTextColor) && (this.conStyle.textBorder > 0)) {
        ctx.lineWidth = this.conStyle.textBorder;
        ctx.strokeStyle = this.conStyle.shadowTextColor;
        ctx.strokeText(name, _text_pos_x, _text_pos_y);
      }
    }

    // text border
    // if ( (!newButtonCondition) && (!this.conStyle) && (this.drawTextBorder()) ) {
    //   ctx.lineWidth = parseInt(font_size/6);
    //   ctx.strokeStyle = this.colorInt.getColor();
    //   ctx.strokeText(name, _text_pos_x, _text_pos_y);
    // }
    if ( this.borderColor ) {
      ctx.lineWidth = parseInt(font_size/7);
      ctx.strokeStyle = this.borderColor.getColor();
      ctx.strokeText(name, _text_pos_x, _text_pos_y);
    }

    ////////////////////////////////////////////////////////////////////////////////////////
    // write the button name
    ctx.fillText(name, _text_pos_x, _text_pos_y);

    ////////////////////////////////////////////////////////////////////////////////////////
    // draw the under line
    if (this.underlined) {
      txtW = ctx.measureText(name).width;
      ctx.strokeStyle = this.color.getColor();
      ctx.lineWidth = MathFloor(font_size/10) || 2;
      ctx.lineCap = "round";

      ctx.beginPath();
      ctx.moveTo( _text_pos_x -txtW/2 + despX, _text_pos_y + MathFloor(font_size/2) + MathFloor(font_size/5) - 1.5 );
      ctx.lineTo( _text_pos_x +txtW/2 + despX, _text_pos_y + MathFloor(font_size/2) + MathFloor(font_size/5) - 1.5 );
      ctx.stroke();
    }

    ////////////////////////////////////////////////////////////////////////////////////////
    if (!this.activeIfValue) {
      if ((this.customStyle) && (this.conStyle.inactiveColor)) {
        container.style.backgroundColor = this.conStyle.inactiveColor;
      }
      else {
        ctx.fillStyle = "rgba(240,240,240,0.6)";
        ctx.fillRect(0, 0, this.w, this.h);
      }
    }

    ctx.restore();

    // for the screenshot
    this._image_pos_x = _image_pos_x;
    this._image_pos_y = _image_pos_y;
  }

  /**
   *
   */
  descartesJS.Button.prototype.drawTextBorder = function() {
    // compute the correct components
    this.colorInt.getColor();
    this.color.getColor();

    return !((( MathAbs(this.colorInt.r - this.color.r) + MathAbs(this.colorInt.g - this.color.g) + MathAbs(this.colorInt.b - this.color.b) )/255) <.5);
  }

  /**
   * Function executed when the button is pressed
   */
  descartesJS.Button.prototype.buttonPressed = function() {
    this.updateAndExecAction();
  }

  /**
   * Register the mouse and touch events
   */
  descartesJS.Button.prototype.addEvents = function() {
    // hasTouchSupport = descartesJS.hasTouchSupport;
    var self = this;
    var timer;

    // prevent the context menu display
    self.btn.oncontextmenu = function () { return false; };

    /**
     * Repeat a function during a period of time, when the user click and hold the click in the button
     * @param {Number} delayTime the delay of time between the function repetition
     * @param {Function} fun the function to execute
     * @param {Boolean} firstime a flag to indicated if is the first time clicked
     * @private
     */
    function repeat(delayTime, fun, firstTime) {
      descartesJS.clearTimeout(timer);

      if ((self.buttonClick) && (self.drawIfValue) && (self.activeIfValue)) {
        fun.call(self);
        delayTime = (firstTime) ? delayTime : 100;
        timer = descartesJS.setTimeout(function() { repeat(delayTime, fun, false); }, delayTime);
      }
    }

    this.buttonClick = false;
    this.over = false;

    this.btn.addEventListener("touchstart", onMouseDown);
    this.btn.addEventListener("mousedown", onMouseDown);
    this.btn.addEventListener("mouseover", onMouseOver);
    this.btn.addEventListener("mouseout", onMouseOut);

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseDown(evt) {
      // remove the focus of the controls
      // document.body.focus();
      this.focus();

      evt.preventDefault();
      evt.stopPropagation();

      // blur other elements when clicked
      if (document.activeElement != document.body) {
        document.activeElement.blur();
      }

      self.whichBtn = descartesJS.whichBtn(evt);

      if (self.whichBtn == "L") {
        if (self.activeIfValue) {
          self.buttonClick = true;

          self.draw();

          if (self.action == "calculate") {
            // se registra el valor de la variable
            self.evaluator.setVariable(self.id, self.evaluator.eval(self.valueExpr));
            repeat(delay, self.buttonPressed, true);
          }

          self.btn.removeEventListener("touchend", onMouseUp);
          self.btn.addEventListener("touchend", onMouseUp);
          self.btn.removeEventListener("mouseup", onMouseUp);
          self.btn.addEventListener("mouseup", onMouseUp);
        }
      }
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseUp(evt) {
      // needed for the save action
      descartesJS.newBlobContent = null;

      // remove the focus of the controls
      // document.body.focus();
      this.focus();

      evt.preventDefault();
      evt.stopPropagation();

      if ((self.activeIfValue) || (self.buttonClick)) {
        self.buttonClick = false;
        self.draw();

        if (self.action != "calculate") {
          // se registra el valor de la variable
          self.evaluator.setVariable(self.id, self.evaluator.eval(self.valueExpr));
          self.buttonPressed();
        }

        self.btn.removeEventListener("touchend", onMouseUp);
        self.btn.removeEventListener("mouseup", onMouseUp);
      }
      // espero que no haya errores
      self.parent.update();
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseOver(evt) {
      evt.preventDefault();
      evt.stopPropagation();

      self.over = true;
      self.draw();
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseOut(evt) {
      // needed for the save action
      descartesJS.newBlobContent = null;
      
      evt.preventDefault();
      evt.stopPropagation();

      self.over = false;
      self.buttonClick = false;
      self.draw();
    }

    /**
     *
     */
    document.addEventListener("visibilitychange", function(evt) {
      // needed for the save action
      descartesJS.newBlobContent = null;
      self.buttonClick = false;
    });

  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var evaluator;
  var tmpIncr;
  var expr;
  var oldFieldValue;
  var oldValue;
  var ctx;
  var w;
  var h;
  var c1;
  var c2;
  var triaX;
  var triaY;
  var resultValue;
  var incr;
  var decimals;
  var evalMin;
  var evalMax;
  var hasTouchSupport;
  var parseTrue;

  /**
   * Descartes spinner control
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the spinner control
   */
  descartesJS.Spinner = function(parent, values){
    // call the parent constructor
    descartesJS.Control.call(this, parent, values);

    // tabular index
    this.tabindex = ++this.parent.tabindex;

    if (this.name == "_._") {
      this.name = "";
    }

    // change the name of the button with an expression
    if ((this.name.charAt(0) === "[") && (this.name.charAt(this.name.length-1) === "]")) {
      this.name = this.parser.parse(this.name.substring(1, this.name.length-1));
    }
    else {
      this.name = this.parser.parse("'" + this.name + "'");
    }

    // control container
    this.container = document.createElement("div");
    this.canvas = document.createElement("canvas");
    this.divUp = document.createElement("div");
    this.divDown = document.createElement("div");
    this.field = document.createElement("input");

    // the label
    this.label = document.createElement("label");

    this.container.appendChild(this.label);
    this.container.appendChild(this.field);
    this.container.appendChild(this.canvas);
    this.container.appendChild(this.divUp);
    this.container.appendChild(this.divDown);

    this.addControlContainer(this.container);

    parseTrue = this.evaluator.parser.parse("1");

    // if the decimals are negative or zero
    this.originalIncr = this.incr;
    if ( (this.evaluator.eval(this.decimals) < 0) || (this.evaluator.eval(this.incr) == 0) ) {
      var tmpIncr = this.evaluator.eval(this.incr);

      if (tmpIncr > 0) {
        this.incr = this.evaluator.parser.parse(parseInt(tmpIncr).toString());
        this.originalIncr = this.incr;
      }
      else {
        this.incr = parseTrue;
      }
    }

    // register the mouse and touch events
    this.addEvents();

    // init the menu parameters
    this.init();
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Control
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Spinner, descartesJS.Control);

  /**
   * Init the spinner
   */
  descartesJS.Spinner.prototype.init = function() {
    evaluator = this.evaluator;

    var name = evaluator.eval(this.name).toString();
    this.label.innerHTML = name;

    // validate the initial value
    this.value = this.validateValue(evaluator.eval(this.valueExpr));

    // get the width of the initial value to determine the width of the text field
    var fieldValue = this.formatOutputValue(this.value);

    // find the font size of the text field
    this.fieldFontSize = (this.parent.version !== 2) ? descartesJS.getFieldFontSize(this.h) : 10;

    // extra space added to the name
    var extraSpace = (this.parent.version !== 2) ? "__" : "_____";

    var fieldValueSize = descartesJS.getTextWidth(fieldValue+"_", this.fieldFontSize+"px " + descartesJS.sansserif_font);

    // for each element calculated width
    var canvasWidth = 2 + parseInt(this.h/2);
    var labelWidth = parseInt(this.w/2 - canvasWidth/2);
    var minTFWidth = fieldValueSize;
    var minLabelWidth = descartesJS.getTextWidth(name+extraSpace, this.fieldFontSize+"px " + descartesJS.sansserif_font);

    if (!this.visible) {
      labelWidth = this.w - canvasWidth;
      minTFWidth = 0;
    }

    if (labelWidth < minLabelWidth) {
      labelWidth = minLabelWidth;
    }

    if (name == "") {
      labelWidth = 0;
    }

    if (this.w-labelWidth-canvasWidth < minTFWidth) {
      labelWidth = this.w - canvasWidth - minTFWidth;
    }

    if (labelWidth < 0) {
      labelWidth=0;
    }

    var fieldWidth = this.w - (labelWidth + canvasWidth);

    this.container.setAttribute("class", "DescartesSpinnerContainer");
    this.container.setAttribute("style", "width:" + this.w + "px;height:" + this.h + "px;left:" + this.x + "px;top:" + this.y + "px;z-index:" + this.zIndex + ";");
    this.container.setAttribute("id", this.id);

    this.canvas.setAttribute("width", canvasWidth+"px");
    this.canvas.setAttribute("height", this.h+"px");
    this.canvas.setAttribute("style", "position:absolute;left:" + labelWidth + "px;top:0;");
    this.ctx = this.canvas.getContext("2d");
    this.ctx.imageSmoothingEnabled = false;

    var divStyle = "opacity:0;cursor:pointer;position:absolute;width:" + canvasWidth + "px;height:" + this.h/2 + "px;left:" + labelWidth + "px;";
    this.divUp.setAttribute("class", "up");
    this.divUp.setAttribute("style", divStyle+"top:0;");
    this.divDown.setAttribute("class", "down");
    this.divDown.setAttribute("style", divStyle+"top:" + this.h/2 + "px;");

    this.field.setAttribute("type", "text");
    this.field.setAttribute("id", this.id+"_spinner");
    this.field.setAttribute("class", "DescartesSpinnerField");
    this.field.setAttribute("style", "font-family:" + descartesJS.sansserif_font + ";font-size:" + this.fieldFontSize + "px;width:" + fieldWidth + "px;height:" + this.h + "px;left:" + (canvasWidth + labelWidth) + "px;");
    this.field.setAttribute("tabindex", this.tabindex);
    this.field.value = fieldValue;
    if (!this.visible) {
      this.field.style.display = "none";
    }

    this.label.setAttribute("class", "DescartesSpinnerLabel");
    this.label.setAttribute("style", "font-size:" + this.fieldFontSize + "px;width:" + labelWidth + "px;height:" + this.h + "px;line-height:" + this.h + "px;");

    // register the control value
    evaluator.setVariable(this.id, this.value);

    // create the background gradient
    this.createGradient(this.h/2, this.h);

    // this.update();
  }

  /**
   * Update the spinner
   */
  descartesJS.Spinner.prototype.update = function() {
    evaluator = this.evaluator;

    this.label.innerHTML = evaluator.eval(this.name).toString();

    if (evaluator.eval(this.decimals) < 0) {
      tmpIncr = evaluator.eval(this.incr);

      if (tmpIncr > 0) {
        this.incr = evaluator.parser.parse(parseInt(tmpIncr).toString());
        this.originalIncr = this.incr;
      }
      else {
        this.incr = parseTrue;
      }
    }
    else {
      this.incr = (evaluator.eval(this.originalIncr) !== 0) ? this.originalIncr : parseTrue;
    }

    // check if the control is active and visible
    this.activeIfValue = (evaluator.eval(this.activeif) > 0);
    this.drawIfValue = (evaluator.eval(this.drawif) > 0);

    // enable or disable the control
    this.field.disabled = !this.activeIfValue;

    // hide or show the spinner control
    if (this.drawIfValue) {
      this.container.style.display = "block"
      this.draw();
    }
    else {
      this.click = false;
      this.container.style.display = "none";
    }

    // update the position and size
    this.updatePositionAndSize();

    if ( !(this.parent.animation.playing) || (document.activeElement != this.field) ) {
      oldFieldValue = this.field.value;
      oldValue = this.value;

      // update the spinner value
      this.value = this.validateValue( evaluator.getVariable(this.id) );
      this.field.value = this.formatOutputValue(this.value);

      if ((this.value == oldValue) && (this.field.value != oldFieldValue)) {
        // update the spinner value
        this.value = this.validateValue( oldFieldValue );
        this.field.value = this.formatOutputValue(this.value);
      }

      // register the control value
      evaluator.setVariable(this.id, this.value);
    }
  }

  /**
   * Draw the spinner
   */
  descartesJS.Spinner.prototype.draw = function() {
// return;
    ctx = this.ctx;

    w = this.canvas.width;
    h = this.canvas.height

    ctx.fillStyle = "#f0f8ff";
    ctx.fillRect(0, 0, w, h);

    ctx.fillStyle = this.linearGradient;
    ctx.fillRect(0, 0, w, h);

    // draw the upper lines for depth efect
    if (this.up) {
      c1 = "gray";
      c2 = "#f0f8ff";
    } else {
      c1 = "#f0f8ff";
      c2 = "gray";
    }

    descartesJS.drawLine(ctx, 0, 0, w, 0, c1);
    descartesJS.drawLine(ctx, 0, 0, 0, h/2, c1);
    descartesJS.drawLine(ctx, 0, h/2, w, h/2, c2);

    // draw the lower lines for depth efect
    if (this.down) {
      c1 = "gray";
      c2 = "#f0f8ff";
    } else {
      c1 = "#f0f8ff";
      c2 = "gray";
    }

    descartesJS.drawLine(ctx, 0, h/2+1, w, h/2+1, c1);
    descartesJS.drawLine(ctx, 0, h/2+1, 0, h, c1);
    descartesJS.drawLine(ctx, 0, h-1, w, h-1, c2);

    triaX = [parseInt(w/2+1), parseInt(w/5+1), parseInt(w-w/5+1)];
    triaY = [parseInt(h/8+1), parseInt(h/8+1+h/4), parseInt(h/8+1+h/4)];

    // draw the uper triangle
    ctx.fillStyle = (this.activeIfValue) ? "#2244cc" : "#8888aa";
    ctx.beginPath();
    ctx.moveTo(triaX[0], triaY[0]);
    ctx.lineTo(triaX[1], triaY[1]);
    ctx.lineTo(triaX[2], triaY[2]);
    ctx.fill();

    triaY = [parseInt(h-h/8), parseInt(h-h/8-h/4), parseInt(h-h/8-h/4)];

    // draw the lower triangle
    ctx.fillStyle = (this.activeIfValue) ? "#d00018" : "#aa8888";
    ctx.beginPath();
    ctx.moveTo(triaX[0], triaY[0]);
    ctx.lineTo(triaX[1], triaY[1]);
    ctx.lineTo(triaX[2], triaY[2]);
    ctx.fill();

    // draw another layer for pressed effect
    ctx.fillStyle = "rgba(0,0,0,"+ 24/255 +")";
    if (this.up) {
      ctx.fillRect(0, 0, w, h/2);
    }
    if (this.down) {
      ctx.fillRect(0, h/2, w, h);
    }
  }

  /**
   * Validate if the value is the range [min, max]
   * @param {String} value the value to validate
   * @return {Number} return the value like a number,
   *                         is greater than the upper limit then return the upper limit
   *                         is less than the lower limit then return the lower limit
   */
  descartesJS.Spinner.prototype.validateValue = function(value) {
    evaluator = this.evaluator;

    if (!isNaN(parseFloat(value))) {
      // remove the exponential notation of the number and convert it to a fixed notation
      if (value.toString().match("e")) {
        value = parseFloat(value).toFixed(20);
      }
    }
    value = (value != undefined) ? value.toString() : "0";

    var tmp = value.replace(this.parent.decimal_symbol, ".");
    if (tmp == parseFloat(tmp)) {
      resultValue = parseFloat(tmp);
    }
    else {
      resultValue = parseFloat( evaluator.eval( evaluator.parser.parse(tmp) ) );
    }

    // if the value is a string that do not represent a number, parseFloat return NaN
    if (isNaN(resultValue)) {
      resultValue = 0;
    }

    evalMin = evaluator.eval(this.min);
    evalMax = evaluator.eval(this.max);

    if (evalMin === "") {
      evalMin = -Infinity;
    }
    if (evalMax === "") {
      evalMax = Infinity;
    }

    // if is less than the lower limit or greater than the upper limit
    resultValue = Math.min( Math.max(resultValue, evalMin), evalMax );

    if (this.discrete) {
      incr = evaluator.eval(this.incr);
      resultValue = (incr == 0) ? 0 : (incr * Math.round(resultValue / incr));
    }

    decimals = evaluator.eval(this.decimals);
    if (decimals <= 0) {
      decimals = 0;
    }

    resultValue = parseFloat(parseFloat(resultValue).toFixed(decimals));

    return resultValue;
  }

  /**
   * Increase the value of the spinner
   */
  descartesJS.Spinner.prototype.increase = function() {
    this.changeValue( parseFloat(this.value) + this.evaluator.eval(this.incr) );
  }

  /**
   * Decrease the value of the spinner
   */
  descartesJS.Spinner.prototype.decrease = function() {
    this.changeValue( parseFloat(this.value) - this.evaluator.eval(this.incr) );
  }

  /**
   * Change the spinner value
   */
  descartesJS.Spinner.prototype.changeValue = function(value) {
    if (this.activeIfValue) {
      this.value = this.validateValue(value);
      this.field.value = this.formatOutputValue(this.value);

      // register the control value
      this.evaluator.setVariable(this.id, this.value);

      this.updateAndExecAction();
    }
  }

  /**
   * Register the mouse and touch events
   */
  descartesJS.Spinner.prototype.addEvents = function() {
    hasTouchSupport = descartesJS.hasTouchSupport;

    var self = this;
    var delay = (hasTouchSupport) ? 500 : 200;
    var timer;

    // prevent the context menu display
    self.divUp.oncontextmenu = self.divDown.oncontextmenu = self.field.oncontextmenu = self.label.oncontextmenu = function() { return false; };

    // prevent the default events int the label
    this.label.addEventListener("touchstart", descartesJS.preventDefault);
    this.label.addEventListener("mousedown", descartesJS.preventDefault);

    /**
     * Repeat a function during a period of time, when the user click and hold the click in the button
     * @param {Number} delayTime the delay of time between the function repetition
     * @param {Function} fun the function to execut
     * @param {Boolean} firstime a flag to indicated if is the first time clicked
     * @private
     */
    function repeat(delayTime, fun, firstTime) {
      descartesJS.clearTimeout(timer);

      if (self.up || self.down) {
        fun.call(self);
        delayTime = (firstTime) ? delayTime : 10;
        timer = descartesJS.setTimeout(function() { repeat(delayTime, fun); }, delayTime);
      }
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onKeyDown_TextField(evt) {
      // responds to enter
      if (evt.keyCode == 13) {
        self.changeValue(self.field.value);
      }
    }
    this.field.addEventListener("keydown", onKeyDown_TextField);

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseDown_UpButton(evt) {
      evt.preventDefault();

      self.whichBtn = descartesJS.whichBtn(evt);

      if (self.whichBtn == "L") {
        if (self.activeIfValue) {
          self.up = true;
          repeat(delay, self.increase, true);
          self.draw();
        }
      }
    }

    this.divUp.addEventListener("touchstart", onMouseDown_UpButton);
    this.divUp.addEventListener("mousedown", onMouseDown_UpButton);

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseDown_DownButton(evt) {
      evt.preventDefault();

      self.whichBtn = descartesJS.whichBtn(evt);

      if (self.whichBtn == "L") {
        if (self.activeIfValue) {
          self.down = true;
          repeat(delay, self.decrease, true);
          self.draw();
        }
      }
    }

    this.divDown.addEventListener("touchstart", onMouseDown_DownButton);
    this.divDown.addEventListener("mousedown", onMouseDown_DownButton);

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseOut_UpButton(evt) {
      self.up = false;
      descartesJS.clearTimeout(timer);
      self.draw();
      evt.preventDefault();
    }

    this.divUp.addEventListener("mouseout", onMouseOut_UpButton);

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseOut_DownButton(evt) {
      self.down = false;
      descartesJS.clearTimeout(timer);
      self.draw();
      evt.preventDefault();
    }

    this.divDown.addEventListener("mouseout", onMouseOut_DownButton);

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseUp_UpButton(evt) {
      self.up = false;
      descartesJS.clearTimeout(timer);
      self.draw();
      // evt.preventDefault();
    }

    this.divUp.addEventListener("touchend", onMouseUp_UpButton);
    window.addEventListener("touchend", onMouseUp_UpButton);
    this.divUp.addEventListener("mouseup", onMouseUp_UpButton);
    window.addEventListener("mouseup", onMouseUp_UpButton);

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseUp_DownButton(evt) {
      self.down = false;
      descartesJS.clearTimeout(timer);
      self.draw();
      // evt.preventDefault();
    }

    this.divDown.addEventListener("touchend", onMouseUp_DownButton);
    window.addEventListener("touchend", onMouseUp_DownButton);
    this.divDown.addEventListener("mouseup", onMouseUp_DownButton);
    window.addEventListener("mouseup", onMouseUp_DownButton);

    /**
     *
     */
    document.addEventListener("visibilitychange", function(evt) {
      self.up = false;
      self.down = false;
      descartesJS.clearTimeout(timer);
      self.draw();
    });

    /**
     * Prevent an error with the focus of a text field
     */
    self.field.addEventListener("click", function(evt) {
      this.select();
      this.focus();
    });
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var evaluator;

  var Checkbox = (function() {
    /**
     * Descartes checkbox control
     * @constructor
     * @param {DescartesApp} parent the Descartes application
     * @param {String} values the values of the checkbox control
     */
    function Checkbox(parent, values){
      var self = this;

      self.radio_group = "";
      self.typeCtr = "checkbox";
      self.pressed = false;

      // call the parent constructor
      descartesJS.Control.call(self, parent, values);

      // checkbox or radiobutton
      self.radio_group = self.radio_group.trim();
      if (self.radio_group !== "") {
        self.typeCtr = "radio";
      }

      // modification to change the name of the Checkbox with an expression
      if ((self.name.charAt(0) === "[") && (self.name.charAt(self.name.length-1) === "]")) {
        self.name = self.parser.parse(self.name.substring(1, self.name.length-1));
      }
      else {
        self.name = self.parser.parse("'" + self.name.trim() + "'");
      }

      // tabular index
      self.tabindex = ++self.parent.tabindex;

      // control container
      self.containerControl = document.createElement("div");

      // the checkbox
      self.checkbox = document.createElement("input");
      self.checkbox.setAttribute("type", self.typeCtr);
      if (self.radio_group !== "") {
        self.checkbox.setAttribute("name", self.radio_group);
      }
      self.checkbox.internalID = this.id;
        
      // the label
      self.label = document.createElement("label");

      // the dummyLabel
      self.dummyLabel = document.createElement("label");

      self.value = self.evaluator.eval(self.valueExpr);

      // add the elements to the container
      self.containerControl.appendChild(self.label);
      self.containerControl.appendChild(self.checkbox);
      self.containerControl.appendChild(self.dummyLabel);

      self.addControlContainer(self.containerControl);

      // register the mouse and touch events
      self.addEvents();

      self.init();
    };

    ////////////////////////////////////////////////////////////////////////////////////
    // create an inheritance of Control
    ////////////////////////////////////////////////////////////////////////////////////
    descartesJS.extend(Checkbox, descartesJS.Control);

    /**
     * Init the checkbox
     */
    Checkbox.prototype.init = function(changeSizePos) {
      var self = this;
      evaluator = self.evaluator;

      self.label.innerHTML = evaluator.eval(self.name).toString();

      // find the font size of the checkbox
      self.labelFontSize = descartesJS.getFieldFontSize(self.h);
      var labelWidth = Math.max(self.w - self.h, 0);

      self.containerControl.setAttribute("class", "DescartesCheckboxContainer");
      self.containerControl.setAttribute("style", "width: " + self.w + "px; height: " + self.h + "px; left: " + self.x + "px; top: " + self.y + "px; z-index: " + self.zIndex + ";");

      self.dummyLabel.setAttribute("style", "position:absolute; width : " + self.h + "px; height : " + self.h + "px; left: " + labelWidth + "px;");
      self.dummyLabel.setAttribute("for", self.id+self.typeCtr);

      self.checkbox.setAttribute("type", self.typeCtr);
      self.checkbox.setAttribute("id", self.id+self.typeCtr);
      self.checkbox.setAttribute("class", "DescartesCheckbox");
      self.checkbox.setAttribute("style", "width : " + self.h + "px; height : " + self.h + "px; left: " + labelWidth + "px;");
      self.checkbox.setAttribute("tabindex", self.tabindex);
      self.checkbox.checked = (self.value != 0);

      self.label.setAttribute("class", "DescartesCheckboxLabel");
      self.label.setAttribute("style", "font-size:" + self.labelFontSize + "px; width: " + labelWidth + "px; height: " + self.h + "px; line-height: " + self.h + "px;");
      
      // register the control value
      self.evaluator.setVariable(self.id, self.value);
     
      self.update();
    };

    /**
     * Update the checkbox
     */
    Checkbox.prototype.update = function() {
      var self = this;
      evaluator = self.evaluator;

      self.label.innerHTML = evaluator.eval(self.name).toString();

      // check if the control is active and visible
      self.activeIfValue = (evaluator.eval(self.activeif) > 0);
      self.drawIfValue = (evaluator.eval(self.drawif) > 0);

      // enable or disable the control
      self.checkbox.disabled = !self.activeIfValue;

      // hide or show the checkbox control
      self.containerControl.style.display = (self.drawIfValue) ? "block" : "none";

      if ( !(self.parent.animation.playing) || (document.activeElement != self.checkbox)) {
        var oldVal = (evaluator.getVariable(self.id) !== 0) ? 1 : 0;
        
        // update the checkbox value
        if (self.radio_group === "") {
          if (self.pressed) {
            self.value = (self.checkbox.checked) ? 1 : 0;
            self.pressed = false;
          }
          else {
            self.value = oldVal;
            self.checkbox.checked = (self.value !== 0);
          }
        }
        // update the radiobutton value
        else {
          self.value = (self.checkbox.checked) ? 1 : 0;
          if (self.pressed) {
            evaluator.setVariable(self.radio_group, self.id);
            self.pressed = false;
          }
          
          // if (self.pressed) {
            // var radios = document.querySelectorAll("[name="+self.radio_group+"]");
            // for (var i=radios.length-1; i>=0; i--) {
            //   evaluator.setVariable(radios[i].internalID, 0);
            // }
            // self.value = 1;
            // self.pressed = false;
          // }
          // else {
          //   self.value = oldVal;
          //   self.checkbox.checked = (self.value !== 0);
          //   var radios = document.querySelectorAll("[name="+self.radio_group+"]");
          //   for (var i=radios.length-1; i>=0; i--) {
          //     if (radios[i].checked === false) {
          //       evaluator.setVariable(radios[i].internalID, 0);
          //     }
          //   }
          // }
        }

        // register the control value
        evaluator.setVariable(self.id, self.value);
      }

      // update the position and size
      self.updatePositionAndSize();
    }

    /**
     * Register the mouse and touch events
     */
    Checkbox.prototype.addEvents = function() {
      var self = this;

      // prevent the context menu display
      self.checkbox.oncontextmenu = self.label.oncontextmenu = self.dummyLabel.oncontextmenu = function() { return false; };

      // prevent the default events int the label
      self.label.addEventListener("touchstart", descartesJS.preventDefault);
      self.label.addEventListener("mousedown", descartesJS.preventDefault);
      self.dummyLabel.addEventListener("touchstart", descartesJS.preventDefault);
      self.dummyLabel.addEventListener("mousedown", descartesJS.preventDefault);

      /*
      * Prevent an error with the focus of a checkbox
      */
      self.checkbox.addEventListener("click", function(evt) {
        self.pressed = true;
        self.updateAndExecAction();
      });
    }

    return Checkbox;
  })();
  descartesJS.Checkbox = Checkbox;

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var evaluator;
  var oldFieldValue;
  var oldValue;
  var resultValue;
  var decimals;
  var indexDot;
  var value;
  var limInf;
  var limSup;
  var cond1;
  var cond2;
  var cond3;
  var cond4;
  var answer_i_0;
  var answer_i_1;
  var tmpValue;
  var tmpAnswer;
  var regExpPattern;
  var answerValue;
  var evalMin;
  var evalMax;

  var hasTouchSupport;

  /**
   * Descartes text field control
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the text field control
   */
  descartesJS.TextField = function(parent, values){
    // call the parent constructor
    descartesJS.Control.call(this, parent, values);

    // modification to change the name of the textfield with an expression
    if ((this.name.charAt(0) === "[") && (this.name.charAt(this.name.length-1) === "]")) {
      this.name = this.parser.parse(this.name.substring(1, this.name.length-1));
    }
    else {
      this.name = this.parser.parse("'" + this.name.trim() + "'");
    }

    if (this.valueExprString === undefined) {
      if (this.onlyText) {
        this.valueExprString = '0';
      }
      else {
        this.valueExprString = "";
      }
    }

    // an empty string
    this.emptyString = false;

    // the evaluation of the control
    this.ok = 0;

    // tabular index
    this.tabindex = ++this.parent.tabindex;

    this.regExpDecimalSymbol = new RegExp("\\" + this.parent.decimal_symbol, "g");

    // if the answer exist
    if (this.answer) {
      // the answer is encrypted
      if (this.answer.match("krypto_")) {
        var krypt = new descartesJS.Krypto();
        this.answer = krypt.decode(this.answer.substring(7));
      }
      this.answerPattern = this.answer;

      this.answer = descartesJS.buildRegularExpresionsPatterns(this.answer, this.evaluator);

      if (this.onlyText) {
        // find the first answer pattern
        var sepIndex = this.answerPattern.indexOf("|");
        this.firstAnswer = (sepIndex == -1) ? this.answerPattern : this.answerPattern.substring(0, sepIndex);
      } else {
        // find the minimum value of the first interval of a numeric answer pattern
        this.firstAnswer = this.parser.parse( this.answerPattern.substring(1, this.answerPattern.indexOf(",")) );
      }
    }

    // if the text field is only text, then the value has to fulfill the validation norms
    if (this.onlyText) {
      if ( !(this.valueExprString.match(/^'/)) || !(this.valueExprString.match(/'$/)) ) {
        this.valueExpr = this.evaluator.parser.parse( "'" + this.valueExprString + "'" );
      }

      /**
       * validate value for a only text control
       */
      this.validateValue = function(value) {
        value = value.toString();
        if ( (value == "''") || (value == "'") ) {
          return "";
        }

        if ((value) && value.match(/^'/) && value.match(/'$/)) {
          return value.substring(1,value.length-1);
        }

        return value;
      }
      this.formatOutputValue = function(value) {
        return value.toString();
      }
    }

    // if the name is only white spaces
    if (name.trim() == "") {
      name = "";
    }

    // control container
    this.containerControl = document.createElement("div");

    // the text field
    this.field = document.createElement("input");

    // the label
    this.label = document.createElement("label");

    // add the elements to the container
    this.containerControl.appendChild(this.label);
    this.containerControl.appendChild(this.field);

    this.addControlContainer(this.containerControl);

    // register the mouse and touch events
    this.addEvents();

    this.init();
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Control
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.TextField, descartesJS.Control);

  /**
   * Init the text field
   */
  descartesJS.TextField.prototype.init = function(changeSizePos) {
    evaluator = this.evaluator;

    var name = evaluator.eval(this.name).toString();
    this.label.innerHTML = name;

    // validate the initial value
    if (!changeSizePos) {
      this.value = this.validateValue( evaluator.eval(this.valueExpr) );
    }

    // get the width of the initial value to determine the width of the text field
    var fieldValue = this.formatOutputValue(this.value);

    // find the font size of the text field
    this.fieldFontSize = descartesJS.getFieldFontSize(this.h);

    var fieldValueSize = descartesJS.getTextWidth(fieldValue+"_", this.fieldFontSize+"px " + descartesJS.sansserif_font);

    // widths are calculated for each element
    var labelWidth = parseInt(this.w/2);
    var minTFWidth = fieldValueSize;
    var minLabelWidth = descartesJS.getTextWidth(name, this.fieldFontSize+"px " + descartesJS.sansserif_font);

    if (!this.visible) {
      labelWidth = this.w;
      minTFWidth = 0;
    }

    if (labelWidth < minLabelWidth) {
      labelWidth = minLabelWidth;
    }

    if (name == "") {
      labelWidth = 0;
    }

    if (this.w-labelWidth < minTFWidth) {
      labelWidth = this.w - minTFWidth;
    }

    if (labelWidth < 0) {
      labelWidth=0;
    }

    var fieldWidth = this.w - (labelWidth);

    this.containerControl.setAttribute("class", "DescartesTextFieldContainer");
    this.containerControl.setAttribute("style", "width: " + this.w + "px; height: " + this.h + "px; left: " + this.x + "px; top: " + this.y + "px; z-index: " + this.zIndex + ";");

    this.field.setAttribute("type", "text");
    this.field.setAttribute("id", this.id+"TextField");
    this.field.setAttribute("class", "DescartesTextFieldField");
    this.field.setAttribute("style", "font-size: " + this.fieldFontSize + "px; width : " + fieldWidth + "px; height : " + this.h + "px; left: " + labelWidth + "px;");
    this.field.setAttribute("tabindex", this.tabindex);
    this.field.value = fieldValue;

    this.label.setAttribute("class", "DescartesTextFieldLabel");
    this.label.setAttribute("style", "font-size:" + this.fieldFontSize + "px; width: " + labelWidth + "px; height: " + this.h + "px; line-height: " + this.h + "px;");

    // if the text field evaluates, get the ok value
    if (this.evaluate) {
      this.ok = this.evaluateAnswer();
    }

    // register the control value
    this.evaluator.setVariable(this.id, this.value);
    this.evaluator.setVariable(this.id+".ok", this.ok);

    this.oldValue = this.value;

    this.update();
  }

  /**
   * Update the text field
   */
  descartesJS.TextField.prototype.update = function() {
    evaluator = this.evaluator;

    this.label.innerHTML = evaluator.eval(this.name).toString();

    // check if the control is active and visible
    this.activeIfValue = (evaluator.eval(this.activeif) > 0);
    this.drawIfValue = (evaluator.eval(this.drawif) > 0);

    // enable or disable the control
    this.field.disabled = !this.activeIfValue;

    // hide or show the text field control
    if (this.drawIfValue) {
      this.containerControl.style.display = "block";
    } else {
      this.containerControl.style.display = "none";
    }

    if ( !(this.parent.animation.playing) || (document.activeElement != this.field)) {
      oldFieldValue = this.field.value;
      oldValue = this.value;

      // update the text field value
      this.value = this.validateValue( evaluator.getVariable(this.id) );
      this.field.value = this.formatOutputValue(this.value);

      if ((this.value === oldValue) && (this.field.value != oldFieldValue)) {
        // update the spinner value
        this.value = this.validateValue( oldFieldValue );
        this.field.value = this.formatOutputValue(this.value);
      }

      // register the control value
      evaluator.setVariable(this.id, this.value);
    }

    // update the position and size
    this.updatePositionAndSize();
  }

  /**
   * Validate if the value is in the range [min, max]
   * @param {String} value the value to validate
   * @return {Number} return the value like a number,
   *                         is greater than the upper limit then return the upper limit
   *                         is less than the lower limit then return the lower limit
   */
  descartesJS.TextField.prototype.validateValue = function(value) {
    // if the value is an empty text
    if ((value === "") || (value == "''")) {
      return "";
    }

    evaluator = this.evaluator;

    var tmp = value.toString().replace(this.regExpDecimalSymbol, ".", "g");
    if (tmp == parseFloat(tmp)) {
      resultValue = parseFloat(tmp);
    }
    else {
      resultValue = parseFloat( evaluator.eval( evaluator.parser.parse(tmp) ) );
    }

    // if the value is a string that do not represent a number, parseFloat return NaN
    if (isNaN(resultValue)) {
      resultValue = 0;
    }

    evalMin = evaluator.eval(this.min);
    evalMax = evaluator.eval(this.max);
    
    if (evalMin === "") {
      evalMin = -Infinity;
    }
    evalMax = evaluator.eval(this.max);
    if (evalMax === "") {
      evalMax = Infinity;
    }

    // if is less than the lower limit
    if (resultValue < evalMin) {
      resultValue = evalMin;
    }

    // if si greater than the upper limit
    if (resultValue > evalMax) {
      resultValue = evalMax;
    }

    if (this.discrete) {
      var incr = evaluator.eval(this.incr);
      resultValue = (incr === 0) ? 0 : (incr * Math.round(resultValue / incr));
    }

    resultValue = parseFloat(parseFloat(resultValue).toFixed(evaluator.eval(this.decimals)));

    return resultValue;
  }

  /**
   * Format the value with the number of decimals, the exponential representation and the decimal symbol
   * @param {String} value tha value to format
   * @return {String} return the value with the format applyed
   */
  descartesJS.TextField.prototype.formatOutputValue = function(value) {
    if (value === "") {
      return "";
    }

    // call the draw function of the father (uber instead of super as it is reserved word)
    return this.uber.formatOutputValue.call(this, value);
  }

  /**
   * Change the text field value
   * @param {String} value is the new value to update the text field
   * @param {Boolean} update is a condition to update the parent or not
   */
  descartesJS.TextField.prototype.changeValue = function(value, update) {
    if (this.activeIfValue) {
      this.value = this.validateValue(value);
      this.field.value = this.formatOutputValue(this.value);

      // if the text field evaluates, get the ok value
      if (this.evaluate) {
        this.ok = this.evaluateAnswer();
      }

      // register the control value
      this.evaluator.setVariable(this.id, this.value);
      this.evaluator.setVariable(this.id+".ok", this.ok);

      this.updateAndExecAction();
    }
  }

  /**
   * @return
   */
  descartesJS.TextField.prototype.evaluateAnswer = function() {
    return descartesJS.esCorrecto(this.answer, this.value, this.evaluator, this.answer);
  }

  /**
   * @return
   */
  descartesJS.TextField.prototype.getFirstAnswer = function() {
    // if the text field has an answer pattern
    if (this.answer) {
      // if the text field is only text
      if (this.onlyText) {
        return this.firstAnswer;
      }
      // if the text field is numeric
      else {
        return this.evaluator.eval(this.firstAnswer);
      }
    }
    // if the text field has not an answer pattern
    else {
      return "";
    }
  }

  /**
   * Register the mouse and touch events
   */
  descartesJS.TextField.prototype.addEvents = function() {
    hasTouchSupport = descartesJS.hasTouchSupport;

    var self = this;

    // prevent the context menu display
    self.field.oncontextmenu = self.label.oncontextmenu = function() { return false; };

    // prevent the default events int the label
    self.label.addEventListener("touchstart", descartesJS.preventDefault);
    self.label.addEventListener("mousedown", descartesJS.preventDefault);

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onBlur_textField(evt) {
      // self.update();
      if (self.evaluator.eval(self.drawIf)) {
        self.changeValue(self.field.value, true);
      }
    }
    this.field.addEventListener("blur", onBlur_textField);

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onKeyDown_TextField(evt) {
      if (self.activeIfValue) {
        // responds to enter
        if (evt.keyCode == 13) {
          self.changeValue(self.field.value, true);
        }
      }
    }
    this.field.addEventListener("keydown", onKeyDown_TextField);

    /*
     * Prevent an error with the focus of a text field
     */
    self.field.addEventListener("click", function(evt) {
      this.select();
      this.focus();
    });
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathAbs = Math.abs;

  var parser;
  var evaluator;

  var expr
  var val;
  var tempInd;
  var diff;
  var rest;
  var resultValue;
  var decimals;
  var indexDot;
  var subS;
  var hasTouchSupport;

  var closeBracket;
  var tmpText;
  var pos;
  var lastPos;
  var ignoreSquareBracket;
  var charAt;
  var charAtAnt;

  /**
   * Descartes menu control
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the menu control
   */
  descartesJS.Menu = function(parent, values) {
    this.options = "";

    // call the parent constructor
    descartesJS.Control.call(this, parent, values);

    parser = this.parser;
    evaluator = this.evaluator;

    // the evaluation of the control
    this.ok = 0;

    // tabular index
    this.tabindex = ++this.parent.tabindex;

    // if the answer exist
    if (this.answer) {
      // the answer is encrypted
      if (this.answer.match("krypto_")) {
        var krypt = new descartesJS.Krypto();
        this.answer = krypt.decode(this.answer.substring(7));
      }

      this.answer = parseInt(this.answer.split(",")[0].replace("[", "")) || 0;
    }

    // modification to change the name of the button with an expression
    if ((this.name.charAt(0) === "[") && (this.name.charAt(this.name.length-1) === "]")) {
      this.name = this.parser.parse(this.name.substring(1, this.name.length-1));
    }
    else {
      this.name = this.parser.parse("'" + this.name + "'");
    }

    var self = this;
    this.evaluator.setFunction(this.id + ".setOptions", setOptions);
    /**
     * Auxiliar function to set the optios to the menu
     */
    function setOptions(options) {
      // options are separated using the comma as separator
      self.options = options.split(",");
      self.menuOptions = [];
      self.strValue = [];

      var splitOption;

      // parse the options
      for (var i=0, l=self.options.length; i<l; i++) {

        // split the options if has values with square backets (option[value])
        splitOption = self.customSplit(self.options[i]);

        // if divide the option only has a value, then are not specifying its value and take the order in which it appears
        if (splitOption.length == 1) {
          self.menuOptions.push( splitOption[0] );
          self.strValue.push( i.toString() );
        }
        // if divide the option has two values, then has a value specified
        else if (splitOption.length == 2) {
          self.menuOptions.push( splitOption[0] );

          // if the value is an empty string, then asign the order value
          if (splitOption[1] == "") {
            self.strValue.push( i.toString() );
          }
          // if not, then use te especified value
          else {
            self.strValue.push(splitOption[1]);
          }
        }
      }

      for (var i=0, l=self.menuOptions.length; i<l; i++) {
        // is an expression
        if ( (self.menuOptions[i].match(/^\[/)) && (self.menuOptions[i].match(/\]$/)) ) {
          self.menuOptions[i] = parser.parse( self.menuOptions[i].substring(1, self.menuOptions[i].length-1) );
        }
        // is a string
        else {
          self.menuOptions[i] = parser.parse( "'" + self.menuOptions[i] + "'" );
        }
      }

      // parse the option values
      for (var i=0, l=self.strValue.length; i<l; i++) {
        if ( (self.strValue[i].match(/^\[/)) && (self.strValue[i].match(/\]$/)) ) {
          self.strValue[i] = parser.parse( self.strValue[i].substring(1, self.strValue[i].length-1) );
        }
        else {
          self.strValue[i] = parser.parse( self.strValue[i] );
        }
      }

      // remove all the previous options
      while (self.select.firstChild) {
        self.select.removeChild(self.select.firstChild);
      }

      // add the options to the menu
      var opt;
      for (var i=0, l=self.menuOptions.length; i<l; i++) {
        opt = document.createElement("option");
        opt.innerHTML = evaluator.eval( self.menuOptions[i] );
        self.select.appendChild(opt);
      }

      return 0;
    }

    // control container
    this.containerControl = document.createElement("div");

    // the label
    this.label = document.createElement("label");

    // the menu
    this.select = document.createElement("select");

    // the text field
    this.field = document.createElement("input");

    //
    setOptions(this.options);
    //

    // add the elements to the container
    this.containerControl.appendChild(this.label);
    this.containerControl.appendChild(this.select);

    // if visible then show the text field
    if (this.visible) {
      this.containerControl.appendChild(this.field);
    }

    this.addControlContainer(this.containerControl);

    // register the mouse and touch events
    this.addEvents();

    // init the menu parameters
    this.init();
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Control
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Menu, descartesJS.Control);

  /**
   * Init the menu
   */
  descartesJS.Menu.prototype.init = function(noupdate) {
    evaluator = this.evaluator;

    var name = evaluator.eval(this.name).toString();
    this.label.innerHTML = name;

    // find the font size of the text field
    this.fieldFontSize = (this.parent.version != 2) ? descartesJS.getFieldFontSize(this.h) : 10;

    var minchw = 0;
    var indMinTFw = 0;
    var minTFw = 0;
    var mow;
    this.value = (noupdate) ? this.value : evaluator.eval(this.valueExpr);
    this.indexValue = this.getIndex(this.value);

    // find the widest choice to set the menu width
    for (var i=0, l=this.menuOptions.length; i<l; i++) {
      mow = descartesJS.getTextWidth( evaluator.eval(this.menuOptions[i]).toString(), this.fieldFontSize+"px " + descartesJS.sansserif_font );
      if (mow > minchw) {
        minchw = mow;
        indMinTFw = i;
      }
    }

    minchw += 25;
    minTFw = descartesJS.getTextWidth( this.formatOutputValue(evaluator.eval(this.strValue[indMinTFw])), this.fieldFontSize+"px " + descartesJS.sansserif_font ) + 7;

    var labelWidth = descartesJS.getTextWidth(name, this.fieldFontSize+"px " + descartesJS.sansserif_font) +10;
    var fieldWidth = minTFw;

    if (name == "") {
      labelWidth = 0;
    }
    if (!this.visible) {
      fieldWidth = 0;
    }
    var chw = this.w - fieldWidth - labelWidth;
    while (chw<minchw && labelWidth>0) {
      labelWidth--;
      chw++;
    }
    while (chw<minchw && fieldWidth>0) {
      fieldWidth--;
      chw++;
    }
    while (labelWidth+chw+fieldWidth+1<this.w) {
      chw++;
      fieldWidth++;
    }
    var chx = labelWidth;
    var TFx = chx + chw;
    fieldWidth = this.w - TFx;

    var fieldValue = this.formatOutputValue( evaluator.eval(this.strValue[this.indexValue]) );

    this.containerControl.setAttribute("class", "DescartesMenuContainer");
    this.containerControl.setAttribute("style", "width: " + this.w + "px; height: " + this.h + "px; left: " + this.x + "px; top: " + this.y + "px; z-index:" + this.zIndex + ";");

    this.label.setAttribute("class", "DescartesMenuLabel");
    this.label.setAttribute("style", "font-size:" + this.fieldFontSize + "px; width:" + labelWidth + "px; height:" + this.h + "px; line-height:" + this.h + "px;");

    this.field.setAttribute("type", "text");
    this.field.setAttribute("id", this.id+"_menuField");
    this.field.value = fieldValue;

    this.field.setAttribute("class", "DescartesMenuField");
    this.field.setAttribute("style", "font-size: " + this.fieldFontSize + "px; width: " + fieldWidth + "px; height: " + this.h + "px; left:" + TFx + "px;");
    this.field.setAttribute("tabindex", this.tabindex);

    this.select.setAttribute("id", this.id+"_menuSelect");
    this.select.setAttribute("class", "DescartesMenuSelect");
    this.select.setAttribute("style", "text-align:left; font-size:" + this.fieldFontSize + "px; width: " + chw + "px; height: " + this.h + "px; left: " + chx + "px;");
    this.select.setAttribute("tabindex", this.tabindex);
    this.select.selectedIndex = this.indexValue;

    // register the control value
    evaluator.setVariable(this.id, parseFloat(fieldValue.replace(this.parent.decimal_symbol, ".")));

    this.update();
  }

  /**
   * Update the menu
   */
  descartesJS.Menu.prototype.update = function() {
    evaluator = this.evaluator;

    // check if the control is active and visible
    this.activeIfValue = (evaluator.eval(this.activeif) > 0);
    this.drawIfValue = (evaluator.eval(this.drawif) > 0);

    // enable or disable the control
    this.field.disabled = (this.activeIfValue) ? false : true;
    this.select.disabled = (this.activeIfValue) ? false : true;

    // hide or show the menu control
    if (this.drawIfValue) {
      this.containerControl.style.display = "block";
    } else {
      this.click = false;
      this.containerControl.style.display = "none";
    }

    if ( !(this.parent.animation.playing) || (document.activeElement != this.select) ) {
      this.label.innerHTML = evaluator.eval(this.name).toString();

      for (var i=0, l=this.menuOptions.length; i<l; i++) {
        this.select.options[i].innerHTML = evaluator.eval( this.menuOptions[i] );
      }

      // update the value of the menu
      this.value = evaluator.getVariable(this.id);

      if (isNaN(this.value)) {
        this.value = 0;
      }
      this.field.value = this.formatOutputValue(this.value);

      // register the control value
      evaluator.setVariable(this.id, parseFloat(this.value));
      this.select.selectedIndex = parseFloat(this.getIndex(this.value));
    }

    this.ok = (this.value == this.answer) ? 1 : 0;
    this.evaluator.setVariable(this.id+".ok", this.ok);

    // update the position and size
    this.updatePositionAndSize();
  }

  /**
   *
   */
  descartesJS.Menu.prototype.customSplit = function(op) {
    closeBracket = false;
    tmpText = "";
    pos = 0;
    lastPos = 0;
    ignoreSquareBracket = -1;

    while (pos < op.length) {
      charAt = op.charAt(pos);
      charAtAnt = op.charAt(pos-1);

      // find a open square bracket
      if ((charAt === "[") && (ignoreSquareBracket === -1)) {
        if ((closeBracket) || (tmpText != "")) {
          tmpText += "¦";
        }

        lastPos = pos;
        ignoreSquareBracket++;

      }
      else if (charAt === "[") {
        ignoreSquareBracket++;
      }

      // if find a close square bracket add the strin +'
      else if ((charAt === "]") && (ignoreSquareBracket === 0)) {
        closeBracket = true;
        lastPos = pos+1;
        ignoreSquareBracket--;
      }

      else if (op.charAt(pos) == "]") {
        ignoreSquareBracket = (ignoreSquareBracket < 0) ? ignoreSquareBracket : ignoreSquareBracket-1;
      }

      tmpText = tmpText + op.charAt(pos);

      pos++;
    }

    return tmpText.split("¦");
  }

  /**
   * Get the selected index
   * @param {String} val the value to find the index
   * @return {Number} return the index asociated to the value
   */
  descartesJS.Menu.prototype.getIndex = function(val) {
    val = parseFloat( (val.toString()).replace(this.parent.decimal_symbol, ".") );
    tempInd = -1;
    diff = Infinity;

    for (var i=0, l=this.strValue.length; i<l; i++) {
      rest = MathAbs( val - parseFloat( this.evaluator.eval(this.strValue[i])) );

      if (rest <= diff) {
        diff = rest;
        tempInd = i;
      }
    }

    return tempInd;
  }

  /**
   * Change the menu value
   */
  descartesJS.Menu.prototype.changeValue = function() {
    if (this.activeIfValue) {
      // register the control value
      this.evaluator.setVariable(this.id, this.value);

      this.updateAndExecAction();
    }
  }

  /**
   * Register the mouse and touch events
   */
  descartesJS.Menu.prototype.addEvents = function() {
    hasTouchSupport = descartesJS.hasTouchSupport;

    var self = this;

    // prevent the context menu display
    self.select.oncontextmenu = self.label.oncontextmenu = self.field.oncontextmenu = function() { return false; };

    self.label.addEventListener("touchstart", descartesJS.preventDefault)
    self.label.addEventListener("mousedown", descartesJS.preventDefault)

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onChangeSelect(evt) {
      self.value = self.evaluator.eval( self.strValue[this.selectedIndex] );
      self.field.value = self.formatOutputValue(self.value);
      self.evaluator.setVariable(self.id, self.field.value);

      self.changeValue();

      evt.preventDefault();
    }
    this.select.addEventListener("change", onChangeSelect);

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onKeyDown_TextField(evt) {
      // responds to enter
      if (evt.keyCode == 13) {
        self.indexValue = self.getIndex(self.field.value);

        self.value = self.evaluator.eval( self.strValue[self.indexValue] );
        self.field.value = self.formatOutputValue(self.indexValue);
        self.select.selectedIndex = self.indexValue;

        self.changeValue();
      }
    }
    this.field.addEventListener("keydown", onKeyDown_TextField);

    /*
     * Prevent an error with the focus of a text field
     */
    self.field.addEventListener("click", function(evt) {
      // this.select();
      this.focus();
    });
    // self.select.addEventListener("mouse", function(evt) {
    //   this.focus();
    // });
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathFloor = Math.floor;

  var HORIZONTAL = "h";
  var VERTICAL = "v";

  var evaluator;
  var self;
  var fieldValue;
  var expr;
  var ctx;
  var tmpH;
  var tmpW;
  var desp;
  var tmpPos;
  var smw;
  var resultValue;
  var incr;
  var decimals;
  var indexDot;
  var subS;
  var newValue;
  var limInf;
  var limSup;
  var min;
  var max;
  var name;
  // var hasTouchSupport;

  var tmpContainer;
  var boundingRect;
  var tmpDisplay;
  var pos;

  /**
   * Descartes scrollbar control
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the scrollbar control
   */
  descartesJS.Scrollbar = function(parent, values){
    // call the parent constructor
    descartesJS.Control.call(this, parent, values);

    // modification to change the name of the button with an expression
    if ((this.name.charAt(0) === "[") && (this.name.charAt(this.name.length-1) === "]")) {
      this.name = this.parser.parse(this.name.substring(1, this.name.length-1));
    }
    else {
      this.name = this.parser.parse("'" + this.name + "'");
    }

    this.orientation = (this.w >= this.h) ? HORIZONTAL : VERTICAL;

    // control container
    this.container = document.createElement("div");
    this.canvas = document.createElement("canvas");
    this.divUp = document.createElement("div");
    this.divDown = document.createElement("div");
    this.field = document.createElement("input");

    // the scroll handler
    this.scrollHandler = document.createElement("div");

    // the label
    this.label = document.createElement("label");

    // add the elements to the container
    this.container.appendChild(this.canvas);
    this.container.appendChild(this.label);
    this.container.appendChild(this.divUp);
    this.container.appendChild(this.divDown);
    this.container.appendChild(this.field);
    this.container.appendChild(this.scrollHandler);

    this.addControlContainer(this.container);

    // register the mouse and touch events
    this.addEvents();

    // init the menu parameters
    this.init();
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Control
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Scrollbar, descartesJS.Control);

  /**
   * Init the scrollbar
   */
  descartesJS.Scrollbar.prototype.init = function() {
    evaluator = this.evaluator;

    // if has decimals the increment are the interval [min, max] dividen by 100, if not then the incremente is 1
    if (evaluator.eval(this.decimals) == 0) {
      this.incr = 1;
    }
    else {
      this.incr = (evaluator.eval(this.max) - evaluator.eval(this.min)) / 100;
    }

    // validate the initial value
    this.value = this.validateValue( evaluator.eval(this.valueExpr) );

    // format the output value
    fieldValue = this.formatOutputValue(this.value);

    expr = this.evaluator.eval(this.expresion);
    this.x = expr[0][0];
    this.y = expr[0][1];
    if (expr[0].length == 4) {
      this.w = expr[0][2];
      this.h = expr[0][3];
    }
    this.orientation = (this.w >= this.h) ? HORIZONTAL : VERTICAL;

    // init the scroll configuration
    this.initScroll(fieldValue);

    // change the value if really need a change
    this.changeScrollPositionFromValue();
    this.prePos = this.pos;
    // register the control value
    evaluator.setVariable(this.id, this.value);
  }

  /**
   * Init the scroll configuration
   */
  descartesJS.Scrollbar.prototype.initScroll = function(fieldValue) {
    self = this;
    evaluator = self.evaluator;

    name = evaluator.eval(self.name).toString();
    self.label.innerHTML = name;

    var defaultHeight = (self.orientation === VERTICAL) ? parseInt(19 + (5*(self.h-100))/100) : self.h;

    // find the font size of the text field
    self.fieldFontSize = (self.orientation === VERTICAL) ? (defaultHeight - parseInt(self.h/20) -1) : ((self.parent.version !== 2) ? descartesJS.getFieldFontSize(defaultHeight) : 10);

    var fieldValueSize = descartesJS.getTextWidth(fieldValue+"_", self.fieldFontSize+"px " + descartesJS.sansserif_font);

    var spaceH = self.parent.getSpaceById(self.spaceID).h;

    self.labelHeight = (name == "") ? 0 : defaultHeight;
    self.fieldHeight = (self.visible == "") ? 0 : defaultHeight;

    // vertical orientation
    if (self.orientation === VERTICAL) {
      self.canvasWidth = self.w;
      self.canvasHeight = self.h - self.labelHeight - self.fieldHeight;

      if (self.canvasHeight + self.y - spaceH >= 18) {
        self.canvasHeight = spaceH;
      }

      var sbx = 0;
      var sby = self.fieldHeight;
      var TFy = sby + self.canvasHeight;

      self.canvasX = 0;
      self.canvasY = self.fieldHeight;

      self.labelWidth = self.w;
      self.labelY = TFy;

      self.upWidth = self.downW = self.w;
      self.upHeight = self.downH = 15;
      self.upX = 0;
      self.upY = self.fieldHeight;
      self.downX = 0;
      self.downY = TFy-self.downH;

      self.fieldWidth = self.w;
      self.fieldX = 0;

      self.scrollHandlerW = self.w;
      self.scrollHandlerH = parseInt( (self.canvasHeight -self.upHeight -self.downH -self.labelHeight -self.fieldHeight)/10 );
      self.scrollHandlerH = (self.scrollHandlerH < 15) ? 15 : self.scrollHandlerH;

      self.limInf = TFy -self.downH -self.scrollHandlerH;
      self.limSup = sby+self.downH;
    }
    else {
      var minsbw = 58;

      // get the width of all elements in the scrollbar
      var minLabelWidth = descartesJS.getTextWidth(name, self.fieldFontSize+"px " + descartesJS.sansserif_font) +10;
      self.labelWidth = minLabelWidth;
      var minTFWidth = fieldValueSize;
      self.fieldWidth = minTFWidth;

      if (name == "") {
        self.labelWidth = 0;
      }

      if (!self.visible) {
        self.fieldWidth = 0;
      }

      var sbw = self.w - self.fieldWidth - self.labelWidth;
      while ((sbw < minsbw) && (self.labelWidth > 0)) {
        self.labelWidth--;
        sbw++;
      }
      while ((sbw < minsbw) && (self.fieldWidth > 0)) {
        self.fieldWidth--;
        sbw++;
      }

      var sbx = self.labelWidth;
      var sby = 0;
      var TFx = sbx + sbw;
      self.fieldWidth = self.w - TFx;

      self.canvasWidth = sbw;
      self.canvasHeight = self.h;
      self.canvasX = self.labelWidth;
      self.canvasY = 0;

      self.fieldX = self.canvasWidth + self.labelWidth;

      self.labelHeight = self.h;
      self.labelY = 0;

      self.upWidth = self.downW = 15;
      self.upHeight = self.downH = self.h;
      self.upX = TFx-self.downW;
      self.upY = 0;
      self.downX = self.labelWidth;
      self.downY = 0;

      self.scrollHandlerW = parseInt( (self.canvasWidth-self.upWidth-self.downW)/10 );
      self.scrollHandlerW = (self.scrollHandlerW < 15) ? 15 : self.scrollHandlerW;
      self.scrollHandlerH = self.h;

      self.limInf = sbx+self.downW;
      self.limSup = sbx+self.canvasWidth-self.downW -self.scrollHandlerW;
    }

    self.container.setAttribute("class", "DescartesScrollbarContainer");
    self.container.setAttribute("id", self.id);
    self.container.setAttribute("style", "width: " + self.w + "px; height: " + self.h + "px; left: " + self.x + "px; top: " + self.y + "px; z-index: " + self.zIndex + ";");

    self.canvas.setAttribute("width", self.w+"px");
    self.canvas.setAttribute("height", self.h+"px");
    self.canvas.setAttribute("style", "position: absolute; left: 0px; top: 0px;");
    self.ctx = self.canvas.getContext("2d");
    self.ctx.imageSmoothingEnabled = false;

    self.divUp.setAttribute("class", "DescartesCatcher up");
    self.divUp.setAttribute("style", "width : " + self.upWidth + "px; height : " + self.upHeight + "px; left: " + self.upX + "px; top: " + self.upY + "px;");
    self.divDown.setAttribute("class", "DescartesCatcher down");
    self.divDown.setAttribute("style", "width : " + self.downW + "px; height : " + self.downH + "px; left: " + self.downX + "px; top: " + self.downY + "px;");

    self.scrollHandler.setAttribute("class", "DescartesCatcher manipulator");
    self.scrollHandler.setAttribute("style", "width : " + self.scrollHandlerW + "px; height : " + self.scrollHandlerH + "px;");
    self.scrollHandler.style.top = ((self.orientation === VERTICAL) ? self.limInf : 0) + "px";
    self.scrollHandler.style.left = ((self.orientation === VERTICAL) ? 0 : self.limInf) + "px";

    // style the text field
    self.field.setAttribute("type", "text");
    self.field.setAttribute("id", self.id+"scrollbar");
    self.field.setAttribute("class", "DescartesScrollbarField");
    self.field.setAttribute("style", "font-size: " + self.fieldFontSize + "px; width : " + self.fieldWidth + "px; height : " + self.fieldHeight + "px; left: " + self.fieldX + "px; top: 0px;");
    self.field.value = fieldValue;
    if (self.fieldHeight === 0) {
      self.field.style.display = "none";
    }

    // style the label
    self.label.setAttribute("class", "DescartesScrollbarLabel");
    self.label.setAttribute("style", "font-size:" + self.fieldFontSize + "px; width: " + self.labelWidth + "px; height: " + self.labelHeight + "px; line-height: " + self.labelHeight + "px; left: 0px; top:" + self.labelY + "px;");

  }

  /**
   * Update the scrollbar
   */
  descartesJS.Scrollbar.prototype.update = function() {
    evaluator = this.evaluator;

    this.label.innerHTML = evaluator.eval(this.name).toString();

    // the incremente is the interval [min, max] dividen by 100 if has decimals, if not then the incremente is 1
    if (evaluator.eval(this.decimals) == 0) {
      this.incr = 1;
    }
    else {
      this.incr = (evaluator.eval(this.max) - evaluator.eval(this.min)) / 100;
    }

    // check if the control is active and visible
    this.activeIfValue = (evaluator.eval(this.activeif) > 0);
    this.drawIfValue = (evaluator.eval(this.drawif) > 0);

    // enable or disable the control
    this.field.disabled = !this.activeIfValue;

    // hide or show the menu control
    if (this.drawIfValue) {
      this.container.style.display = "block";
      this.draw();
    } else {
      this.container.style.display = "none";
    }

    // update the position and size
    this.updatePositionAndSize();

    // update the value of the menu
    var tmpValue = this.validateValue( evaluator.getVariable(this.id) );
    if ( (tmpValue != this.value) && !((Math.abs(tmpValue - this.value)>0) && (Math.abs(tmpValue - this.value)<.000000001))) {
      this.value = tmpValue;
      this.changeScrollPositionFromValue();
      this.prePos = this.pos;
    }

    this.value = tmpValue;
    this.field.value = this.formatOutputValue(this.value);

    // register the control value
    evaluator.setVariable(this.id, this.value);
  }

  /**
   * Draw the scrollbar
   */
  descartesJS.Scrollbar.prototype.draw = function() {
    self = this;
    ctx = self.ctx;

    tmpW = MathFloor(this.w);
    tmpH = MathFloor(this.h);

    ctx.fillStyle = "#e0e4e8";
    ctx.fillRect(0, 0, tmpW, tmpH);

    ctx.strokeStyle = "#7a8a99";

    if (self.down) {
      ctx.fillStyle = "#ccdcec";
      ctx.fillRect(self.downX+.5, self.downY+.5, self.downW, self.downH-1);
    }
    ctx.strokeRect(self.downX+.5, self.downY+.5, self.downW, self.downH-1);

    if (self.up) {
      ctx.fillStyle = "#ccdcec";
      ctx.fillRect(self.upX+.5, self.upY-.5, self.upWidth, self.upHeight+1);
    }
    ctx.strokeRect(self.upX+.5, self.upY-.5, self.upWidth, self.upHeight+1);

    desp = 4;
    ctx.fillStyle = "black";
    ctx.beginPath();

    if (self.orientation === HORIZONTAL) {
      // triangle in the buttons
      ctx.moveTo(self.downX +desp, self.downH/2);
      ctx.lineTo(self.downX +self.downW -desp, desp);
      ctx.lineTo(self.downX +self.downW -desp, self.downH -desp);
      ctx.moveTo(self.upX + self.upWidth -desp, self.downH/2);
      ctx.lineTo(self.upX +desp, desp);
      ctx.lineTo(self.upX +desp, self.downH -desp);
      ctx.fill();

      if (self.activeIfValue) {
        // scroll handler
        tmpPos = MathFloor(self.pos);
        ctx.fillStyle = "#ccdcec";
        ctx.fillRect(tmpPos+.5, 0, MathFloor(self.scrollHandlerW), tmpH);
        ctx.strokeStyle = "#6382bf";
        ctx.strokeRect(tmpPos+.5, 0, MathFloor(self.scrollHandlerW), tmpH);

        // scroll handler lines
        smw = MathFloor(self.scrollHandlerW/2);
        ctx.beginPath();
        ctx.moveTo(tmpPos+smw+.5-2, 3);
        ctx.lineTo(tmpPos+smw+.5-2, tmpH-3);
        ctx.moveTo(tmpPos+smw+.5,   3);
        ctx.lineTo(tmpPos+smw+.5,   tmpH-3);
        ctx.moveTo(tmpPos+smw+.5+2, 3);
        ctx.lineTo(tmpPos+smw+.5+2, tmpH-3);
        ctx.stroke();
      }

    }
    else {
      // triangle in the buttons
      ctx.moveTo(self.downX +self.downW/2, self.downY +self.downH -desp);
      ctx.lineTo(self.downX +desp, self.downY +desp);
      ctx.lineTo(self.downX +self.downW -desp, self.downY +desp);
      ctx.moveTo(self.upX +self.upWidth/2, self.upY +desp);
      ctx.lineTo(self.upX +desp, self.upY +self.upHeight -desp);
      ctx.lineTo(self.upX +self.upWidth -desp, self.upY +self.upHeight -desp);
      ctx.fill();

      if (self.activeIfValue) {
        // scroll handler
        tmpPos = MathFloor(self.pos);
        ctx.fillStyle = "#ccdcec";
        ctx.fillRect(0, tmpPos+.5, tmpW, MathFloor(self.scrollHandlerH));
        ctx.strokeStyle = "#6382bf";
        ctx.strokeRect(0, tmpPos+.5, tmpW, MathFloor(self.scrollHandlerH));

        // scroll handler lines
        smw = MathFloor(self.scrollHandlerH/2);
        ctx.beginPath();
        ctx.moveTo(3,      tmpPos+smw+.5-2);
        ctx.lineTo(tmpW-3, tmpPos+smw+.5-2);
        ctx.moveTo(3,      tmpPos+smw+.5);
        ctx.lineTo(tmpW-3, tmpPos+smw+.5);
        ctx.moveTo(3,      tmpPos+smw+.5+2);
        ctx.lineTo(tmpW-3, tmpPos+smw+.5+2);
        ctx.stroke();
      }
    }

    // external border
    ctx.strokeRect(.5, .5, tmpW-1, tmpH-1);

    // inactive shade
    if (!self.activeIfValue) {
      ctx.fillStyle = "rgba(" + 0xf0 + "," + 0xf0 + "," + 0xf0 + "," + (0xa0/255) + ")";
      ctx.fillRect(0, 0, tmpW, tmpH.h);
    }
  }

  /**
   * Validate if the value is the range [min, max]
   * @param {String} value the value to validate
   * @return {Number} return the value like a number,
   *                         is greater than the upper limit then return the upper limit
   *                         is less than the lower limit then return the lower limit
   */
  descartesJS.Scrollbar.prototype.validateValue = function(value) {
    evaluator = this.evaluator;
    resultValue = value.toString();
    resultValue = parseFloat( resultValue.replace(this.parent.decimal_symbol, ".") );

    // if the value is a string that do not represent a number, parseFloat return NaN
    if (isNaN(resultValue)) {
      resultValue = 0;
    }

    // if is less than the lower limit
    this.minimo = evaluator.eval(this.min);
    if (resultValue < this.minimo) {
      this.value = null;
      resultValue = this.minimo;
    }

    // if si greater than the upper limit
    this.maximo = evaluator.eval(this.max);
    if (resultValue > this.maximo) {
      this.value = null;
      resultValue = this.maximo;
    }

    incr = this.incr;
    resultValue = (incr != 0) ? (resultValue*incr)/incr : 0;

//     if (this.discrete) {
//       var incr = this.incr;
//       resultValue = incr * Math.round(resultValue / incr);
//     }

    if (this.fixed) {
      resultValue = parseFloat(parseFloat(resultValue).toFixed(evaluator.eval(this.decimals)));
    }

    return resultValue;
  }

  /**
   * Increase the value of the scrollbar
   */
  descartesJS.Scrollbar.prototype.increase = function() {
    this.changeValue( parseFloat(this.value) + this.incr );
  }

  /**
   * Decrease the value of the scrollbar
   */
  descartesJS.Scrollbar.prototype.decrease = function() {
    this.changeValue( parseFloat(this.value) - this.incr );
  }

  /**
   * Increase by then the value of the scrollbar
   */
  descartesJS.Scrollbar.prototype.increase10 = function() {
    desp = (this.evaluator.eval(this.max)-this.evaluator.eval(this.min))/10;

    if (this.orientation == HORIZONTAL) {
      if (this.clickPos.x > this.prePos) {
        this.changeValue( parseFloat(this.value) + desp );
      }
    } else {
      if (this.clickPos.y < this.prePos) {
        this.changeValue( parseFloat(this.value) + desp );
      }
    }
  }

  /**
   * Decrease by then the value of the scrollbar
   */
  descartesJS.Scrollbar.prototype.decrease10 = function() {
    desp = (this.evaluator.eval(this.max)-this.evaluator.eval(this.min))/10;

    if (this.orientation == HORIZONTAL) {
      if (this.clickPos.x < this.prePos) {
        this.changeValue( parseFloat(this.value) - desp );
      }
    } else {
      if (this.clickPos.y > this.prePos) {
        this.changeValue( parseFloat(this.value) - desp );
      }
    }
  }

  /**
   * Change the scrollbar value
   */
  descartesJS.Scrollbar.prototype.changeValue = function(value) {
    if (this.activeIfValue) {
      newValue = this.validateValue(value);

      // change the value if really need a change
      if (newValue != this.value) {
        this.value = newValue;
        this.field.value = this.formatOutputValue(newValue);

        this.changeScrollPositionFromValue();

        this.prePos = this.pos;

        // register the control value
        this.evaluator.setVariable(this.id, this.value);

        this.updateAndExecAction();
      }
    }
  }

  /**
   * Change the value when the scroll handler move
   */
  descartesJS.Scrollbar.prototype.changeValueForScrollMovement = function() {
    evaluator = this.evaluator;
    limInf = this.limInf;
    limSup = this.limSup;
    min = evaluator.eval(this.min);
    max = evaluator.eval(this.max);
    incr = this.incr;

    newValue = MathFloor( (((this.pos-limInf)*(max-min))/(limSup-limInf))/incr )*incr  +min;

    // if the value change, the update everything
    if (newValue != this.value) {
      this.value = newValue;
      this.field.value = this.formatOutputValue(newValue);

      // register the control value
      evaluator.setVariable(this.id, this.value);

      // update the controls
      this.parent.updateControls();
      // execute the acction
      this.actionExec.execute();
      // update again the controls
      this.parent.update();
    }
  }

  /**
   * Change the position of the scroll handler give the value
   */
  descartesJS.Scrollbar.prototype.changeScrollPositionFromValue = function() {
    evaluator = this.evaluator;
    limInf = this.limInf;
    limSup = this.limSup;
    min = evaluator.eval(this.min);
    max = evaluator.eval(this.max);
    incr = this.incr;

    this.pos = (((this.value-min)*(limSup-limInf))/(max-min))+limInf;

    if (this.orientation == HORIZONTAL) {
      this.scrollHandler.style.left = this.pos + "px";
    } else {
      this.scrollHandler.style.top = this.pos + "px";
    }
  }

  /**
   * Register the mouse and touch events
   */
  descartesJS.Scrollbar.prototype.addEvents = function() {
    // hasTouchSupport = descartesJS.hasTouchSupport;

    var self = this;
    // var delay = (hasTouchSupport) ? 500 : 200;
    var delay = 350;
    var timer;

    // prevent the context menu display
    self.canvas.oncontextmenu = self.divUp.oncontextmenu = self.divDown.oncontextmenu = self.label.oncontextmenu = self.field.oncontextmenu = self.scrollHandler.oncontextmenu = function () { return false; };

    /**
     * Repeat a function during a period of time, when the user click and hold the click in the button
     * @param {Number} delayTime the delay of time between the function repetition
     * @param {Function} fun the function to execut
     * @param {Boolean} firstime a flag to indicated if is the first time clicked
     * @private
     */
    function repeat(delayTime, fun, firstTime, limit) {
      descartesJS.clearTimeout(timer);

      if ((self.up || self.down || self.canvasClick) && (Math.abs(self.value - limit) > .0000001)) {
        fun.call(self);
        delayTime = (firstTime) ? delayTime : 30;
        timer = descartesJS.setTimeout(function() { repeat(delayTime, fun, false, limit); }, delayTime);
      }
    }

    /**
     *
     * @param {Event}
     * @private
     */
    function onKeyDown_TextField(evt) {
      // responds to enter
      if (evt.keyCode == 13) {
        self.changeValue(self.field.value);
      }
    }
    this.field.addEventListener("keydown", onKeyDown_TextField);

    /**
     *
     * @param {Event}
     * @private
     */
    function onMouseDown_canvas(evt) {
      evt.preventDefault();

      self.whichBtn = descartesJS.whichBtn(evt);

      if (self.whichBtn == "L") {
        if (self.activeIfValue) {
          self.clickPos = descartesJS.getCursorPosition(evt, self.container);
          self.canvasClick = true;

          if (self.orientation == HORIZONTAL) {
            if (self.clickPos.x < self.prePos) {
              repeat(delay, self.decrease10, true, self.minimo);
            }
            else {
              repeat(delay, self.increase10, true, self.maximo);
            }
          }
          else {
            if (self.clickPos.y < self.prePos) {
              repeat(delay, self.increase10, true, self.maximo);
            }
            else {
              repeat(delay, self.decrease10, true, self.minimo);
            }
          }
        }
      }
    }
    // if (hasTouchSupport) {
      this.canvas.addEventListener("touchstart", onMouseDown_canvas);
    // } else {
      this.canvas.addEventListener("mousedown", onMouseDown_canvas);
    // }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseOut_canvas(evt) {
      self.canvasClick = false;
      descartesJS.clearTimeout(timer);
      evt.preventDefault();
    }
    // if (!hasTouchSupport) {
      this.divDown.addEventListener("mouseout", onMouseOut_DownButton);
    // }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseUp_Canvas(evt) {
      self.canvasClick = false;
      descartesJS.clearTimeout(timer);
      // evt.preventDefault();
    }
    // if (hasTouchSupport) {
      window.addEventListener("touchend", onMouseUp_Canvas);
    // } else {
      window.addEventListener("mouseup", onMouseUp_Canvas);
    // }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseMove_Canvas(evt) {
      if (self.canvasClick == true) {
        self.clickPos = descartesJS.getCursorPosition(evt, self.container);
        evt.preventDefault();
      }
    }
    // if (hasTouchSupport) {
      this.canvas.addEventListener("touchmove", onMouseMove_Canvas);
    // } else {
      this.canvas.addEventListener("mousemove", onMouseMove_Canvas);
    // }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseDown_scrollHandler(evt) {
      if (self.activeIfValue) {
        self.scrollClick = true;

        self.initPos = descartesJS.getCursorPosition(evt, self.container);

        window.addEventListener("mouseup", onMouseUp_scrollHandler);
        window.addEventListener("mousemove", onMouseMove_scrollHandler);

        evt.preventDefault();
      }
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onTouchStart_scrollHandler(evt) {
      if (self.activeIfValue) {
        self.scrollClick = true;

        self.initPos = descartesJS.getCursorPosition(evt, self.container);

        window.addEventListener("touchend", onTouchEnd_scrollHandler);
        window.addEventListener("touchmove", onMouseMove_scrollHandler);

        evt.preventDefault();
      }
    }

    // if (hasTouchSupport) {
      this.scrollHandler.addEventListener("touchstart", onTouchStart_scrollHandler);
    // } else {
      this.scrollHandler.addEventListener("mousedown", onMouseDown_scrollHandler);
    // }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseUp_scrollHandler(evt) {
      self.scrollClick = false;

      self.prePos = self.pos;

      window.removeEventListener("mouseup", onMouseUp_scrollHandler, false);
      window.removeEventListener("mousemove", onMouseMove_scrollHandler, false);

      evt.preventDefault();
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onTouchEnd_scrollHandler(evt) {
      self.scrollClick = false;

      self.prePos = self.pos;

      window.removeEventListener("touchend", onTouchEnd_scrollHandler, false);
      window.removeEventListener("touchmove", onMouseMove_scrollHandler, false);

      evt.preventDefault();
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseMove_scrollHandler(evt) {
      var newPos = descartesJS.getCursorPosition(evt, self.container);

      if (self.orientation == HORIZONTAL) {
        self.pos = self.prePos - (self.initPos.x - newPos.x);

        if (self.pos < self.limInf) {
          self.pos =  self.limInf;
        }

        if (self.pos > self.limSup) {
          self.pos =  self.limSup;
        }

        self.scrollHandler.setAttribute("style", "background-color: rgba(255, 255, 255, 0); cursor: pointer; position: absolute; width : " + self.scrollHandlerW + "px; height : " + self.h + "px; left: " + self.pos + "px; top: 0px;");
      } else {
        self.pos = self.prePos - (self.initPos.y - newPos.y);

        if (self.pos > self.limInf) {
          self.pos =  self.limInf;
        }

        if (self.pos < self.limSup) {
          self.pos =  self.limSup;
        }

        self.scrollHandler.setAttribute("style", "background-color: rgba(255, 255, 255, 0); cursor: pointer; position: absolute; width : " + self.w + "px; height : " + self.scrollHandlerH + "px; left: 0px; top: " + self.pos + "px;");
      }

      self.changeValueForScrollMovement();

      evt.preventDefault();
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseDown_UpButton(evt) {
      evt.preventDefault();

      self.whichBtn = descartesJS.whichBtn(evt);

      if (self.whichBtn == "L") {
        if (self.activeIfValue) {
          self.up = true;
          repeat(delay, self.increase, true, self.maximo);
        }
      }
    }
    // if (hasTouchSupport) {
      this.divUp.addEventListener("touchstart", onMouseDown_UpButton);
    // } else {
      this.divUp.addEventListener("mousedown", onMouseDown_UpButton);
    // }

    /**
     *
     * @param {Event}
     * @private
     */
    function onMouseDown_DownButton(evt) {
      evt.preventDefault();

      self.whichBtn = descartesJS.whichBtn(evt);

      if (self.whichBtn == "L") {
        if (self.activeIfValue) {
          self.down = true;
          repeat(delay, self.decrease, true, self.minimo);
        }
      }
    }
    // if (hasTouchSupport) {
      this.divDown.addEventListener("touchstart", onMouseDown_DownButton);
    // } else {
      this.divDown.addEventListener("mousedown", onMouseDown_DownButton);
    // }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseOut_UpButton(evt) {
      self.up = false;
      descartesJS.clearTimeout(timer);
      evt.preventDefault();
    }
    // if (!hasTouchSupport) {
      this.divUp.addEventListener("mouseout", onMouseOut_UpButton);
    // }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseOut_DownButton(evt) {
      self.down = false;
      descartesJS.clearTimeout(timer);
      evt.preventDefault();
    }
    // if (!hasTouchSupport) {
      this.divDown.addEventListener("mouseout", onMouseOut_DownButton);
    // }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseUp_UpButton(evt) {
      self.up = false;
      descartesJS.clearTimeout(timer);
      // evt.preventDefault();
      self.draw();
    }
    // if (hasTouchSupport) {
      window.addEventListener("touchend", onMouseUp_UpButton);
    // } else {
      window.addEventListener("mouseup", onMouseUp_UpButton);
    // }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseUp_DownButton(evt) {
      self.down = false;
      descartesJS.clearTimeout(timer);
      // evt.preventDefault();
      self.draw();
    }
    // if (hasTouchSupport) {
      window.addEventListener("touchend", onMouseUp_DownButton);
    // } else {
      window.addEventListener("mouseup", onMouseUp_DownButton);
    // }

  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var evaluator;

  /**
   * Descartes audio control
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the audio control
   */
  descartesJS.Audio = function(parent, values) {
    /**
     * condition to show the controls
     * type {Boolean}
     * @private
     */
    this.controls = true;

    this.file = "";

    this.oldDrawIf = 0;

    // call the parent constructor
    descartesJS.Control.call(this, parent, values);

    var self = this;

    // the audio position and size
    var expr = self.evaluator.eval(self.expresion);
    if (expr[0].length == 4) {
      self.w = expr[0][2];
      self.h = expr[0][3];
    } else {
      self.w = 200;
      self.h = 28;
    }

    self.audio = self.parent.getAudio(self.file);
    self.oldFile = self.file;


    if (self.file.charAt(self.file.length-1) === "]") {
      self.file = self.evaluator.parser.parse(self.file.substring(1, self.file.length-1));
    }

    
    if (self.autoplay) {
      self.audio.setAttribute("autoplay", "autoplay");
      self.audio.play();
    }

    if (self.loop) {
      self.audio.setAttribute("loop", "loop");
    }

    if (self.controls) {
      self.audio.setAttribute("controls", "controls");
    }

    self.audio.setAttribute("style", "position: absolute; width: " + self.w + "px; left: " + self.x + "px; top: " + self.y + "px; z-index: " + self.zIndex + ";");

    self.addControlContainer(self.audio);

    //
    self.evaluator.setFunction(self.id + ".play", function() {
      try {
        self.audio.play();
      } catch(e) {}

      return 0;
    });
    self.evaluator.setFunction(self.id + ".pause", function() {
      try {
        self.audio.pause();
      } catch(e) {}

      return 0;
    });
    self.evaluator.setFunction(self.id + ".stop", function() {
      try {
        self.audio.pause();
        self.audio.currentTime = 0.0;
      } catch(e) {}

      return 0;
    });
    self.evaluator.setFunction(self.id + ".currentTime", function(time) {
      try {
        self.audio.currentTime = parseFloat(time);
      } catch(e) {}

      return 0;
    });
    self.audio.addEventListener("timeupdate", function(evt) {
      self.evaluator.setVariable(self.id + ".currentTime", self.audio.currentTime);
    });

  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Control
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Audio, descartesJS.Control);

  /**
   * Init the audio
   */
  descartesJS.Audio.prototype.init = function() {
    // this.audio.setAttribute("width", this.w);
    // this.audio.setAttribute("height", this.h);
    this.audio.style.left = this.x + "px";
    this.audio.style.top  = this.y + "px";

    this.update();
  }

  var drawif;
  /**
   * Update the audio control
   */
  descartesJS.Audio.prototype.update = function() {
    evaluator = this.evaluator;

    // the file name is variable
    if (typeof(this.file) !== "string") {
      this.tmpFile = evaluator.eval(this.file);
      if (this.oldFile !== this.tmpFile) {
        this.audio.src = this.tmpFile;
        this.oldFile = this.tmpFile;
      }
    }

    drawif = evaluator.eval(this.drawif) > 0;

    // hide or show the audio control
    if (drawif) {
      this.audio.style.display = "block";
    } else {
      this.audio.style.display = "none";

      if (drawif !== this.oldDrawIf) {
        this.audio.pause();
      }
    }

    this.oldDrawIf = drawif;

    // update the position and size
    this.updatePositionAndSize();
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var evaluator;

  /**
   * Descartes video control
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the video control
   */
  descartesJS.Video = function(parent, values) {
    /**
     * condition to show the controls
     * type {Boolean}
     * @private
     */
    this.controls = true;

    this.file = "";

    this.oldDrawIf = 0;

    // call the parent constructor
    descartesJS.Control.call(this, parent, values);

    var self = this;
    evaluator = self.evaluator;

    var expr = self.evaluator.eval(self.expresion);
    if (expr[0].length == 4) {
      self.w = expr[0][2];
      self.h = expr[0][3];
    } else {
      self.w = null;
      self.h = null;
    }

    var filename = self.file;
    var indexDot = filename.lastIndexOf(".");

    if (indexDot != -1) {
      filename = self.file.substring(0, indexDot);
    }

    self.video = document.createElement("video");

    if (self.autoplay) {
      self.video.setAttribute("autoplay", "autoplay");
    }

    if (self.loop) {
      self.video.setAttribute("loop", "loop");
    }

    if (self.controls) {
      self.video.setAttribute("controls", "controls");
    }

    self.video.setAttribute("poster", filename + '.png');

    if (self.w) {
      self.video.setAttribute("width", self.w);
      self.video.setAttribute("height", self.h);
    }
    self.video.setAttribute("style", "position:absolute; overflow:hidden; left:" + self.x + "px; top:" + self.y + "px; outline:none; background:rgba(0,0,0,0);");

    var source;
    //mp4
    if (self.video.canPlayType("video/mp4")) {
      source = document.createElement("source");
      source.setAttribute("src", filename + ".mp4");
      // source.setAttribute("type", "video/mp4");
      self.video.appendChild(source);
    }
    // ogg, ogv
    if (self.video.canPlayType("video/ogg")) {
      source = document.createElement("source");
      source.setAttribute("src", filename + ".ogg");
      source.setAttribute("type", "video/ogg");
      self.video.appendChild(source);

      source = document.createElement("source");
      source.setAttribute("src", filename + ".ogv");
      source.setAttribute("type", "video/ogg");
      self.video.appendChild(source);
    }
    // webm
    if (self.video.canPlayType("video/webm")) {
      source = document.createElement("source");
      source.setAttribute("src", filename + ".webm");
      source.setAttribute("type", "video/webm");
      self.video.appendChild(source);
    }

    self.addControlContainer(self.video);

    //
    self.evaluator.setFunction(self.id + ".play", function() {
      try {
        self.video.play();
      } catch(e) {}

      return 0;
    });
    self.evaluator.setFunction(self.id + ".pause", function() {
      try {
        self.video.pause();
      } catch(e) {}

      return 0;
    });
    self.evaluator.setFunction(self.id + ".stop", function() {
      try {
        self.video.pause();
        self.video.currentTime = 0.0;
      } catch(e) {}

      return 0;
    });
    self.evaluator.setFunction(self.id + ".currentTime", function(time) {
      try {
        self.video.currentTime = parseFloat(time);
      } catch(e) {}

      return 0;
    });
    self.video.addEventListener("timeupdate", function(evt) {
      self.evaluator.setVariable(self.id + ".currentTime", self.video.currentTime);
    });
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Control
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Video, descartesJS.Control);

  /**
   * Init the video
   */
  descartesJS.Video.prototype.init = function() {
    this.video.style.left = this.x + "px";
    this.video.style.top  = this.y + "px";

    this.update();
  }

  var drawif;
  /**
   * Update the video control
   */
  descartesJS.Video.prototype.update = function() {
    evaluator = this.evaluator;

    drawif = evaluator.eval(this.drawif) > 0

    // hide or show the video control
    if (drawif) {
      this.video.style.display = "block"
    } else {
      this.video.style.display = "none";

      if (drawif !== this.oldDrawIf) {
        this.video.pause();
      }
    }

    this.oldDrawIf = drawif;

    // update the position and size
    this.updatePositionAndSize();
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathFloor = Math.floor;
  var evaluator;
  var displaceY;
  var newText;

  /**
   * Descartes scrollbar control
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the scrollbar control
   */
  descartesJS.TextArea = function(parent, values){
    this.font_family = "Monospaced";
    this.style = ",PLAIN,";
    this.font_size = 12;

    // call the parent constructor
    descartesJS.Control.call(this, parent, values);

    if (typeof(this.font_size !== "number")) {
      this.font_size = this.evaluator.eval(this.font_size);
    }
 
    this.font = this.font_family + this.style + this.font_size;

    // always show in the interior region
    this.region = "interior";

    // tabular index
    this.tabindex = ++this.parent.tabindex;

    // la respuesta existe
    if (this.answer) {
      // la respuesta esta encriptada
      if (this.answer.match("krypto_")) {
        var krypt = new descartesJS.Krypto();
        this.answer = krypt.decode(this.answer.substring(7));
      }

      var parseAnswer = this.parent.lessonParser.parseText(this.answer);
    }

    // control container
    this.containerControl = document.createElement("div");

    // the text area
    this.textArea = document.createElement("div");
    this.textAreaAnswer = document.createElement("div");

    // show answer button
    this.showButton = document.createElement("div");

    // active cover
    this.activeCover = document.createElement("div");

    // add the elements to the container
    this.containerControl.appendChild(this.textArea);
    this.containerControl.appendChild(this.textAreaAnswer);
    this.containerControl.appendChild(this.showButton);
    this.containerControl.appendChild(this.activeCover);

    this.addControlContainer(this.containerControl);

    this.showAnswer = false;

    // plain text
    if ( (this.text == undefined) || (this.text.type == "simpleText")) {
      this.text = this.rawText || "";
    }
    // rtf text
    else {
      if (this.text.hasFormula) {
        this.text = this.rawText;
      }
      else {
        this.text = this.text.toHTML();
      }
    }

    // rtf answer
    if ((parseAnswer) && (parseAnswer.type !== "simpleText")) {
      if (!this.text.hasFormula) {
        this.answer = parseAnswer.toHTML();
      }
      else {
        this.answer = "";
      }
    }

    this.evaluator.setVariable(this.id, this.text);

    this.drawButton();

    var self = this;
    var sel;
    var range;
    var newText;
    this.evaluator.setFunction(this.id + ".insertAtCursor", function(str) {
      sel = window.getSelection();
      if (sel && sel.getRangeAt && sel.rangeCount) {
        newText = document.createTextNode(str);
        range = sel.getRangeAt(0);
        range.deleteContents();
        range.insertNode(newText);
        
        // move the caret to the end of the inserted text
        range.setStart(newText, newText.length);
        range.setEnd(newText, newText.length);
        sel.removeAllRanges();
        sel.addRange(range);

        self.textArea.focus();
      }
      return 0;
    });

    this.evaluator.setFunction(this.id + ".update", function() {
      self.update();
    })

    // register the mouse and touch events
    this.addEvents();

    this.init();
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Control
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.TextArea, descartesJS.Control);

  /**
   * Init the text area
   */
  descartesJS.TextArea.prototype.init = function() {
    displaceY = (this.answer) ? 28 : 4;
    evaluator = this.evaluator;

    var newText;

    if (this.text.match(/<span/)) {
      newText = this.text;
    }
    else {
      newText = this.text.replace(/\\n/g, "<br/>");
    }

    this.containerControl.setAttribute("class", "DescartesTextAreaContainer");
    this.containerControl.setAttribute("style", "width: " + this.w + "px; height: " + this.h + "px; left: " + this.x + "px; top: " + this.y + "px; z-index: " + this.zIndex + ";");
    this.containerControl.style.display = (evaluator.eval(this.drawif) > 0) ? "block" : "none";
    this.containerControl.setAttribute("spellcheck", "false");

    // text area
    this.textArea.setAttribute("class", "DescartesTextAreaContainer");
    this.textArea.setAttribute("style", "padding: 5px; width: " + (this.w-4) + "px; height: " + (this.h-displaceY) + "px; left: 2px; top: 2px; background-color: white; text-align: left; font: " + descartesJS.convertFont(this.font) + ";line-height:"+ this.font_size +"px;");
    this.textArea.setAttribute("contenteditable", "true");
    // this.textArea.innerHTML = "<span style='position: relative; top: 10px; left: 10px; white-space: nowrap;' >" + newText + "</span>";
    this.textArea.innerHTML = newText;

    // text area answer
    this.textAreaAnswer.setAttribute("class", "DescartesTextAreaContainer");
    this.textAreaAnswer.setAttribute("style", "width: " + (this.w-8) + "px; height: " + (this.h-displaceY) + "px; left: 4px; top: 4px; background-color: white; text-align: left; font: " + descartesJS.convertFont(this.font) + ";");
    this.textAreaAnswer.style.display = (this.showAnswer) ? "block" : "none";
    this.textAreaAnswer.innerHTML = "<span style='position: relative; top: 10px; left: 10px; white-space: nowrap;'>" + this.answer + "</span>";

    // show answer button
    this.showButton.setAttribute("style", "width: 20px; height: 16px; position: absolute; bottom: 4px; right: 4px; cursor: pointer;");
    this.showButton.style.backgroundImage = "url(" + this.imageUnPush + ")";
    this.showButton.style.display = (this.answer) ? "block" : "none";
    this.showButton.innerHTML = "<span style='position: relative; top: 2px; text-align: center; font: 9px Arial'> S </span>";

    this.activeCover.setAttribute("style", "position: absolute; width: " + this.w + "px; height: " + this.h + "px; left: " + this.x + "px; top: " + this.y + "px;");

    this.update();
  }

  /**
   * Draw the show/hide button
   */
  descartesJS.TextArea.prototype.drawButton = function() {
    var w = 20;
    var h = 16;

    var canvas = document.createElement("canvas");
    canvas.setAttribute("width", w);
    canvas.setAttribute("height", h);
    var ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = false;

    this.canvas = canvas;
    this.ctx = ctx;
    this.createGradient(w, h);

    ctx.lineWidth = 1;
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = this.linearGradient;
    ctx.fillRect(0, 0, w, h);
    descartesJS.drawLine(ctx, w-1, 0, w-1, h, "rgba(0,0,0,"+(0x80/255)+")");
    descartesJS.drawLine(ctx, 0, 0, 0, h, "rgba(0,0,0,"+(0x18/255)+")");
    descartesJS.drawLine(ctx, 1, 0, 1, h, "rgba(0,0,0,"+(0x08/255)+")");
    this.imageUnPush = canvas.toDataURL();

    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = this.linearGradient;
    ctx.fillRect(0, 0, w, h);
    descartesJS.drawLine(ctx, 0, 0, 0, h-2, "gray");
    descartesJS.drawLine(ctx, 0, 0, w-1, 0, "gray");
    ctx.fillStyle = "rgba(0, 0, 0,"+(0x18/255)+")";
    ctx.fillRect(0, 0, this.w, this.h);

    this.imagePush = canvas.toDataURL();
  }

  var count = 0;
  /**
   * Update the text area
   */
  descartesJS.TextArea.prototype.update = function() {
    evaluator = this.evaluator;
    
    // check if the control is active and visible
    this.activeIfValue = (evaluator.eval(this.activeif) > 0);
    this.drawIfValue = (evaluator.eval(this.drawif) > 0);

    if (evaluator.getVariable(this.id) !== this.oldValue) {
      this.textArea.innerText = (evaluator.getVariable(this.id) || "").replace(/\\n/g, "\n");
    }

    newText = (this.textArea.innerText || "");
    newText = (newText.charAt(newText.length-1) === "\n") ? newText.substring(0, newText.length-1) : newText;
    newText = newText.replace(/\n/g, "\\n").replace(/\s/g, " ");

    evaluator.setVariable(this.id, newText);

    this.oldFieldValue = newText;
    this.oldValue = evaluator.getVariable(this.id);

    // enable or disable the control
    this.activeCover.style.display = (this.activeIfValue) ? "none" : "block";

    // hide or show the text field control
    this.containerControl.style.display = (this.drawIfValue) ? "block" : "none";

    // update the position and size
    this.updatePositionAndSize();
  }

  /**
   * Register the mouse and touch events
   */
  descartesJS.TextArea.prototype.addEvents = function() {
    var self = this;

    /**
     * @param {Event} evt
     * @private
     */
    function onMouseDown(evt) {
      evt.preventDefault();
      self.showAnswer = !self.showAnswer;
      self.textAreaAnswer.style.display = (self.showAnswer) ? "block" : "none";
      self.showButton.childNodes[0].childNodes[0].textContent = (self.showAnswer) ? "T" : "S";
      self.showButton.style.backgroundImage = "url(" + self.imagePush + ")";
    }
    this.showButton.addEventListener("mousedown", onMouseDown);

    /**
     * @param {Event} evt
     * @private
     */
    function onMouseUp(evt) {
      evt.preventDefault();
      self.showButton.style.backgroundImage = "url(" + self.imageUnPush + ")";
    }
    this.showButton.addEventListener("mouseup",  onMouseUp);
    this.showButton.addEventListener("mouseout", onMouseUp);

    function getSelection() {
      var selection = window.getSelection();
      self.cursorInd = selection.focusOffset;
    }
    this.textArea.addEventListener("blur", getSelection)
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var PI2 = Math.PI*2;
  var evaluator;
  var parser;
  var x;
  var y;
  var cpos;
  var ctx;
  var backCtx;
  var constraintPosition;

  var hasTouchSupport;
  var boundingRect;
  var tmp;

  /**
   * Descartes graphic control
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the graphic control
   */
  descartesJS.GraphicControl = function(parent, values) {
    /**
     * Descartes application
     * type {DescartesApp}
     * @private
     */
    parser = parent.evaluator.parser;

    /**
     * space identifier
     * type {String}
     * @private
     */
    this.spaceID = "";

    /**
     * text
     * type {String}
     * @private
     */
    this.text = "";

    /**
     * size
     * type {Node}
     * @private
     */
    this.size = parser.parse("4");

    /**
     * font control
     * type {String}
     * @private
     */
    this.font = "Monospaced,PLAIN,12";

    /**
     * image control
     * type {Image}
     * @private
     */
    this.image = new Image();
    var self = this;
    this.image.onload = function() {
      this.ready = 1;
    }

    /**
     * image file name
     * type {String}
     * @private
     */
    this.imageSrc = "";

    // call the parent constructor
    descartesJS.Control.call(this, parent, values);

    // get the Descartes font
    this.font = descartesJS.convertFont(this.font);

    // build the contraint
    if (this.constraintExpr) {
      this.constraint = parser.parse(this.constraintExpr);

      if (this.constraint.type == "(expr)") {
        this.constraint = parser.parse(this.constraintExpr.substring(1, this.constraintExpr.length-1));
      }

      if (this.constraint.type == "compOperator") {
        var left = this.constraint.childs[0];
        var right = this.constraint.childs[1];

        if ( (left.type == "identifier") && (left.value == "y") && (!right.contains("y")) ) {
          this.constVar = "x";
          this.noConstVar = "y";
          this.evalConst = this.evalConstXoY;
          this.constraint = right;
        }
        else if ( (left.type == "identifier") && (left.value == "x") && (!right.contains("x")) ) {
          this.constVar = "y";
          this.noConstVar = "x";
          this.evalConst = this.evalConstXoY;
          this.constraint = right;
        }
        else {
          this.newt = new descartesJS.R2Newton(this.evaluator, this.constraint);
        }

      } else {
        this.constraint = null;
      }

      constraintPosition = new descartesJS.R2(0, 0);
    }

    // get the container
    this.container = this.getContainer();

    // dom element for catch the mouse events
    this.mouseCacher = document.createElement("div");
    this.mouseCacher.setAttribute("class", "DescartesGraphicControl");
    this.mouseCacher.setAttribute("id", this.id);
    this.mouseCacher.setAttribute("dragged", true);
    this.mouseCacher.setAttribute("tabindex", "-1");

    this.ctx = this.space.ctx;

    this.container.appendChild(this.mouseCacher);

    // register the mouse and touch events
    this.addEvents();

    this.xStr = this.id + ".x";
    this.yStr = this.id + ".y";
    this.activoStr = this.id + ".activo";
    this.activeStr = this.id + ".active";

    if ((this.space.id !== "") && (parent.version !== 2)) {
      this.mxStr = this.space.id + ".mouse_x";
      this.myStr = this.space.id + ".mouse_y";
      this.mclickedStr = this.space.id + ".mouse_clicked";
      this.mclicizquierdoStr = this.space.id + ".clic_izquierdo";
    }
    else {
      this.mxStr = "mouse_x";
      this.myStr = "mouse_y";
      this.mclickedStr = "mouse_clicked";
      this.mclicizquierdoStr = "clic_izquierdo";
    }

    this.init();
  }

  /**
   * Init the graphic control
   */
  descartesJS.GraphicControl.prototype.init = function() {
    evaluator = this.evaluator;
    hasTouchSupport = descartesJS.hasTouchSupport;

    // find the x and y position
    var expr = evaluator.eval(this.expresion);
    this.x = expr[0][0];
    this.y = expr[0][1];
    evaluator.setVariable(this.xStr, this.x);
    evaluator.setVariable(this.yStr, this.y);

    var radioTouch = 48;
    var radioTouchImage = 32;

    this.mouseCacher.setAttribute("style", "cursor:pointer;background-color:rgba(255, 255, 255, 0);z-index:" + this.zIndex + ";");

    // if the control has an image name
    if ((this.imageSrc != "") && !(this.imageSrc.toLowerCase().match(/vacio.gif$/))) {
      this.image = this.parent.getImage(this.imageSrc);

      this.width = this.image.width;
      this.height = this.image.height;

      this._w = Math.max(this.width, radioTouchImage);
      this._h = Math.max(this.height, radioTouchImage);
    }
    else {
      this.width = (evaluator.eval(this.size)*2);
      this.height = (evaluator.eval(this.size)*2);

      this._w = ((hasTouchSupport) && (this.width < radioTouch)) ? radioTouch : this.width;
      this._h = ((hasTouchSupport) && (this.height < radioTouch)) ? radioTouch : this.height;

      // set a style to make the button round
      this.mouseCacher.style.borderRadius = parseInt( Math.min(this._w, this._h)/2 ) + "px";
    }

    this.mouseCacher.style.width = this._w + "px";
    this.mouseCacher.style.height = this._h + "px";
    this.mouseCacher.style.left = parseInt(this.space.getAbsoluteX(this.x)-this._w/2)+"px";
    this.mouseCacher.style.top = parseInt(this.space.getAbsoluteY(this.y)-this._h/2)+"px";

    evaluator.setVariable(this.activoStr, 0);
    evaluator.setVariable(this.activeStr, 0);

    this.setImage = false;

    this.update();
  }

  /**
   * Update the graphic control
   */
  descartesJS.GraphicControl.prototype.update = function() {
    evaluator = this.evaluator;

    // check if the control is active and visible
    this.activeIfValue = (evaluator.eval(this.activeif) > 0);
    this.drawIfValue = (evaluator.eval(this.drawif) > 0);

    // update the position
    this.x = evaluator.getVariable(this.xStr);
    this.y = evaluator.getVariable(this.yStr);

    x = this.space.getAbsoluteX(this.x);
    y = this.space.getAbsoluteY(this.y);

    this.mouseCacher.style.display = (!this.activeIfValue) ? "none" : "block";
    this.mouseCacher.style.left = parseInt(x-this._w/2)+"px";
    this.mouseCacher.style.top = parseInt(y-this._h/2)+"px";

    // eval the constraint
    if (this.constraint) {
      this.evalConst();
    }

    this.draw();
  }

  /**
   * Draw the graphic control
   */
  descartesJS.GraphicControl.prototype.draw = function() {
    evaluator = this.evaluator;

    if (this.drawIfValue) {
      ctx = this.ctx;
      backCtx = this.space.backgroundCtx;
      x = parseInt(this.space.getAbsoluteX(this.x))+.5;
      y = parseInt(this.space.getAbsoluteY(this.y))+.5;

      if (this.text != "") {
        this.drawText(x, y);
      }

      // if the control do not have a image or is not ready
      if (!this.image.ready) {
        ctx.beginPath();
        ctx.arc(x, y, parseInt(this.width/2), 0, PI2, false);

        ctx.fillStyle = this.colorInt.getColor();
        ctx.fill();

        ctx.lineWidth = 1;
        ctx.strokeStyle = this.color.getColor();
        ctx.stroke();

        if (this.active) {
          ctx.strokeStyle = this.colorInt.borderColor();
          ctx.beginPath();
          ctx.arc(x, y, parseInt(this.width/2)-2, 0, PI2, false);
          ctx.stroke();
        }

        // if has trace
        if (this.trace) {
          backCtx.strokeStyle = this.trace.getColor();
          backCtx.beginPath();
          backCtx.arc(x, y, parseInt(this.width/2), 0, PI2, false);
          backCtx.stroke();
        }
      }
      // if the control has an image and is ready
      else {
      	if ((this.image.complete) && (!this.setImage)) {
          ctx.drawImage(this.image, parseInt(x-this.image.width/2), parseInt(y-this.image.height/2));
        }

        // if has trace
        if (this.trace) {
          backCtx.save();
          backCtx.translate(x, y);
          backCtx.scale(parseInt(this.image.width/2), parseInt(this.image.height/2));

          backCtx.beginPath();
          backCtx.arc(0, 0, 1, 0, PI2, false);
          backCtx.restore();

          backCtx.lineWidth = 1;
          backCtx.strokeStyle = this.trace.getColor();
          backCtx.stroke();
        }
      }
    }

  }

  /**
   * Eval the constraint and change the position
   */
  descartesJS.GraphicControl.prototype.evalConst = function() {
    constraintPosition.set(this.x, this.y);

    cpos = this.newt.findZero(constraintPosition, 1/this.space.scale, true);
    this.x = cpos.x;
    this.y = cpos.y;
    this.evaluator.setVariable(this.xStr, this.x);
    this.evaluator.setVariable(this.yStr, this.y);
  }

  /**
   * Eval the constraint and change the position
   */
  descartesJS.GraphicControl.prototype.evalConstXoY = function() {
    evaluator = this.evaluator;

    tmp = evaluator.getVariable(this.constVar);

    evaluator.setVariable(this.constVar, this[this.constVar]);
    this[this.noConstVar] = evaluator.eval( this.constraint );

    evaluator.setVariable(this.xStr, this.x);
    evaluator.setVariable(this.yStr, this.y);

    evaluator.setVariable(this.constVar, tmp);
  }

  /**
   * Draw the graphic control text
   */
  descartesJS.GraphicControl.prototype.drawText = function(x, y) {
    ctx = this.ctx;
    evaluator = this.evaluator;

    // simpleText
    if (this.text.type == "simpleText") {
      ctx.fillStyle = this.color.getColor();
      ctx.font = this.font;
      ctx.textBaseline = "alphabetic";

      ctx.fillText(this.text.toString(evaluator.eval(this.decimals), this.fixed),
                   parseInt(x+1+this.width/2),
                   parseInt(y-1-this.height/2)
                  );
    }
    // rtfNode
    else {
      ctx.fillStyle = this.color.getColor();
      ctx.strokeStyle = this.color.getColor();
      ctx.textBaseline = "alphabetic";
      this.text.draw(ctx, parseInt(x+1+this.width/2), parseInt(y-1-this.height/2), this.decimals, this.fixed, "start", true, this.color.getColor());
    }
  }

  /**
   * Add the control to a espace and get the space container
   * @return {HTMLDiv} return the space container
   */
  descartesJS.GraphicControl.prototype.getContainer = function() {
    var spaces = this.parent.spaces;
    var space_i;
    // if the control is in a internal space
    for(var i=0, l=spaces.length; i<l; i++) {
      space_i = spaces[i];

      if (space_i.id == this.spaceID) {
        space_i.addCtr(this);
        this.zIndex = space_i.zIndex;
        // set the space to draw the control
        this.space = space_i;
        return space_i.graphicControlContainer;
      }
    }

    // if do not find the space return the first space
    spaces[0].addCtr(this);
    this.zIndex = spaces[0].zIndex;
    // set the space to draw the control
    this.space = spaces[0];
    return spaces[0].graphicControlContainer;
  }

  /**
   * Deactivate the graphic control removing the circle mark
   */
  descartesJS.GraphicControl.prototype.deactivate = function() {
    this.active = false;
    this.evaluator.setVariable(this.activoStr, 0);
    this.evaluator.setVariable(this.activeStr, 0);
    // this.evaluator.setVariable(this.mclickedStr, 0);
    this.evaluator.setVariable(this.mclicizquierdoStr, 0);
  }

  /**
   * Register the mouse and touch events
   */
  descartesJS.GraphicControl.prototype.addEvents = function() {
    var lastTime = 0;

    var self = this;

    this.click = false;
    this.over = false;
    this.active = false;

    // prevent the context menu display
    this.mouseCacher.oncontextmenu = function () { return false; };

    this.mouseCacher.addEventListener("touchstart", onTouchStart);
    this.mouseCacher.addEventListener("mousedown", onMouseDown);
    this.mouseCacher.addEventListener("mouseover", onMouseOver);
    this.mouseCacher.addEventListener("mouseout", onMouseOut);

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseDown(evt) {
      // remove the focus of the controls
      document.body.focus();

      evt.preventDefault();

      self.whichBtn = descartesJS.whichBtn(evt);

      if (self.whichBtn == "L") {
        if ((self.activeIfValue) && (self.over)) {
          self.parent.deactivateGraphiControls();
          self.click = self.active = true;

          self.evaluator.setVariable(self.activoStr, 1);
          self.evaluator.setVariable(self.activeStr, 1);

          self.evaluator.setVariable(self.mclickedStr, 0);
          self.evaluator.setVariable(self.mclicizquierdoStr, 0);

          self.posAnte = descartesJS.getCursorPosition(evt, self.container);
          self.prePos = { x: self.space.getAbsoluteX(self.x), y: self.space.getAbsoluteY(self.y) };

          self.evaluator.setVariable(self.mxStr, self.space.getRelativeX(self.posAnte.x));
          self.evaluator.setVariable(self.myStr, self.space.getRelativeY(self.posAnte.y));

          self.parent.update();

          window.addEventListener("mouseup", onMouseUp);
          window.addEventListener("mousemove", onMouseMove);
        }
      }
    }

    /**
     *
     * @param {Event} evt el evento lanzado por la accion de presionar un boton
     * @private
     */
    function onTouchStart(evt) {
      // remove the focus of the controls
      document.body.focus();

      evt.preventDefault();

      if (self.activeIfValue) {
        self.parent.deactivateGraphiControls();
        self.click = self.active = true;

        self.evaluator.setVariable(self.activoStr, 1);
        self.evaluator.setVariable(self.activeStr, 1);

        self.evaluator.setVariable(self.mclickedStr, 0);
        self.evaluator.setVariable(self.mclicizquierdoStr, 0);

        self.posAnte = descartesJS.getCursorPosition(evt, self.container);
        self.prePos = { x : self.space.getAbsoluteX(self.x), y : self.space.getAbsoluteY(self.y) };

        self.evaluator.setVariable(self.mxStr, self.space.getRelativeX(self.posAnte.x));
        self.evaluator.setVariable(self.myStr, self.space.getRelativeY(self.posAnte.y));

        self.parent.update();

        window.addEventListener("touchend", onMouseUp);
        window.addEventListener("touchmove", onMouseMove);
      }
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseUp(evt) {
      // remove the focus of the controls
      document.body.focus();

      evt.preventDefault();
      evt.stopPropagation();

      self.evaluator.setVariable(self.mclickedStr, 1);
      self.evaluator.setVariable(self.mclicizquierdoStr, 1);

      if ((self.activeIfValue) || (self.active)) {
        self.click = false;

        // remove all event listener
        window.removeEventListener("mouseup",   onMouseUp, false);
        window.removeEventListener("mousemove", onMouseMove, false);
        window.removeEventListener("touchend",  onMouseUp, false);
        window.removeEventListener("touchmove", onMouseMove, false);

        posNew = descartesJS.getCursorPosition(evt, self.container);

        self.posX = self.prePos.x - (self.posAnte.x - posNew.x);
        self.posY = self.prePos.y - (self.posAnte.y - posNew.y);

        self.evaluator.setVariable(self.xStr, self.space.getRelativeX(self.posX));
        self.evaluator.setVariable(self.yStr, self.space.getRelativeY(self.posY));
        self.evaluator.setVariable(self.mxStr, self.space.getRelativeX(posNew.x));
        self.evaluator.setVariable(self.myStr, self.space.getRelativeY(posNew.y));

        self.parent.updateControls();
        self.parent.update();

        self.mouseCacher.style.left = (self.space.getAbsoluteX(self.x)-self._w/2)+"px";
        self.mouseCacher.style.top = (self.space.getAbsoluteY(self.y)-self._h/2)+"px";
      }

      // deactivate control
      self.parent.deactivateGraphiControls();
    }

    var posNew;
    var tmpX;
    var tmpY;
    var cpos;

    /**
     *
     * @param {Event}
     * @private
     */
    function onMouseMove(evt) {
      evt.preventDefault();

      self.evaluator.setVariable(self.mclickedStr, 0);
      self.evaluator.setVariable(self.mclicizquierdoStr, 0);

      posNew = descartesJS.getCursorPosition(evt, self.container);

      self.posX = self.prePos.x - (self.posAnte.x - posNew.x);
      self.posY = self.prePos.y - (self.posAnte.y - posNew.y);

      self.evaluator.setVariable(self.xStr, self.space.getRelativeX(self.posX));
      self.evaluator.setVariable(self.yStr, self.space.getRelativeY(self.posY));
      self.evaluator.setVariable(self.mxStr, self.space.getRelativeX(posNew.x));
      self.evaluator.setVariable(self.myStr, self.space.getRelativeY(posNew.y));

      // limit the number of updates in the lesson
      if (Date.now()-lastTime > 20) {
        // update the controls
        self.parent.updateControls();
        self.parent.update();

        lastTime = Date.now();
      }
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseOver(evt) {
      self.over = true;
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseOut(evt) {
      self.over = false;
      self.click = false;
    }

  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS, babel) {
  if (descartesJS.loadLib) { return descartesJS; }

  var temp;
  var babelValue;
  var values_i_0;
  var values_i_1;
  var spaceObj;
  var controlObj;
  var graphicObj;
  var auxiliarObj;
  var regExpImage = /[\w-//]*(\.png|\.jpg|\.gif|\.svg)/gi;

  var theAction_action;
  var theAction_parent;
  var theAction_parameter;

  var splitValues;
  var pos;
  var i;
  var initToken;
  var initPosToken;
  var endPosToken;
  var stringToken;
  var valueToken;
  var charAt;

  var splitString;
  var parenthesesStack;
  var lastSplitIndex;

  var tmpColor;
  var splitColor;
  var hexColor;

  var subtitleFontSize;
  var plecaObj;
  var paddingSides = 15;
  var image;
  var imageHeight;
  var divTitle;
  var divSubTitle;
  var tempDiv;
  var tempDivHeight;
  var tempFontSize;
  var noLines;
  var tempDecrement;
  var tmpIndexEqual;
  var tmpIndexSpace;

  var charAt;

  /**
   * Parser of principal elements of descartes
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   */
  descartesJS.LessonParser = function(parent) {
    this.parent = parent;

    this.parser = parent.evaluator.parser;

    this.RTFparser = new descartesJS.RTFParser(parent.evaluator);
  }

  /**
   * Parse the button configuration
   * @param {String} values is the string containing the values ​​that define the button configuration
   * @return {Object} return a configuration object with the corresponding values
   */
  descartesJS.LessonParser.prototype.parseButtonsConfig = function(values) {
    // default values
    var buttonConfigObj = { rowsNorth: 0, rowsSouth: 0, widthEast: 125, widthWest: 125, height: 23 };

    // remove the single quotation marks of the string of values, and divides the values in parameter name and value
    values = this.split(values);

    // traverse all values and asign to variables of the button configuration
    for(var i=0, l=values.length; i<l; i++) {
      values_i_0 = values[i][0];
      values_i_1 = values[i][1];

      babelValue = babel[values_i_0];

      switch(babelValue) {
        //
        case("rowsNorth"):
        case("rowsSouth"):
        case("widthEast"):
        case("widthWest"):
        case("height"):
          buttonConfigObj[babelValue] = parseInt(values_i_1);
          break;

        //
        case("about"):
        case("config"):
        case("init"):
        case("clear"):
          buttonConfigObj[babelValue] = (babel[values_i_1] === "true");
          break;

        // any variable missing
        default:
          console.log("Propiedad de botones no identificada: <" + values_i_0 + "> valor: <" + values_i_1 + ">");
          break;
      }
    }

    return buttonConfigObj;
  }

  /**
   * Parse and create a space
   * @param {String} values is the string containing the values ​​that define the space
   * @return {Space} return a space constructed with the correspondign values
   */
  descartesJS.LessonParser.prototype.parseSpace = function(values) {
    // object containing all the values ​​found in values
    spaceObj = {};

    // remove the single quotation marks of the string of values, and divides the values in parameter name and value
    values = this.split(values);

    // traverse all values and asign to variables to the space
    for(var i=0, l=values.length; i<l; i++) {
      values_i_0 = values[i][0];
      values_i_1 = values[i][1];

      babelValue = babel[values_i_0];

      //////////////////////////////////////////
      descartesJS.DEBUG.paramName = values_i_0;
      descartesJS.DEBUG.objectName = "Space";
      //////////////////////////////////////////

      switch(babelValue) {
        // identifier
        case("id"):
          // get the id for the debug
          descartesJS.DEBUG.idName = values_i_1;
        // text of the X axis
        case("x_axis"):
        // text of the Y axis
        case("y_axis"):
        // the type of the space (2D, 3D or another)
        case("type"):
        // control identifier (for rtf positioning)
        case("cID"):
        // file name of an external space
        case("file"):
        // information
        case("info"):
          spaceObj[babelValue] = values_i_1;
          break;

        // fixed condition
        case("fixed"):
        // condition to show the numbers in the space
        case("numbers"):
        // sensitive to mouse movements condition
        case("sensitive_to_mouse_movements"):
        // space 3D
        case("R3"):
        // split option for the render
        case("split"):
        // resizable
        case("resizable"):
          spaceObj[babelValue] = (babel[values_i_1] === "true");
          break;

        // how the background image is positioned
        case("bg_display"):
        // render mode sort, painter, raytrace
        case("render"):
          spaceObj[babelValue] = babel[values_i_1];
          break;

        // color of the net
        case("net"):
        // color of the net 10
        case("net10"):
        // color of the axis
        case("axes"):
        // color of the coordinate text of the mouse
        case("text"):
          if (values_i_1 != "") {
            spaceObj[babelValue] = (babel[values_i_1] === "false") ? "" : new descartesJS.Color(values_i_1, this.parent.evaluator);
          }
          else {
            spaceObj[babelValue] = "";
          }
          break;

        // x position of origin
        case("O.x"):
          spaceObj["OxExpr"] = values_i_1;
          break;

        // y position of origin
        case("O.y"):
          spaceObj["OyExpr"] = values_i_1;
          break;

        // background image
        case("image"):
          spaceObj["imageSrc"] = values_i_1;
          break;

        // x position
        case("x"):
          temp = values_i_1;

          // if specified with a percentage use the parent container's width to get the value in pixels
          if (temp[temp.length-1] === "%") {
            spaceObj["xPercentExpr"] = temp.trim();
            temp = (this.parent.container.width*parseFloat(temp)/100).toString();
          }
          // if not specified with a percentage get the numerical value of the position in x
          else {
            temp = values_i_1;
          }

          spaceObj["xExpr"] = this.parser.parse(temp);
          break;

        // y position
        case("y"):
          temp = values_i_1;

          // if specified with a percentage use the parent container's height to get the value in pixels
          if (temp[temp.length-1] === "%") {
            spaceObj["yPercentExpr"] = temp.trim();
            temp = (this.parent.container.height*parseFloat(temp)/100).toString();
          }
          // if not specified with a percentage get the numerical value of the position in y
          else {
            temp = values_i_1;
          }

          spaceObj["yExpr"] = this.parser.parse(temp);
          break;

        // width
        case("width"):
          temp = values_i_1.trim();
          spaceObj["wModExpr"] = temp;

          // if specified with a percentage use the parent container's width to get the value in pixels
          if (temp[temp.length-1] === "%") {
            spaceObj["wExpr"] = temp;
            temp = this.parent.container.width*parseFloat(temp)/100;
          }
          // if not specified with a percentage get the numerical value of the width
          else {
            temp = parseFloat(values_i_1);

            // whether to convert the value to a number the values ​​are different, then the width becomes the width of the parent container
            if (temp != values_i_1) {
              temp = this.parent.container.width; // default value
              spaceObj["_w_"] = values_i_1.trim();
            }
          }

          spaceObj["w"] = temp;
          break;

        // height
        case("height"):
          temp = values_i_1.trim();
          spaceObj["hModExpr"] = temp;
          
          // if specified with a percentage use the parent container's height to get the value in pixels
          if (temp[temp.length-1] === "%") {
            spaceObj["hExpr"] = temp;
            temp = this.parent.container.height*parseFloat(temp)/100;
          }
          // if not specified with a percentage get the numerical value of the height
          else {
            temp = parseFloat(values_i_1);

            // whether to convert the value to a number the values ​​are different, then the height becomes the height of the parent container
            if (temp != values_i_1) {
              temp = this.parent.container.height; // default value
              spaceObj["_h_"] = values_i_1.trim()
            }
          }

          spaceObj["h"] = temp;
          break;

        // drawif condition
        case("drawif"):
          if (values_i_1 != "") {
            spaceObj["drawif"] = this.parser.parse(values_i_1);
          }
          break;

        // scale
        case("scale"):
          temp = parseFloat(values_i_1);

          // whether to convert the value to a number the values ​​are different, then use the default value
          // this case ocurrs when the scale has a no valid value
          // if (temp.toString() != values_i_1) {
          if (isNaN(temp)) {
            temp =  48; // default value
          }

          spaceObj["scale"] = temp;
          break;

        // background color
        case("background"):
          spaceObj["background"] = new descartesJS.Color(values_i_1, this.parent.evaluator);
          break;

        // any variable missing
        default:
          console.log("Propiedad del espacio no identificada: <" + values_i_0 + "> valor: <" + values_i_1 + ">");
          break;
      }
    }

    // construct the space
    switch(spaceObj.type) {
      case("R2"):
        return new descartesJS.Space2D(this.parent, spaceObj);
        break;

      case("R3"):
        return new descartesJS.Space3D(this.parent, spaceObj);
        break;

      case("AP"):
        return new descartesJS.SpaceAP(this.parent, spaceObj);
        break;

      case("HTMLIFrame"):
        return new descartesJS.SpaceHTML_IFrame(this.parent, spaceObj);
        break;

      // Descartes 2
      default:
        return new descartesJS.Space2D(this.parent, spaceObj);
        break;
    }
  }

  /**
   * Parse and create a control
   * @param {String} values is the string containing the values ​​that define the control
   * @return {Control} return a control constructed with the correspondign values
   */
  descartesJS.LessonParser.prototype.parseControl = function(values) {
    // object containing all the values ​​found in values
    controlObj = { type: "numeric" };

    // remove the single quotation marks of the string of values, and divides the values in parameter name and value
    values = this.split(values);

    // traverse all values and asign to variables to the control
    for (var i=0, l=values.length; i<l; i++) {
      values_i_0 = values[i][0];
      values_i_1 = values[i][1];

      babelValue = babel[values_i_0];

      //////////////////////////////////////////
      descartesJS.DEBUG.paramName = values_i_0;
      descartesJS.DEBUG.objectName = "Control";
      //////////////////////////////////////////

      switch(babelValue) {
        // identifier
        case("id"):
          // get the id for the debug
          descartesJS.DEBUG.idName = values_i_1;
        // name
        case("name"):
        // parameter of the action
        case("parameter"):
        // tooltip
        case("tooltip"):
        // font tooltip
        case("tooltipFont"):
        // explanation
        case("Explanation"):
        // font explanation
        case("ExplanationFont"):
        // control identifier (for rtf positioning)
        case("cID"):
        // control menu options
        case("options"):
        // control graphic text font
        case("font"):
        // control graphic text font
        case("font_family"):
        // file name of a video or audio control
        case("file"):
        // answer pattern
        case("answer"):
        // css class
        case("cssClass"):
        // css class
        case("radio_group"):        
        // information
        case("info"):
          controlObj[babelValue] = values_i_1;
          break;

        // interface (spinner, button, etc)
        case("gui"):
        // region
        case("region"):
        // action
        case("action"):
        // relative position of control mesagges
        case("msg_pos"):
        // video control poster image
        case("poster"):
        // text alignment
        case("text_align"):
        // image alignment
        case("image_align"):
          controlObj[babelValue] = babel[values_i_1];
          break;

        // condition to use fixed notation in the text
        case("fixed"):
        // visible condition
        case("visible"):
        // condition for the discrete increment
        case("discrete"):
        // condition for a only text control
        case("onlyText"):
        // condition to evaluate the control
        case("evaluate"):
        // condition to auto play a video or audio control
        case("autoplay"):
        // condition to loop a video or audio control
        case("loop"):
        // condition to show the controls of a video or audio control
        case("controls"):
        // condition to show or remove the gradient in the buttons
        case("flat"):
          controlObj[babelValue] = (babel[values_i_1] === "true");
          break;

        // color text
        case("color"):
        // color-int text
        case("colorInt"):
        // control graphic trace
        case("trace"):
          controlObj[babelValue] = new descartesJS.Color(values_i_1, this.parent.evaluator);
          break;

        // font size
        case("font_size"):
        // drawif condition
        case("drawif"):
        // activeif condition
        case("activeif"):
        // number of decimals of the text in the graphic control
        case("decimals"):
        // minimum value
        case("min"):
        // maximum value
        case("max"):
        // control graphic size
        case("size"):
          if (values_i_1 !== "") {
            controlObj[babelValue] = this.parser.parse(values_i_1);
          }
          break;

        // control graphic constraint
        case("constraint"):
          controlObj["constraintExpr"] = values_i_1;
          break;

        // image
        case("image"):
          controlObj["imageSrc"] = values_i_1;
          break;

        // id of the containing space
        case("space"):
          controlObj["spaceID"] = values_i_1;
          break;

        // type
        case("type"):
          controlObj["type"] = babel[values_i_1.trim()];
          break;

        // expresion of the position and size
        case("expresion"):
          controlObj["expresion"] = this.parser.parse(values_i_1.replace(")(", ","));
          break;

        // border color of the text
        case("borderColor"):
          controlObj[babelValue] = (babel[values_i_1] === "false") ? "" : values_i_1;
          break;

        // bold text contidition
        case("bold"):
          if (babel[values_i_1] != "false") {
            controlObj["bold"] = "bold";
          }
          break;

        // italic text condition
        case("italics"):
          if (babel[values_i_1] != "false") {
            controlObj["italics"] = "italic";
          }
          break;

        // underline text condition
        case("underlined"):
          if (babel[values_i_1] != "false") {
            controlObj["underlined"] = true;
          }
          break;

        // value
        case("value"):
          var tmpVal = values_i_1.replace(/&squot;/g, "'");

          // replace the pipes with single quotation marks in the text value
          if (tmpVal.match(/^\|/)) {
            tmpVal = "'" + tmpVal.substring(1);
            if (tmpVal.match(/\|$/)) {
              tmpVal = tmpVal.substring(0, tmpVal.length-1) + "'";
            }
          }

          // the value expression for future evaluation
          controlObj["valueExpr"] = this.parser.parse(tmpVal);
          // the value string for reference
          controlObj["valueExprString"] = tmpVal;
          break;

        // increment
        case("incr"):
          if (values_i_1 != 0) {
            controlObj["incr"] = this.parser.parse(values_i_1);
          }
          break;

        // condition to show the text content in exponential notation
        case("exponentialif"):
          controlObj["exponentialif"] = parseFloat(values_i_1); // parse the posible expression
          break;

        // control graphic text
        case("text"):
          // the raw string
          controlObj["rawText"] = values_i_1;

          var tmpText = this.parseText(values_i_1);
          for (var ii=0, ll=tmpText.length; ii<ll; ii++) {
            tmpText[ii] = this.parser.parse(tmpText[ii], false);
          }

          controlObj["text"] = tmpText;
          break;

        // any variable missing
        default:
          var ind    = values_i_0.indexOf(".");
          var prefix = babel[values_i_0.substring(0,ind)];
          var sufix  = babel[values_i_0.substring(ind+1)];

          // find the font of the paramether
          if ((prefix === "parameter") && (sufix === "font")) {
            controlObj["parameterFont"] = values_i_1;
            break;

          // find the font of the explanation
          } else if ((prefix === "Explanation") && (sufix === "font")) {
            controlObj["ExplanationFont"] = values_i_1;
            break;

          // find the font of the tooltip
          } else if ((prefix === "tooltip") && (sufix === "font")) {
            controlObj["tooltipFont"] = values_i_1;
            break;
          }

          console.log("Propiedad de control no identificada: <" + values_i_0 + "> valor: <" + values_i_1 + ">");
          break;
      }
    }

    if (controlObj.type === "numeric") {
      switch (controlObj.gui) {
        case("spinner"):
          return new descartesJS.Spinner(this.parent, controlObj);
          break;

        case("button"):
          return new descartesJS.Button(this.parent, controlObj);
          break;

        case("textfield"):
          return new descartesJS.TextField(this.parent, controlObj);
          break;

        case("menu"):
          return new descartesJS.Menu(this.parent, controlObj);
          break;

        case("scrollbar"):
          return new descartesJS.Scrollbar(this.parent, controlObj);
          break;

        default:
          return new descartesJS.Spinner(this.parent, controlObj);
          break;
      }
    }

    else if (controlObj.type === "video") {
      return new descartesJS.Video(this.parent, controlObj);
    }

    else if (controlObj.type === "audio") {
      return new descartesJS.Audio(this.parent, controlObj);
    }

    else if (controlObj.type === "graphic") {
      return new descartesJS.GraphicControl(this.parent, controlObj);
    }

    else if (controlObj.type === "text") {
      return new descartesJS.TextArea(this.parent, controlObj);
    }

    else if (controlObj.type === "checkbox") {
      return new descartesJS.Checkbox(this.parent, controlObj);
    }

  }

  /**
   * Parse and create a graphic
   * @param {String} values is the string containing the values ​​that define the graphic
   * @param {Boolean} abs_coord is a boolean specifying the use of absolute coordinate in macro graphics
   * @param {Boolena} background is a boolean specifying that draw in the background the macro graphics
   * @param {Node} rotateExp is a expression that specify a rotation for the macro graphics
   * @return {Graphic} return a graphic constructed with the correspondign values
   */
  descartesJS.LessonParser.prototype.parseGraphic = function(values, abs_coord, background, rotateExp) {
    // object containing all the values ​​found in values
    graphicObj = { rotateExp: rotateExp, parameter: "t" };

    // remove the single quotation marks of the string of values, and divides the values in parameter name and value
    values = this.split(values);

    // traverse all values and asign to variables del graphic
    for(var i=0, l=values.length; i<l; i++) {
      values_i_0 = values[i][0];
      values_i_1 = values[i][1];

      babelValue = babel[values_i_0];

      //////////////////////////////////////////
      descartesJS.DEBUG.paramName = values_i_0;
      descartesJS.DEBUG.objectName = "Graphic";
      //////////////////////////////////////////

      if (values_i_1 != "") {
        switch(babelValue) {
          // type
          case("type"):
            // get the type for the debug
            descartesJS.DEBUG.idName = values_i_1;
          // text alignment
          case("align"):
          // ancho text
          case("anchor"):
          // linedash
          case("lineDash"):
            graphicObj[babelValue] = babel[values_i_1];
            break;

          // condition to draw the graphic in the background
          case("background"):
          // type of coordinates
          case("abs_coord"):
          // visible condition
          case("visible"):
          // editable condition
          case("editable"):
          // condition to use fixed notation in the text
          case("fixed"):
          // arc condition to use vectors
          case("vectors"):
          // bold text contidition
          case("bold"):
          // italic text condition
          case("italics"):
          // underline text condition
          case("underlined"):
            graphicObj[babelValue] = (babel[values_i_1] === "true");
            break;

          // color
          case("color"):
          // fill color
          case("fill"):
          // equation fill+ color
          case("fillP"):
          // equation fill- color
          case("fillM"):
          // arrow color
          case("arrow"):
          // trace
          case("trace"):
            // patch for catala
            if (babel[values_i_1] === "false") {
              graphicObj[babelValue] = "";
            }
            else {
              graphicObj[babelValue] = new descartesJS.Color(values_i_1, this.parent.evaluator);
            }
            break;

          // family parameter
          case("family"):
          // parameter of a curve
          case("parameter"):
          // information
          case("info"):
          // text font
          case("font"):
          // text font_family
          case("font_family"):
          // macro name
          case("name"):
          // arc init angle
          case("init"):
          // arc end angle
          case("end"):
            graphicObj[babelValue] = values_i_1;
            break;

          // drawif condition
          case("drawif"):
          // width
          case("width"):
          // number of decimals of the text in the graphic
          case("decimals"):
          // size
          case("size"):
          // arrow spear size
          case("spear"):
          // arc center
          case("center"):
          // arc radius
          case("radius"):
          // border radius
          case("border_radius"):
          // image opacity
          case("opacity"):
          // image and macro rotation
          case("inirot"):
          // macro initial position
          case("inipos"):
          // range
          case("range"):
          // font size
          case("font_size"):
            if (values_i_1 != "") {
              graphicObj[babelValue] = this.parser.parse(values_i_1);
            }
            break;

          // space identifier
          case("space"):
            graphicObj["spaceID"] = values_i_1;
            break;

          // expression
          case("expresion"):
            if (values_i_1 != "") {
              if (graphicObj.type != "macro") {
                graphicObj["expresion"] = this.parser.parse(values_i_1);
                graphicObj["expresionString"] = values_i_1;
              } else {
                graphicObj["expresion"] = values_i_1;
              }
            }
            break;

          // text
          case("text"):
            // graphicObj["text"] = this.parseText(values_i_1);
            graphicObj["text"] = values_i_1;
            break;

          // file name
          case("file"):
            var fileTmp = values_i_1.replace(/&squot;/g, "'");
            if ((fileTmp.charAt(0) === "[") && (fileTmp.charAt(fileTmp.length-1) === "]")) {
              fileTmp = fileTmp.substring(1, fileTmp.length-1);
            }
            // explicit image file name
            if (fileTmp.match(regExpImage)) {
              fileTmp = "'" + fileTmp + "'";
            }
            graphicObj["file"] = this.parser.parse(fileTmp);
            break;

          // color border
          case("border"):
            if ( (values_i_1 != "") && (babel[values_i_1] != "false") ) {
              graphicObj["border"] = new descartesJS.Color(values_i_1, this.parent.evaluator);
            }
            break;

          // any variable missing
          default:
            if (graphicObj["family"] != undefined) {
              if (values_i_0.substring(0, graphicObj["family"].length+1) === (graphicObj["family"] + ".")) {

                switch(babel[values_i_0.substring(graphicObj["family"].length+1)]) {

                  // find the interval variable of a family
                  case("interval"):
                    if (values_i_1 != "") {
                      graphicObj["family_interval"] = this.parser.parse(values_i_1);
                    }
                    break;

                  // find the number of steps in the family
                  case("steps"):
                    if (values_i_1 != "") {
                      graphicObj["family_steps"] = this.parser.parse(values_i_1);
                    }
                    break;
                }
                break;
              }
            }

            if (graphicObj["parameter"] != undefined) {

              if (values_i_0.match(graphicObj["parameter"] + ".")) {

                // default parameter in a macro
                if (graphicObj["parameter"] !== values_i_0.substring(0, values_i_0.indexOf(graphicObj["parameter"]) +graphicObj["parameter"].length)) {
                  graphicObj["parameter"] = values_i_0.substring(0, values_i_0.indexOf(graphicObj["parameter"]) +graphicObj["parameter"].length);
                }

                switch (babel[values_i_0.substring(graphicObj["parameter"].length +1)]) {

                  // find the interval variable of a parameter
                  case("interval"):
                    if (values_i_1 != "") {
                      graphicObj["parameter_interval"] = this.parser.parse(values_i_1);
                    }
                    break;

                  // find the number of steps in the parameter
                  case("steps"):
                    if (values_i_1 != "") {
                      graphicObj["parameter_steps"] = this.parser.parse(values_i_1);
                    }
                    break;
                }
                break;
              }
            }

            console.log("Propiedad del grafico no identificada: <" + values_i_0 + "> valor: <" + values_i_1 +">");
            break;
        }
      } // end switch

    } // end if

    // MACRO //
    // when absolute coordinates are used
    if (abs_coord) {
      graphicObj.abs_coord = abs_coord;
    }
    // if have to draw the macro in the background
    if (background) {
      graphicObj.background = background;
    }
    // MACRO //

    switch(graphicObj.type) {
      case("text"):
        return new descartesJS.Text(this.parent, graphicObj);
        break;

      case("image"):
        return new descartesJS.Image(this.parent, graphicObj);
        break;

      case("point"):
        return new descartesJS.Point(this.parent, graphicObj);
        break;

      case("polygon"):
        return new descartesJS.Polygon(this.parent, graphicObj);
        break;

      case("arc"):
        return new descartesJS.Arc(this.parent, graphicObj);
        break;

      case("segment"):
        return new descartesJS.Segment(this.parent, graphicObj);
        break;

      case("arrow"):
        return new descartesJS.Arrow(this.parent, graphicObj);
        break;

      case("macro"):
        return new descartesJS.Macro(this.parent, graphicObj);
        break;

      case("curve"):
        return new descartesJS.Curve(this.parent, graphicObj);
        break;

      case("equation"):
        return new descartesJS.Equation(this.parent, graphicObj);
        break;

      case("sequence"):
        return new descartesJS.Sequence(this.parent, graphicObj);
        break;

      case("rectangle"):
        return new descartesJS.Rectangle(this.parent, graphicObj);
        break;

      case("fill"):
        return new descartesJS.Fill(this.parent, graphicObj);
        break;

      default:
        break;
    }

  }

  /**
   * Parse and create a 3D graphic
   * @param {String} values is the string containing the values ​​that define the 3D graphic
   * @param {Boolean} abs_coord is a boolean specifying the use of absolute coordinate in macro graphics
   * @param {Boolena} background is a boolean specifying that draw in the background the macro graphics
   * @param {Node} rotateExp is a expression that specify a rotation for the macro graphics
   * @return {3DGraphic} return a 3D graphic constructed with the correspondign values
   */
  descartesJS.LessonParser.prototype.parse3DGraphic = function(values, abs_coord, background, rotateExp) {
    // object containing all the values ​​found in values
    graphicObj = { rotateExp:rotateExp };
    graphicObj["parameter"] = "t";

    // remove the single quotation marks of the string of values, and divides the values in parameter name and value
    values = this.split(values);

    // traverse all values and asign to variables del graphic
    for(var i=0, l=values.length; i<l; i++) {
      values_i_0 = values[i][0];
      values_i_1 = values[i][1];

      babelValue = babel[values_i_0];

      //////////////////////////////////////////
      descartesJS.DEBUG.paramName = values_i_0;
      descartesJS.DEBUG.objectName = "Graphic3D";
      //////////////////////////////////////////

      switch(babelValue) {
        // type
        case("type"):
        // get the type for the debug
        descartesJS.DEBUG.idName = values_i_1;
        // ilumination model
        case("model"):
        // linedash
        case("lineDash"):
          graphicObj[babelValue] = babel[values_i_1];
          break;

        // fill color of the curve
        case("fill"):
          // patch for catala
          graphicObj[babelValue] = (babel[values_i_1] === "false") ? "" : new descartesJS.Color(values_i_1, this.parent.evaluator);
          break;

        // condition to draw the graphic in the background
        case("background"):
        // condition to use fixed notation in the text
        case("fixed"):
        // condition to calculate the intersection edges of faces
        case("split"):
        // bold text contidition
        case("bold"):
        // italic text condition
        case("italics"):
        // underline text condition
        case("underlined"):
          graphicObj[babelValue] = (babel[values_i_1] === "true");
          break;

        // condition to draw the edges
        case("edges"):
        // patch for catala
        if (babel[values_i_1] === "false") {
          graphicObj[babelValue] = "";
        }
        else {
          if (babel[values_i_1] === "true") {
            values_i_1 = "808080";
          }
          graphicObj[babelValue] = new descartesJS.Color(values_i_1, this.parent.evaluator);
        }
        break;

        // color
        case("color"):
        // back face color
        case("backcolor"):
          graphicObj[babelValue] = new descartesJS.Color(values_i_1, this.parent.evaluator);
          break;

        // drawif condition
        case("drawif"):
        // width
        case("width"):
        // lenght
        case("length"):
        // height
        case("height"):
        // R
        case("R"):
        // r
        case("r"):
        // number of decimals of the text in the graphic
        case("decimals"):
        // Nu parameter
        case("Nu"):
        // Nv parameter
        case("Nv"):
        // initial position
        case("inipos"):
        // end position
        case("endpos"):
        // slope angle of the text
        case("offset_angle"):
        // offset from the point to the text
        case("offset_dist"):
        // font size
        case("font_size"):
          if (values_i_1 != "") {
            graphicObj[babelValue] = this.parser.parse(values_i_1);
          }
          break;

        // family parameter
        case("family"):
        // curve parameter
        case("parameter"):
        // font text
        case("font"):
        // text font_family
        case("font_family"):
        // name
        case("name"):
        // initial rotation
        case("inirot"):
        // end rotation
        case("endrot"):
        // information
        case("info"):
          graphicObj[babelValue] = values_i_1;
          break;

        // space identifier
        case("space"):
          graphicObj["spaceID"] = values_i_1;
          break;

        // expression
        case("expresion"):
          if ((graphicObj.type != "macro") && (graphicObj.type != "curve") && (graphicObj.type != "surface")) {
            graphicObj["expresion"] = this.parser.parse(values_i_1);
            graphicObj["expresionString"] = values_i_1;
          } else {
            // graphicObj["expresion"] = values_i_1.replace(/\\n/g, " ").replace(/;/g, " ");
            graphicObj["expresion"] = values_i_1.replace(/\\n/g, ";");
          }
          break;

        // text
        case("text"):
          graphicObj["text"] = values_i_1;

          // var tmpText = this.parseText(values_i_1);

          // for (var ii=0, ll=tmpText.length; ii<ll; ii++) {
          //   tmpText[ii] = this.parser.parse(tmpText[ii], false);
          // }
          // graphicObj["text"] = tmpText;
          break;

        // file name
        case("file"):
          var fileTmp = values_i_1.replace(/&squot;/g, "'");

          if ((fileTmp.charAt(0) === "[") && (fileTmp.charAt(fileTmp.length-1) === "]")) {
            fileTmp = fileTmp.substring(1, fileTmp.length-1);
          }

          if (fileTmp.match(/./)) {
            fileTmp = "'" + fileTmp + "'";
          }

          graphicObj["file"] = this.parser.parse(fileTmp);
          break;

        //
        default:
          if (graphicObj["family"] !== undefined) {
            if (values_i_0.substring(0, graphicObj["family"].length+1) === (graphicObj["family"] + ".")) {

              // family interval
              if (babel[values_i_0.substring(graphicObj["family"].length+1)] === "interval") {
                if (values_i_1 != "") {
                  graphicObj["family_interval"] = this.parser.parse(values_i_1);
                }
                break;
              }
              // family steps
              else {
                if (values_i_1 != "") {
                  graphicObj["family_steps"] = this.parser.parse(values_i_1);
                }
                break;
              }
            }
          }

          console.log("Propiedad del grafico 3D no identificada: <" + values_i_0 + "> valor: <" + values_i_1 +">");
          break;
      }
    }
    switch(graphicObj.type) {
      case("point"):
        return new descartesJS.Point3D(this.parent, graphicObj);
        break;

      case("segment"):
        return new descartesJS.Segment3D(this.parent, graphicObj);
        break;

      case("polygon"):
        return new descartesJS.Polygon3D(this.parent, graphicObj);
        break;

      case("curve"):
        return new descartesJS.Curve3D(this.parent, graphicObj);
        break;

      case("triangle"):
        return new descartesJS.Triangle3D(this.parent, graphicObj);
        break;

      case("face"):
        return new descartesJS.Face3D(this.parent, graphicObj);
        break;

      case("polireg"):
        return new descartesJS.Polireg3D(this.parent, graphicObj);
        break;

      case("surface"):
        return new descartesJS.Surface3D(this.parent, graphicObj);
        break;

      case("text"):
        return new descartesJS.Text3D(this.parent, graphicObj);
        break;

      case("cube"):
      case("box"):
      case("tetrahedron"):
      case("octahedron"):
      case("sphere"):
      case("dodecahedron"):
      case("icosahedron"):
      case("ellipsoid"):
      case("cone"):
      case("cylinder"):
      case("torus"):
      case("mesh"):
        return new descartesJS.OtherGeometry(this.parent, graphicObj);
        break;

      case("macro"):
        return new descartesJS.Macro3D(this.parent, graphicObj);
        break;

      default:
        // console.log(graphicObj.type);
        break;
    }
  }

  /**
   * Parse and create an auxiliar
   * @param {String} values is the string containing the values ​​that define the auxiliar
   * @return {Auxiliary} return a auxiliar constructed with the correspondign values
   */
  descartesJS.LessonParser.prototype.parseAuxiliar = function(values) {
    // object containing all the values ​​found in values
    auxiliarObj = {};

    // remove the single quotation marks of the string of values, and divides the values in parameter name and value
    values = this.split(values);

    for(var i=0, l=values.length; i<l; i++) {
      values[i][1] = (values[i][1]).replace(/&squot;/g, "'");
    }

    // traverse all values and asign to variables del auxiliar
    for(var i=0, l=values.length; i<l; i++) {
      values_i_0 = values[i][0];
      values_i_1 = values[i][1];

      babelValue = babel[values_i_0];

      //////////////////////////////////////////
      descartesJS.DEBUG.paramName = values_i_0;
      descartesJS.DEBUG.objectName = "Auxiliar";
      //////////////////////////////////////////

      switch(babelValue) {
        // information
        case("info"):
        // code
        case("code"):
          auxiliarObj[babelValue] = values_i_1;
          break;

        // identifier
        case("id"):
          // get the id for the debug
          descartesJS.DEBUG.idName = values_i_1;
        // file name of a vector
        case("file"):
        // init expression
        case("init"):
        // do expression
        case("doExpr"):
        // while expression
        case("whileExpr"):
        // function range
        case("range"):
        // local variables
        case("local"):
        // expression
        case("expresion"):
        // event condition
        case("condition"):
        // event parameter
        case("parameter"):
          auxiliarObj[babelValue] = values_i_1.replace(/&squot;/g, "'");
          break;

        // editable condition
        case("editable"):
        // constant condition
        case("constant"):
        // vector condition
        case("array"):
        // matrix condition
        case("matrix"):
        // algorithm condition
        case("algorithm"):
        // event expression
        case("event"):
        // sequence condition
        case("sequence"):
          auxiliarObj[babelValue] = (babel[values_i_1] === "true");
          break;

        // number of elements in a vector
        case("size"):
        // number of rows in a matrix
        case("rows"):
        // number of columns in a matrix
        case("columns"):
        // x
        case("x"):
        // y
        case("y"):
        // width
        case("width"):
        // height
        case("height"):
          auxiliarObj[babelValue] = this.parser.parse(values_i_1);
          break;

        // type of evaluation
        case("evaluate"):
        // // event expression
        // case("event"):
        // execution expression of an event
        case("execution"):
        // relative position of event mesagges
        case("msg_pos"):
        // event action
        case("action"):
        // type
        case("type"):
          auxiliarObj[babelValue] = babel[values_i_1];
          break;
        //////////////////////////////

        // library documentation
        case("doc"):
          break;

        // any variable missing
        default:
          var ind    = values_i_0.indexOf(".");
          var prefix = babel[values_i_0.substring(0,ind)];
          var sufix  = babel[values_i_0.substring(ind+1)];

          // find the font of the paramether
          if ((prefix === "parameter") && (sufix === "font")) {
            auxiliarObj["parameterFont"] = values_i_1;
            break;
          }

          console.log("Propiedad del auxiliar no identificada: <" + values_i_0 + "> valor: <" + values_i_1 + ">");
          break;
      }
    }

    if (auxiliarObj.sequence) {
      auxiliarObj.type = "sequence";
    }
    else if (auxiliarObj.constant) {
      auxiliarObj.type = "constant";
    }
    else if ((auxiliarObj.algorithm) && (auxiliarObj.evaluate)) {
      auxiliarObj.type = "algorithm";
    }
    else if ((auxiliarObj.array) && (!auxiliarObj.matrix) && (auxiliarObj.id.charAt(auxiliarObj.id.length-1) != ")")) {
      auxiliarObj.type = "vector";
    }
    else if ((auxiliarObj.matrix) && (auxiliarObj.id.charAt(auxiliarObj.id.length-1) != ")")) {
      auxiliarObj.type = "matrix";
    }
    else if ((auxiliarObj.event) && (auxiliarObj.id.charAt(auxiliarObj.id.length-1) != ")")) {
      auxiliarObj.type = "event";
    }
    else if (auxiliarObj.type === "library") {
      auxiliarObj.type = "library";
    }
    else if (auxiliarObj.type === "jsfun") {
      auxiliarObj.type = "jsfun";
    }
    else {
      if (auxiliarObj.id.charAt(auxiliarObj.id.length-1) === ")") {
        auxiliarObj.type = "function";
      }
      else {
        auxiliarObj.type = "variable";
      }
    }
    descartesJS.DEBUG.typeName = auxiliarObj.type;

    switch(auxiliarObj.type) {
      case("sequence"):
        var auxS = new descartesJS.Function(this.parent, auxiliarObj);
        break;

      case("constant"):
        // only once evaluation
        var auxC = new descartesJS.Constant(this.parent, auxiliarObj);

        // always evaluation
        if ((auxiliarObj.evaluate) && (auxiliarObj.evaluate === "always")) {
          this.parent.auxiliaries.push(auxC);
        }
        break;

      case("algorithm"):
        this.parent.auxiliaries.push( new descartesJS.Algorithm(this.parent, auxiliarObj) );
        break;

      case("vector"):
        // only once evaluation
        var auxV = new descartesJS.Vector(this.parent, auxiliarObj);

        // always evaluation
        if ((auxiliarObj.evaluate) && (auxiliarObj.evaluate === "always")) {
          this.parent.auxiliaries.push(auxV);
        }
        break;

      case("matrix"):
        // only once evaluation
        var auxM = new descartesJS.Matrix(this.parent, auxiliarObj);

        // always evaluation
        if ((auxiliarObj.evaluate) && (auxiliarObj.evaluate === "always")) {
          this.parent.auxiliaries.push(auxM);
        }
        break;

      case("event"):
        this.parent.events.push( new descartesJS.Event(this.parent, auxiliarObj) );
        break;

      case("library"):
        new descartesJS.Library(this.parent, auxiliarObj);
        break;

      case("function"):
        new descartesJS.Function(this.parent, auxiliarObj);
        break;

      case("variable"):
        new descartesJS.Variable(this.parent, auxiliarObj);
        break;

      case("jsfun"):
        new descartesJS.JsFunction(this.parent, auxiliarObj);
        break;

      default:
        break;
      
    }
  }

  /**
   * Parse and create an action
   * @param {String} theAction is the string containing the values ​​that define the action
   * @return {Action} return a action constructed with the correspondign values
   */
  descartesJS.LessonParser.prototype.parseAction = function(theAction) {
    theAction_action = theAction.action;
    theAction_parent = theAction.parent;
    theAction_parameter = theAction.parameter;

    // if has some action then create it
    if (theAction_action) {
      switch (theAction_action) {
        // show a message
        case("message"):
          return (new descartesJS.Message(theAction_parent, theAction_parameter));
          break;

        // performs calculations
        case("calculate"):
          return (new descartesJS.Calculate(theAction_parent, theAction_parameter));
          break;

        // open an URL
        case("openURL"):
          return (new descartesJS.OpenURL(theAction_parent, theAction_parameter));
          break;

        // open a scene
        case("openScene"):
          return (new descartesJS.OpenScene(theAction_parent, theAction_parameter));
          break;

        // show credits
        case("about"):
          return (new descartesJS.About(theAction_parent, theAction_parameter));
          break;

        // show the editor
        case("config"):
          return (new descartesJS.Config(theAction_parent, theAction_parameter));
          break;

        // init the scene
        case("init"):
          return (new descartesJS.Init(theAction_parent, theAction_parameter));
          break;

        // clear the trace
        case("clear"):
          return (new descartesJS.Clear(theAction_parent, theAction_parameter));
          break;

        // start the animation
        case("animate"):
          return (new descartesJS.Animate(theAction_parent, theAction_parameter));
          break;

        // init the animation
        case("initAnimation"):
          return (new descartesJS.InitAnimation(theAction_parent, theAction_parameter));
          break;

        // play audio
        case("playAudio"):
          return (new descartesJS.PlayAudio(theAction_parent, theAction_parameter));
          break;

        default:
          console.log("Accion no soportada: <" + theAction_action + ">");
          break;
      }
    }
    // if has not some action then return a function that does nothing
    else {
      return {execute : function() {}};
    }
  }

  /**
   * Parse and create an animation
   * @param {String} values is the string containing the values ​​that define the animation
   * @return {Animation} return a animation constructed with the correspondign values
   */
  descartesJS.LessonParser.prototype.parseAnimation = function(values) {
    // object containing all the values ​​found in values
    var animationObj = {};

    // remove the single quotation marks of the string of values, and divides the values in parameter name and value
    values = this.split(values);

    // traverse all values and asign to variables of the animation
    for(var i=0, l=values.length; i<l; i++) {
      values_i_0 = values[i][0];
      values_i_1 = values[i][1];

      babelValue = babel[values_i_0];

      switch(babelValue) {

        // identifier
        case("id"):
        // time delay
        case("delay"):
        // init expression
        case("init"):
        // do expression
        case("doExpr"):
        // while expression
        case("whileExpr"):
          animationObj[babelValue] = values_i_1.replace(/&squot;/g, "'");
          break;

        // condition to show the controls
        case("controls"):
        // condition to star automatically
        case("auto"):
        // condition to loop
        case("loop"):
        // algorithm condition
        case("algorithm"):
        // type of evaluation
        case("evaluate"):
          animationObj[babelValue] = (babel[values_i_1] === "true");
          break;

        // any variable missing
        default:
          console.log("Propiedad de la animacion no identificada: <" + values_i_0 + ">  <" + values_i_1 + ">");
          break;
      }
    }

    return (new descartesJS.Animation(this.parent, animationObj));
  }

  /**
   *
   */
  descartesJS.LessonParser.prototype.parsePleca = function(values, w) {
    // remove the single quotation marks of the string of values, and divides the values in parameter name and value
    values = this.split(values);

    // object containing all the values ​​found in values
    plecaObj = {
                title:        "",
                subtitle:     "",
                subtitlines:  0,
                bgcolor:      "#536891",
                fgcolor:      "white",
                align:        "left",
                titleimage:   "",
                titlefont:    "SansSerif,BOLD,20",
                subtitlefont: "SansSerif,PLAIN,18"
             };

    // traverse all values and asign to variables of the pleca
    for(var i=0, l=values.length; i<l; i++) {
      values_i_0 = values[i][0];
      values_i_1 = values[i][1];

      switch(values_i_0) {
        // title text
        case("title"):
          plecaObj.title = values_i_1;
          break;

        // subtitle text
        case("subtitle"):
          plecaObj.subtitle = values_i_1;
          break;

        // number of lines of the subtitle
        case("subtitlines"):
          plecaObj.subtitlines = values_i_1;
          break;

        // background color
        case("bgcolor"):
          if (values_i_1 != "") {
            plecaObj.bgcolor = (new descartesJS.Color(values_i_1, this.parent.evaluator)).getColor();
          }
          break;

        // text color
        case("fgcolor"):
          if (values_i_1 != "") {
            plecaObj.fgcolor = (new descartesJS.Color(values_i_1, this.parent.evaluator)).getColor();
          }
          break;

        // alignment
        case("align"):
          if (values_i_1 != "") {
            plecaObj.align = values_i_1;
          }
          break;

        // file image
        case("titleimage"):
          plecaObj.titleimage = values_i_1;
          break;

        // title font
        case("titlefont"):
          plecaObj.titlefont = (values_i_1 != "") ? descartesJS.convertFont(values_i_1) : descartesJS.convertFont(plecaObj.titlefont);
          break;

        // subtitle font
        case("subtitlefont"):
          plecaObj.subtitlefont = (values_i_1 != "") ? descartesJS.convertFont(values_i_1) : descartesJS.convertFont(plecaObj.subtitlefont);
          break;

        // any variable missing
        default:
          console.log("Propiedad de la pleca no identificada: <" + values_i_0 + ">  <" + values_i_1 + ">");
          break;
      }
    }

    // the pleca is empty
    if ((plecaObj.title === "") && (plecaObj.subtitle === "")) {
      return document.createElement("div");
    }

    // the subtitle font size
    subtitleFontSize = plecaObj.subtitlefont.substring(0, plecaObj.subtitlefont.indexOf("px"));
    subtitleFontSize = subtitleFontSize.substring(subtitleFontSize.lastIndexOf(" "));

    // the image and its height if it exists
    if (plecaObj.titleimage != "") {
      image = this.parent.getImage(plecaObj.titleimage);
      imageHeight = image.height;
    }

    // create the container
    plecaObj.divPleca = document.createElement("div");
    plecaObj.divPleca.setAttribute("id", "descartesPleca");

    // if there is an image, then the height of the pleca is adjusted to the height of the image
    if (imageHeight) {
      // plecaObj.divPleca.setAttribute("style", "position:absolute;left:0;top:0;text-align:" + plecaObj.align + ";width:" + (w-2*paddingSides) + "px;height:"+ (imageHeight-16) + "px;background:" + plecaObj.bgcolor + ";color:" + plecaObj.fgcolor + ";padding-top:8px;padding-bottom:8px;padding-left:" + paddingSides + "px;padding-right:" + paddingSides + "px;margin:0;overflow:hidden;z-index:100;");
      plecaObj.divPleca.setAttribute("style", "position:absolute;left:0;top:0;text-align:" + plecaObj.align + ";width:" + w + "px;height:"+ imageHeight + "px;background:" + plecaObj.bgcolor + ";color:" + plecaObj.fgcolor + ";padding-top:8px;padding-bottom:8px;padding-left:" + paddingSides + "px;padding-right:" + paddingSides + "px;margin:0;overflow:hidden;z-index:1;");

      image.setAttribute("style", "position: absolute;left:0;top:0;z-index:-1;width:100%;height:100%;");
      plecaObj.divPleca.appendChild(image);
    }
    // if there is not an image, the the height is not specified and the contaier guest the height
    else {
      // plecaObj.divPleca.setAttribute("style", "position:absolute;left:0;top:0;text-align:" + plecaObj.align + ";width:" + (w-2*paddingSides) + "px;background:" + plecaObj.bgcolor + ";color:" + plecaObj.fgcolor + ";padding-top:12px;padding-bottom:12px;padding-left:" + paddingSides + "px;padding-right:" + paddingSides + "px;margin:0;z-index:100;");
      plecaObj.divPleca.setAttribute("style", "position:absolute;left:0;top:0;text-align:" + plecaObj.align + ";width:" + w + "px;background:" + plecaObj.bgcolor + ";color:" + plecaObj.fgcolor + ";padding-top:12px;padding-bottom:12px;padding-left:" + paddingSides + "px;padding-right:" + paddingSides + "px;margin:0;z-index:100;");
    }

    // creates the container for the title and the content is added
    divTitle = document.createElement("div");
    divTitle.setAttribute("style", "padding:0;margin:0;font:" + plecaObj.titlefont + ";overflow:hidden;white-space:nowrap;");
    divTitle.innerHTML = plecaObj.title;

    // create the container for the subtitle
    divSubTitle = document.createElement("div");

    // if the number of lines of the subtitle is equal to 1 then the height of the subtitle fits only one line
    if (parseInt(plecaObj.subtitlines) === 1) {
      tempDecrement = 0;

      // creates a temporary container that serves as a substitute container for the subtitle, to determine the font size of the subtitle container
      tempDiv = document.createElement("div");
      tempDiv.innerHTML = plecaObj.subtitle;
      document.body.appendChild(tempDiv);
      tempFontSize = subtitleFontSize;

      do {
        tempFontSize = tempFontSize - tempDecrement;

        // style is assigned to temporary container to measure the number of lines in the text
        tempDiv.setAttribute("style", "padding:0;margin:0;font:" + plecaObj.subtitlefont + ";font-size:" + tempFontSize + "px;width:" + (w-2*paddingSides) + "px;line-height:" + tempFontSize + "px;")

        // find the height of the temporary container
        tempDivHeight = tempDiv.offsetHeight;
        // find the number of lines by dividing the height between the height of a line
        noLines = tempDivHeight / tempFontSize;

        tempDecrement = 1;
      }
      // If the number of lines is one or the font size becomes smaller than 8px then the search ends
      while ((noLines > 1) && (tempFontSize > 8));

      // temporary container is removed from the body
      document.body.removeChild(tempDiv);

      // assign to the subtitle style the proper font size
      divSubTitle.setAttribute("style", "padding:0;margin:0;font:" + plecaObj.subtitlefont + ";font-size:" + tempFontSize + "px;line-height:1em;overflow:hidden;white-space:nowrap;");
    }
    // if the number of lines is different from 1, then the number of lines is ignored
    else {
      divSubTitle.setAttribute("style", "padding:0;margin:0;font:" + plecaObj.subtitlefont + ";line-height:1em;");
    }
    // assign the content to the subtitle
    divSubTitle.innerHTML = plecaObj.subtitle;

    plecaObj.divPleca.appendChild(divTitle);
    plecaObj.divPleca.appendChild(divSubTitle);

    plecaObj.divPleca.imageHeight = imageHeight;
    return plecaObj.divPleca;
  }

  /**
   * Removes single quotes in the value and divided into an array of parameters name and value pairs
   * @param {String} values the string to divided
   * @return {Array<Array<String>>} return the array of name and value pairs
   */
  descartesJS.LessonParser.prototype.split = function(values) {
    if (typeof(values) != "string") {
      return [];
    }

    values = values || "";
    values = values.replace(/\\'/g, "’");

    splitValues = [];
    pos = i = initPosToken = endPosToken = 0;
    initToken = stringToken = valueToken = false;

    // traverse the string to split
    while (pos < values.length) {
      // ignoring the blank spaces if not started the identification of a token
      if ((values.charAt(pos) === " ") && (!initToken)) {
        pos++;
      }

      // find a character which is different from a blank space
      if ((values.charAt(pos) !== " ") && (!initToken)) {
        initToken = true;
        initPosToken = pos;
      }

      // values ​​are specified as a string
      if ((values.charAt(pos) === "=") && (values.charAt(pos+1) === "'") && (!stringToken)) {
        stringToken = true;

        splitValues[i] = [values.substring(initPosToken, pos)]

        initPosToken = pos+2;

        pos+=2;
      }

      if ((stringToken) && (values.charAt(pos) === "'")) {
        stringToken = false;

        initToken = false;

        splitValues[i].push(values.substring(initPosToken, pos));

        i++;
      }

      // values ​​are specified as a word sequence
      if ((values.charAt(pos) === "=") && (values.charAt(pos+1) !== "'") && (!stringToken)) {
        splitValues[i] = [values.substring(initPosToken, pos)]

        initPosToken = pos+1;

        pos++;

        // find the next space and equal sign
        tmpIndexEqual = (values.substring(pos)).indexOf("=");

        if (tmpIndexEqual === -1) {
          tmpIndexEqual = values.length;
          tmpIndexSpace = values.length;
        }
        else {
          tmpIndexEqual += pos;

          tmpIndexSpace = values.substring(pos, tmpIndexEqual).lastIndexOf(" ");
          if (tmpIndexSpace === -1) {
            tmpIndexSpace = values.length;
          }
          else {
            tmpIndexSpace += pos;
          }
        }

        splitValues[i].push(values.substring(initPosToken, tmpIndexSpace));
        i++;
        initToken = false;

        pos = tmpIndexSpace;
      }

      pos++;
    }

    return splitValues;
  }

  /**
   * Parse a text an construct a simple text or rtf text
   * @param {String} text the string text to parse
   * @param {Object} return a rtf text or a simple text
   */
  descartesJS.LessonParser.prototype.parseText = function(text) {
    text = text || "";
    // is a RTF text
    if (text.match(/^\{\\rtf1/)) {
      return this.RTFparser.parse(text.substring(10));
    }

    // is a simple text
    return new descartesJS.SimpleText(this.parent, text);
  }

  return descartesJS;
})(descartesJS || {}, babel);
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var evalArgument;
  var evalCache = {};

  var mathFloor = Math.floor;
  var lastChildIndex;
  var newRoot;
  var root;
  var right;
  descartesJS.fullDecimals = false;

  /**
   * Nodes of a parse tree
   * @param {String} type the type of the node
   * @param {Object} value the value of the node
   * @constructor
   */
  descartesJS.Node = function(type, value) {
    this.sep = "";
    this.type = type;
    this.value = value;
    this.parent = null;
    this.childs = [];
  }

  /**
   * Get the root of the parse tree
   * @return {Node} return the root of the parse tree
   */
  descartesJS.Node.prototype.getRoot = function() {
    if (this.parent === null) {
      return this;
    }
    return this.parent.getRoot();
  }

  /**
   * Add a child to the parse tree
   * @param {Node} child the child that want to add
   */
  descartesJS.Node.prototype.addChild = function(child) {
    child.parent = this;
    this.childs.push(child);
  }

  /**
   * Replace the last child in the parse tree with a new node
   * @param {Node} child the new child to replace the last child in the parse tree
   */
  descartesJS.Node.prototype.replaceLastChild = function(child) {
    lastChildIndex = this.childs.length-1,
    lastChild = this.childs[lastChildIndex];

    lastChild.parent = null;
    this.childs[lastChildIndex] = child;
    child.parent = this;

    return child;
  }

  /**
   * Decide if the parse tree contains a node with some value
   * @param {Node} value the value to find in the parse tree
   * @return {Boolean} return true if the value is in the parse tree or false if not
   */
  descartesJS.Node.prototype.contains = function(value) {
    if (this.value === value) {
      return true;
    }

    for (var i=0, l=this.childs.length; i<l; i++) {
      if (this.childs[i].contains(value)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Converts a parse tree with an equal operator as principal operator in a parse tree with a minus operator as a principal operator
   * @return {Node} return a new parse tree with the convertion of the principal operator
   */
  descartesJS.Node.prototype.equalToMinus = function() {
    if (this.type === "compOperator") {
      this.type = "operator";
      this.value = "-";

      root = new descartesJS.Node("compOperator", "==");
      right = new descartesJS.Node("number", "0");

      root.addChild(this);
      root.addChild(right);

      newRoot = this.getRoot();
      newRoot.setAllEvalFun();

      return newRoot;
    }

    return this;
  }

  /**
   * Register the evaluation functions to all the nodes in the tree
   */
   descartesJS.Node.prototype.setAllEvalFun = function() {
    this.setEvalFun();

    for (var i=0, l=this.childs.length; i<l; i++) {
      this.childs[i].setAllEvalFun();
    }
  }

  /**
   * Set the apropiate evaluate function for the node
   *
   */
  descartesJS.Node.prototype.setEvalFun = function() {
    // number
    if (this.type === "number") {
      this.evaluate = function(evaluator) {
        return parseFloat(this.value);
      }
    }

    // string
    else if (this.type === "string") {
      this.evaluate = function(evaluator) {
        return this.value.replace(/\\u0027/g, "'");
      }
    }

    // variable
    else if ( (this.type === "identifier") && (this.childs.length === 0) ) {
      if (this.value == "rnd") {
        this.evaluate = function(evaluator) {
          return Math.random();
        }
      }
      else {
        var variableValue;
        this.evaluate = function(evaluator, getMatrix) {
          variableValue = evaluator.variables[this.value];

          // the variable has an auxiliar variable value
          if ((typeof(variableValue) === "object") && (variableValue.length == undefined)) {
            return variableValue.evaluate(evaluator);
          }

          // if the name of the variable is the name of a matrix, for matrix operations
          // if ((getMatrix) && (evaluator.matrices[this.value])) {
          //   variableValue = evaluator.matrices[this.value];
          // }

          if (variableValue == undefined) {
            if (getMatrix || evaluator.matrices[this.value]) {
              variableValue = evaluator.matrices[this.value];
            }
            else if (evaluator.vectors[this.value]) {
              variableValue = evaluator.vectors[this.value];
            }
          }

          return (variableValue !== undefined) ? variableValue : 0;
        }
      }
    }

    // vector
    else if ( (this.type === "identifier") && (this.childs[0].type === "square_bracket") && (this.childs[0].childs.length === 1)) {
      var pos;
      var value;
      this.evaluate = function(evaluator) {
        pos = this.childs[0].childs[0].evaluate(evaluator);

        try {
          value = evaluator.vectors[this.value][(pos<0) ? 0 : mathFloor(pos)];
          return (value !== undefined) ? value : 0;
        }
        catch(e) {
          return 0;
        }
      }
    }

    // matrix
    else if ( (this.type === "identifier") && (this.childs[0].type === "square_bracket") && (this.childs[0].childs.length > 1)) {
      var pos1;
      var pos2;
      var value;
      this.evaluate = function(evaluator) {
        pos1 = this.childs[0].childs[0].evaluate(evaluator);
        pos2 = this.childs[0].childs[1].evaluate(evaluator);

        try {
          value = evaluator.matrices[this.value][(pos1<0) ? 0 : mathFloor(pos1)][(pos2<0) ? 0 : mathFloor(pos2)];
          return (value !== undefined) ? value : 0;
        }
        catch(e) {
          return 0;
        }
      }
    }

    // function
    else if ( (this.type === "identifier") && (this.childs[0].type === "parentheses") ) {
      var argu;
      var _asign;
      var tmp_ret;

      this.evaluate = function(evaluator) {
        argu = [];
        for (var i=0, l=this.childs[0].childs.length; i<l; i++) {
          argu[i] = this.childs[0].childs[i].evaluate(evaluator);
        }

        // _Eval_
        if (this.value === "_Eval_") {
          evalArgument = (argu.length > 0) ? argu[0] : 0;

          if (typeof(evalArgument) == "number") {
            return "NaN";
          }
          else {
            // check if the string is a number, then the argument needs to be a string
            if ( (evalArgument.match(",")) && (parseFloat(evalArgument.replace(",", ".")) == evalArgument.replace(",", ".")) ) {
              // evalArgument = "'" + evalArgument + "'";
              evalArgument = evalArgument.replace(",", ".");
            }

            if (evalCache[evalArgument] == undefined) {
              _asign = (evalArgument.match(/:=/g)) ? true : false;
            
              //////////////////////////////////////////////////////////////
              if (evalArgument.match(";")) {
                var inStr = false;
                var charAt;
                var valueArray = [];
                var lastIndex = 0;

                for (var i=0, l=evalArgument.length; i<l; i++) {
                  charAt = evalArgument.charAt(i);
                  // inside or outside of a string
                  if (charAt === "'") {
                    inStr = !inStr;
                  }

                  if ((!inStr) && (charAt === ";")) {
                    valueArray.push(evalArgument.substring(lastIndex, i));
                    lastIndex = i+1;
                  }
                }
                valueArray.push(evalArgument.substring(lastIndex));

                evalArgument = "(" + valueArray.join(")(") + ")";
              }
              //////////////////////////////////////////////////////////////

              evalCache[evalArgument] = evaluator.parser.parse(evalArgument, _asign);
            }

            tmp_ret = evaluator.eval( evalCache[evalArgument] );
            return (tmp_ret != undefined) ? tmp_ret : NaN;
          }
        }

        return evaluator.functions[this.value].apply(evaluator, argu);
      }
    }

    // operator
    else if (this.type === "operator") {
      if (this.value === "+") {
        this.evaluate = function(evaluator) {
          var op1 = this.childs[0].evaluate(evaluator, true);
          var op2 = this.childs[1].evaluate(evaluator, true);

          // numeric or string operation
          if ((op1.type !== "matrix") || (op2.type !== "matrix")) {
            if ((typeof(op1) == "number") && (typeof(op2) == "string")) {
              // op1 = descartesJS.removeNeedlessDecimals(op1.toFixed(30));
              op1 = descartesJS.removeNeedlessDecimals(op1.toString());
            }
            else if ((typeof(op1) == "string") && (typeof(op2) == "number")) {
              // op2 = descartesJS.removeNeedlessDecimals(op2.toFixed(30));
              op2 = descartesJS.removeNeedlessDecimals(op2.toString());
            }
            return op1 + op2;
          }
          // matix operation
          else {
            return sumMatrix(op1, op2);
          }
        }
      }
      else if (this.value === "-") {
        this.evaluate = function(evaluator) {
          var op1 = this.childs[0].evaluate(evaluator, true);
          var op2 = this.childs[1].evaluate(evaluator, true);

          // numeric operation
          if ((op1.type !== "matrix") || (op2.type !== "matrix")) {
            return op1 - op2;
          }
          // matrix operation
          else {
            return substactMatrix(op1, op2);
          }
        }
      }
      else if (this.value === "*") {
        this.evaluate = function(evaluator) {
          var op1 = this.childs[0].evaluate(evaluator, true);
          var op2 = this.childs[1].evaluate(evaluator, true);

          // numeric operation
          if ((op1.type !== "matrix") || (op2.type !== "matrix")) {
            return op1 * op2;
          }
          // matrix operation
          else {
            return multiplicationMatrix(op1, op2);
          }
        }
      }
      else if (this.value === "/") {
        this.evaluate = function(evaluator) {
          var op1 = this.childs[0].evaluate(evaluator, true);
          var op2 = this.childs[1].evaluate(evaluator, true);

          // numeric operation
          if ((op1.type !== "matrix") || (op2.type !== "matrix")) {
            return op1 / op2;
          }
          // matrix operation
          else {
            return divisionMatriz(op1, op2);
          }
        }
      }
      else if (this.value === "%") {
        this.evaluate = function(evaluator) {
          var op1 = this.childs[0].evaluate(evaluator);
          var op2 = this.childs[1].evaluate(evaluator);
          return op1 - mathFloor(op1/op2)*op2;
        }
      }
      else if (this.value === "^") {
        this.evaluate = function(evaluator) {
          var op1 = this.childs[0].evaluate(evaluator);
          var op2 = this.childs[1].evaluate(evaluator);
          if (op2 >= 0) {
            return calcExp(op1, op2);
          }
          else {
            return 1/calcExp(op1, -op2);
          }
        }
      }
    }

    // comparison operator
    else if (this.type === "compOperator") {
      if (this.value === "<") {
        this.evaluate = function(evaluator) {
          return (this.childs[0].evaluate(evaluator) < this.childs[1].evaluate(evaluator)) ? 1 : 0;
        }
      }
      else if (this.value === "<=") {
        this.evaluate = function(evaluator) {
          return (this.childs[0].evaluate(evaluator) <= this.childs[1].evaluate(evaluator)) ? 1 : 0;
        }
      }
      else if (this.value === ">") {
        this.evaluate = function(evaluator) {
          return (this.childs[0].evaluate(evaluator) > this.childs[1].evaluate(evaluator)) ? 1 : 0;
        }
      }
      else if (this.value === ">=") {
        this.evaluate = function(evaluator) {
          return (this.childs[0].evaluate(evaluator) >= this.childs[1].evaluate(evaluator)) ? 1 : 0;
        }
      }
      else if (this.value === "==") {
        this.evaluate = function(evaluator) {
          return (this.childs[0].evaluate(evaluator) === this.childs[1].evaluate(evaluator)) ? 1 : 0;
        }
      }
      else if (this.value === "!=") {
        this.evaluate = function(evaluator) {
          return (this.childs[0].evaluate(evaluator) !== this.childs[1].evaluate(evaluator)) ? 1 : 0;
        }
      }
    }

    // boolean operator
    else if (this.type === "boolOperator") {
      if (this.value === "&") {
        this.evaluate = function(evaluator) {
          var op1 = this.childs[0].evaluate(evaluator) ? 1 : 0;
          if (op1) {
            return (this.childs[1].evaluate(evaluator)) ? 1 : 0;
          }
          else {
            return 0;
          }
        }
      }

      else if (this.value === "|") {
        this.evaluate = function(evaluator) {
          var op1 = this.childs[0].evaluate(evaluator) ? 1 : 0;
          if (op1) {
            return 1;
          }
          else {
            return (this.childs[1].evaluate(evaluator)) ? 1 : 0;
          }
        }
      }

      else if (this.value === "!") {
        this.evaluate = function(evaluator) {
          var op1 = this.childs[0].evaluate(evaluator) ? 1 : 0;
          return (!op1) ? 1 : 0;
        }
      }
    }

    // conditional
    else if (this.type === "conditional") {
      this.evaluate = function(evaluator) {
        var op1 = this.childs[0].evaluate(evaluator);

        return (op1 > 0) ? this.childs[1].evaluate(evaluator) : this.childs[2].evaluate(evaluator);
      }
    }

    // sign
    else if (this.type === "sign") {
      if (this.value === "sign+") {
        this.evaluate = function(evaluator) {
          return this.childs[0].evaluate(evaluator);
        }
      }
      else {
        this.evaluate = function(evaluator) {
          return -(this.childs[0].evaluate(evaluator));
        }
      }
    }

    // parentheses
    else if (this.type === "parentheses") {
      this.evaluate = function(evaluator, getMatrix) {
        return this.childs[0].evaluate(evaluator, getMatrix);
      }
    }

    // expression of the type (x,y) or [x,y]
    else if ( (this.type === "(expr)") || (this.type === "[expr]") ) {
      this.evaluate = function(evaluator) {
        var l = this.childs.length;
        var result = [];
        var tmpRes;

        if ( (l === 1) && (this.childs[0].childs.length === 1) && (this.type === "(expr)") ) {
          result = this.childs[0].childs[0].evaluate(evaluator);
        }
        else {
          for (var i=0; i<l; i++) {
            tmpRes = [];
            for (var j=0, n=this.childs[i].childs.length; j<n; j++) {
              tmpRes.push( this.childs[i].childs[j].evaluate(evaluator));
            }
            result[i] = tmpRes;
          }
        }

        return result;
      }
    }

    // assignation
    else if (this.type === "asign") {
      var tmpPos;
      var tmpPos0;
      var tmpPos1;
      var assignation;

      var ide = this.childs[0];
      var expre = this.childs[1];
      var type = (ide.childs[0]) ? ide.childs[0].type : null
      var pos = (ide.childs[0]) ? ide.childs[0].childs : null;

      // vector assignation
      if ((ide.childs.length === 1) && (ide.childs[0].type === "square_bracket") && (pos.length === 1)) {
        this.evaluate = function(evaluator) {
          tmpPos = pos[0].evaluate(evaluator);
          tmpPos = (tmpPos < 0) ? 0 : mathFloor(tmpPos);

          assignation = expre.evaluate(evaluator);
          evaluator.vectors[ide.value][tmpPos] = assignation
          return assignation;
        }
      }
      // matrix assignation
      else if ((ide.childs.length === 1) && (ide.childs[0].type === "square_bracket") && (pos.length === 2)) {
        this.evaluate = function(evaluator) {
          tmpPos0 = pos[0].evaluate(evaluator);
          tmpPos1 = pos[1].evaluate(evaluator);
          tmpPos0 = (tmpPos0 < 0) ? 0 : mathFloor(tmpPos0);
          tmpPos1 = (tmpPos1 < 0) ? 0 : mathFloor(tmpPos1);

          // condition to handle wrong matrix access
          if (!evaluator.matrices[ide.value][tmpPos0]) {
            evaluator.matrices[ide.value][tmpPos0] = [];
          }

          assignation = expre.evaluate(evaluator);
          evaluator.matrices[ide.value][tmpPos0][tmpPos1] = assignation;
          return assignation;
        }
      }
      else {
        this.evaluate = function(evaluator) {
          assignation = expre.evaluate(evaluator);

          // the assignation isn't a variable
          if (!assignation.type) {
            // prevent to asign a value to an auxiliar variable
            if (typeof(evaluator.variables[ide.value]) !== "object") {
              evaluator.variables[ide.value] = assignation;
              return assignation;
            }
          }
          // the assignation is a matrix
          else {
            evaluator.matrices[ide.value] = assignation;
            return assignation;
          }

          return 0;
        }
      }
    }
  }

  /**
   *
   */
  function calcExp(x, y) {
    if (y == 0) {
      return 1;
    }
    if (y < 0) {
      return NaN;
    }
    if ((x >= 0) || (Math.floor(y) === y)) {
      return Math.pow(x, y);
    }
    if (x < 0) {
      var yinv = 1/y;
      var q = Math.floor(yinv);
      if (q === yinv) {
        if (q%2 === 1) {
          return -Math.pow(-x, y);
        }
      }
    }
    return NaN;
  }

  var rows;
  var cols;
  var result;
  var i, j, k, l;

  /**
   *
   */
  function createMatrix(rows, cols) {
    result = [];
    result.type = "matrix";
    result.rows = rows;
    result.cols = cols;

    var vectInit;
    for (j=0, k=cols; j<k; j++) {
      vectInit = [];
      for (i=0, l=rows; i<l; i++) {
        vectInit.push(0);
      }
      result[j] = vectInit;
    }

    return result;
  }

  /**
   *
   */
  function sumMatrix(op1, op2) {
    rows = op1.rows;
    cols = op1.cols;
    result = createMatrix(rows, cols);

    for (j=0; j<rows; j++){
      for (i=0; i<cols; i++) {
        result[i][j] = op1[i][j] + op2[i][j];
      }
    }

    return result;
  }

  /**
   *
   */
  function substactMatrix(op1, op2) {
    rows = op1.rows;
    cols = op1.cols;
    result = createMatrix(rows, cols);

    for (j=0; j<rows; j++){
      for (i=0; i<cols; i++) {
        result[i][j] = op1[i][j] - op2[i][j];
      }
    }

    return result;
  }

  /**
   *
   */
  function multiplicationMatrix(op1, op2) {
    rows = op1.rows;
    cols = op1.cols;
    result = createMatrix(rows, cols);
    var sum;

    for (j=0; j<rows; j++){
      for (i=0; i<cols; i++) {
        sum = 0;
        for (k=0; k<cols; k++) {
          sum += op1[k][j]*op2[i][k];
        }
        result[i][j] = sum;
      }
    }

    return result;
  }

  /**
   *
   */
  function minor(I, J, T) {
    var M = createMatrix(T.length-1, T.length-1);

    for (var i=0, l=M.length; i<l; i++) {
      for (var j=0; j<l; j++) {
        if (i<I) {
          if (j<J) {
            M[i][j] = T[i][j];
          }
          else {
            M[i][j] = T[i][j+1];
          }
        }
        else {
          if (i<J) {
            M[i][j] = T[i+1][j];
          }
          else {
            M[i][j] = T[i+1][j+1];
          }
        }
      }
    }

    return M;
  }
  /**
   *
   */
  function determinant(T) {
    if (T.cols > 1) {
      var D = 0;
      var s = 1;
      for (var j=0, l=T.cols; j<l; j++) {
        D += s*T[0][j]*determinant(minor(0, j, T));
        s = -s;
      }
      return D;
    } else {
      return T[0][0];
    }
   }

  /**
   *
   */
  function inverseMatriz(T) {
    var S = createMatrix(T.length, T.length);
    var det = determinant(T);

    if (det === 0) {
      return 0;
    }

    var s = 1/det;
    var t;

    if (T.length > 1) {
      for (var i=0, l=T.length; i<l; i++) {
        t = s;
        for (var j=0; j<l; j++) {
          S[j][i] = t*determinant(minor(i, j, T));
          t = - t;
        }
        s = -s;
      }
    }
    else {
      S[0][0] = s;
    }

    return S;
  }

  /**
   *
   */
  function divisionMatriz(op1, op2) {
    var inverse = inverseMatriz(op2);

    if (inverse === 0) {
      return createMatrix(op1.rows, op1.cols);
    }

    return multiplicationMatrix(op1, inverse);
  }

  /**
   *
   */
  descartesJS.Node.prototype.toString = function() {
    var str = "tipo: " + this.type + ", valor: " + this.value + "\n";

    this.sep = "   " + ((this.parent) ? (this.parent.sep) : "");
    for (var i=0, l=this.childs.length; i<l; i++) {
      str += this.sep +this.childs[i].toString();
    }

    return str;
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var inputInicial;
  var tokens ;
  var exit;
  var pos;
  var val;
  var str;
  var inc;
  var count;
  var lastTokenType;

  var whiteSpaceRegExp = /^\s+/;
  var identifierRegExp = /^[a-zA-Z_\u00C0-\u021B\u0391-\u03C9]+[a-zA-Z_0-9\u00C0-\u021B\u0391-\u03C9]*([.]*[0-9a-zA-Z_\u00C0-\u021B\u0391-\u03C9]+[0-9]*)*/;
  var numberRegExp = /^[0-9]+[.][0-9]+|^[.][0-9]+|^[0-9]+/;
  var compOperatorRegExp = /^==|^!=|^<=|^<|^>=|^>|^#/;
  var boolOperatorRegExp = /^\!|^\~|^\&\&|^\&|^\|\||^\|/;
  var asignRegExp = /^=|^:=/;
  var conditionalRegExp = /^[\?\:]/;
  var operatorRegExp = /^[\+\-\*\/\%\^\u2212\u00b7\u00D7\u00F7]/;
  var squareBracketRegExp = /^\[|^\]/;
  var parenthesesRegExp = /^\(|^\)/;
  var separatorRegExp = /^,/;
  var finalOfExpressionRegExp = /^;/;
  var pipeStringDelimiterRegExp = /\|/g;
  var pipeAsteriskLeftRegExp = /\|\*/g;
  var pipeAsteriskRightRegExp = /\*\|/g;

  /**
   * Descartes tokenizer
   * @constructor
   */
  descartesJS.Tokenizer = function() {  };

  descartesJS.Tokenizer.prototype.tokenize = function(input) {
    inputInicial = input;

    if (input) {
      var commentIndex = input.indexOf("//");
      if ((commentIndex >= 0) && (input[commentIndex-1] !== ":")) {
        input = input.substring(0, commentIndex);
      }

      // change the values in UTF of the form \u##
      input = input.replace(/\\u(\S+) /g, function(str, m1){
        if (parseInt(m1, 16) !== 39) {
          return String.fromCharCode(parseInt(m1, 16));
        }
        return str; 
      });

      // superindex numbers codified with &sup#;
      input = input.replace(/\&sup(.+);/g, "^ $1 ");

      // single quotation marks
      input = input.replace(/&squot;/g, "'");

      // replace the pipes used like string marks
      if (input.match(/\=\|\*/g)) {
        input = input.replace(pipeAsteriskLeftRegExp, "'").replace(pipeAsteriskRightRegExp, "'");
      }
      // replace the pipes used like string marks
      if (input.match(/\=\|/g)) {
        input = input.replace(pipeStringDelimiterRegExp, "'");
      }

      var inputTrimed = input.trim();
      if ((inputTrimed.charAt(0) == "|") && (inputTrimed.charAt(inputTrimed.length-1) == "|")) {
        input = inputTrimed.replace(pipeStringDelimiterRegExp, "'");
      }
    }

    tokens = [];
    exit = false;
    pos = 0;
    str = input;
    count = 0;
    lastTokenType = "";

    /**
     * Auxiliar function to add tokens and move the character position
     * @param {String} type the type of the token
     * @param {String} value the value of the token
     * @param {Number} size the length of the value of the token
     */
    function addToken(type, value, size) {
      tokens.push({ type: type, value: value });
      str = str.slice(size);
      pos += size;
      count++;
      lastTokenType = type;
    }

    while ((input) && (pos < input.length)) {
      exit = pos;

      // string
      if (str[0] == "'") {
        inc = 1;
        while (str[inc] != "'") {
          if (inc < str.length) {
            inc++;
          }
          else {
            console.info(">Error, unknown symbol: ["+str+"], in the string 《" + inputInicial + "》" );
            return;
          }
        }

        val = str.substring(1, inc);
        addToken("string", val, val.length+2);
        continue;
      }

      // white spaces
      val = str.match(whiteSpaceRegExp);
      if (val) {
        str = str.slice(val[0].length);
        pos += val[0].length;
        count++;
        continue;
      }

      // operator
      val = str.match(operatorRegExp);
      if (val) {
        val[0] = val[0].replace(/\u00F7/g, "/").replace(/\u2212/g, "-").replace(/\u00b7/g, "*").replace(/\u00D7/g, "*")
        addToken("operator", val[0], val[0].length);
        continue;
      }

      // identifier
      val = str.match(identifierRegExp);
      if (val) {
        // expression of the form 2pi change to 2*pi, so we need to know that the type of the last token is a number
        if (lastTokenType === "number") {
          // add a multiplication operator
          tokens.push({ type: "operator", value: "*" });
        }
        // add the identifier token
        addToken("identifier", val[0], val[0].length);
        continue;
      }

      // number
      val = str.match(numberRegExp);
      if (val) {
        addToken("number", val[0], val[0].length);
        continue;
      }

      // comparison
      val = str.match(compOperatorRegExp);
      if (val) {
        var tempVal = val[0];

        if (tempVal == "#") { tempVal = "!="; }
          addToken("compOperator", tempVal, val[0].length);
        continue;
      }

      // booleans
      val = str.match(boolOperatorRegExp);
      if (val) {
        var tempVal = val[0];
        if (tempVal == "||") { tempVal = "|"; }
        else if (tempVal == "&&") { tempVal = "&"; }
        else if (tempVal == "~") { tempVal = "!"; }

        addToken("boolOperator", tempVal, val[0].length);
        continue;
      }

      // equal (asign)
      val = str.match(asignRegExp);
      if ((val) && !(str.match( /^==/))) {
        addToken("asign", val[0], val[0].length);
        continue;
      }

      // conditional
      val = str.match(conditionalRegExp);
      if (val) {
        addToken("conditional", val[0], val[0].length);
        continue;
      }

      // square brackets
      val = str.match(squareBracketRegExp);
      if (val) {
        addToken("square_bracket", val[0], val[0].length);
        continue;
      }

      // parentheses
      val = str.match( parenthesesRegExp );
      if (val) {
        if ((val == "(") && (lastTokenType === "number")) {
          // add a multiplication operator
          tokens.push({ type: "operator", value: "*" });
        }

        addToken("parentheses", val[0], val[0].length);
        continue;
      }

      // separator
      val = str.match(separatorRegExp);
      if (val) {
        addToken("separator", val[0], val[0].length);
        continue;
      }

      // square
      if (str.charCodeAt(0) === 178) {
        // add a multiplication operator
        tokens.push({ type: "operator", value: "^" });

        // add the identifier token
        addToken("number", 2, 1);
        continue;
      }
      // cube
      if (str.charCodeAt(0) === 179) {
        // add a multiplication operator
        tokens.push({ type: "operator", value: "^" });

        // add the identifier token
        addToken("number", 3, 1);
        continue;
      }

      // final of expression
      val = str.match(finalOfExpressionRegExp);
      if (val) {
        addToken("final_of_expresion", val[0], val[0].length);
        continue;
      }

      if (exit == pos){
        descartesJS.DEBUG.setError(descartesJS.DEBUG.EXPRESSION, inputInicial);
        // console.info("Error, simbolo no conocido: ["+str+"], en la cadena 《" + inputInicial + "》" );
        // console.info("Error: en la cadena 《 " + inputInicial + " 》");
        return;
      }
    }

    return tokens;
  }

  var result;
  var exclude = /rnd|pi|e|Infinity|-Infinity|sqr|sqrt|raíz|exp|log|log10|abs|ent|sgn|ind|sin|sen|cos|tan|cot|sec|csc|sinh|senh|cosh|tanh|coth|sech|csch|asin|asen|acos|atan|min|max/;

  /**
   * Auxiliary funtion for the macros that take a list of tokens and get a string representation
   * @param {Array<Object>} tokens the tokens to be flat
   * @return {String} return a string representation of the tokens
   */
  descartesJS.Tokenizer.prototype.flatTokens = function(tokens, prefix) {
    tokens = tokens || [];
    prefix = prefix || "";

    result = "";

    for (var i=0, l=tokens.length; i<l; i++) {
      if (tokens[i].type == "string") {
        result = result + "&squot;" + tokens[i].value + "&squot;";
      }
      else if ((tokens[i].type == "identifier") && (!tokens[i].value.match(exclude))) {
        result = result + prefix + tokens[i].value;
      }
      else {
        result = result + tokens[i].value;
      }
    }

    return result;
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  descartesJS.reservedIds = new String("-_-rnd-pi-π-e-Infinity-isTouch-esTáctil-screenOrientation-screenWidth-screenHeight-sqr-sqrt-raíz-exp-log-log10-abs-ent-sgn-ind-sin-sen-cos-tan-cot-sec-csc-sinh-senh-cosh-tanh-coth-sech-csch-asin-asen-acos-atan-atan2-floor-ceil-round-min-max-_Trace_-_Print_-_Num_-_Stop_Audios_-esCorrecto-escorrecto-parent.set-parent.update-parent.exec-toFixed-_NumToStr_-_NumACadena_-charAt-_charAt_-_letraEn_-substring-_substring_-_subcadena_-strLength-_length_-_longitud_-indexOf-_indexOf_-índiceDe-lastIndexOf-replace-_replace_-_reemplazar_-toLowerCase-toUpperCase-_Load_-_GetValues_-_GetMatrix_-_MatrixToStr_-_StrToMatrix_-_GetVector_-_VectorToStr_-_StrToVector_-_ExecStr_-_ExecBlock_-_Save_-_Open_-_SaveState_-_OpenState_-_AnchoDeCadena_-_strWidth_-_Rojo_-_Red_-_Verde_-_Green_-_Azul_-_Blue_-DJS.typeof-");
  var lastTime = Date.now();
  var waitTime = 1500;

  /**
   * Descartes parser
   * @constructor
   */
  descartesJS.Parser = function(evaluator) {
    this.evaluator = evaluator;

    this.tokenizer = new descartesJS.Tokenizer();
    this.vectors = {};
    this.matrices = {};
    this.variables = {};
    this.functions = {};
    this.definitions = {};

    this.registerDefaultValues();
    if (this.registerExternalValues) {
      this.registerExternalValues();
    }
  }

  /**
   */
  descartesJS.Parser.prototype.setDefinition = function(name, value) {
    this.definitions[name] = value;
  }
  descartesJS.Parser.prototype.getDefinition = function(name) {
    return this.definitions[name];
  }

  /**
   * Set the value to a variable
   * @param {String} name the name of the variable to set
   * @param {Object} value the value of the variable to set
   */
  descartesJS.Parser.prototype.setVariable = function(name, value) {
    this.variables[name] = value;
  }

  /**
   * Get the value to a variable
   * @param {String} name the name of the variable to get the value
   */
  descartesJS.Parser.prototype.getVariable = function(name, firstTime) {
    if (firstTime) {
      this.variables[name] = (this.variables[name] !== undefined) ? this.variables[name] : undefined;
    }
    return this.variables[name];
  }

  /**
   * Set the value of a position in a vector
   * @param {String} name the name of the vector to set
   * @param {Number} pos the position in the vector to set
   * @param {Object} value the value of the vector to set
   */
  descartesJS.Parser.prototype.setVector = function(name, pos, value) {
    this.vectors[name][pos] = value;
  }

  /**
   * Get the value to a vector
   * @param {String} name the name of the vector to get the value
   */
  descartesJS.Parser.prototype.getVector = function(name) {
    if (!this.vectors.hasOwnProperty(name)) {
      this.vectors[name] = [0,0,0];
    }
    return this.vectors[name];
  }

  /**
   * Set the value of a position in a matrix
   * @param {String} name the name of the matrix to set
   * @param {Number} pos1 the row position in the matrix to set
   * @param {Number} pos2 the column position in the matrix to set
   * @param {Object} value the value of the matrix to set
   */
  descartesJS.Parser.prototype.setMatrix = function(name, pos1, pos2, value){
    this.matrices[name][pos1][pos2] = value;
  }

  /**
   * Get the value to a matrix
   * @param {String} name the name of the matrix to get the value
   */
  descartesJS.Parser.prototype.getMatrix = function(name){
    if (!this.matrices.hasOwnProperty(name)) {
      this.matrices[name] = [[0,0,0],[0,0,0],[0,0,0]];
    }
    return this.matrices[name];
  }

  /**
   * Set the value to a function
   * @param {String} name the name of the function to set
   * @param {Object} value the value of the function to set
   */
  descartesJS.Parser.prototype.setFunction = function(name, value){
    this.functions[name] = value;
  }

  /**
   * Get a function
   * @param {String} name the name of the function to get
   */
  descartesJS.Parser.prototype.getFunction = function(name){
    if (!this.functions.hasOwnProperty(name)) {
      this.functions[name] = function(){ return 0; };
    }
    return this.functions[name];
  }

  var parenthesesType = "parentheses";
  var squareBracketType = "square_bracket";
  var asignType = "asign";
  var compOperatorType = "compOperator";
  var identifierType = "identifier";
  var operatorType = "operator";
  var boolOperatorType = "boolOperator";
  var conditionalType = "conditional";
  var signType = "sign";
  var numberType = "number";
  var stringType = "string";
  var i;
  var l;
  var tokens;
  var lastNode;
  var node;
  var asignation;
  var count;
  var openParentesis;
  var openSquareBracket;
  var openConditional;
  var tokens_i;
  var tokens_i_value;
  var tokens_i_type;
  var root;

  /**
   * Function that parses a string
   * @param {String} input the input to parse
   * @param {Boolean} asignation identify if the input is treated like an asignation
   * @return {Node} return a parse tree from the parses input
   */
  descartesJS.Parser.prototype.parse = function(input, asignation) {
    tokens = this.tokenizer.tokenize(input);

    // tokens is undefined
    if (!tokens) {
      tokens = [];
    }
    lastNode = null;
    asignation = !asignation || false;
    count = 0;

    openParentesis = 0;
    openSquareBracket = 0;
    openConditional = 0;

    for (i=0, l=tokens.length; i<l; i++) {
      tokens_i = tokens[i];
      tokens_i_value = tokens_i.value;
      tokens_i_type = tokens_i.type;

      ////////////////////////////////////////////////////////////////////////////////
      // verify if the variables exist
      ////////////////////////////////////////////////////////////////////////////////
      if (tokens_i_type === identifierType) {
        // the identifier is a function
        if ( ((i+1)<l) && (tokens[i+1].type === parenthesesType) && (tokens[i+1].value === "(") ) {
          this.getFunction(tokens_i_value);
        }
        // the identifier is a vector or a matrix
        else if ( ((i+1)<l) && (tokens[i+1].type === squareBracketType) && (tokens[i+1].value === "[") ) {
          // vector
          if ( (tokens[i+3]) && (tokens[i+3].type === squareBracketType) && (tokens[i+3].value === "]") ) {
            this.getVector(tokens_i_value);
          }
          // matrix
          else {
            this.getMatrix(tokens_i_value);
          }
        }
        // the identifier is a variable
        else {
          var scrollable = tokens_i_value.match(/(\w*)\.mouse_x|(\w*)\.mouse_y|(\w*)\.mouse_pressed|(\w*)\.mouse_clicked|(\w*)\.clic_izquierdo/);
          if (scrollable) {
            this.variables[(scrollable[1] || scrollable[2] || scrollable[3] || scrollable[4] || scrollable[5]) + ".DESCARTESJS_no_fixed"] = 1;
          }

          this.getVariable(tokens_i_value, true);
        }
      }
      ////////////////////////////////////////////////////////////////////////////////

      ////////////////////////////////////////////////////////////////////////////////
      //
      // Asignation (one equal sign)
      //
      ////////////////////////////////////////////////////////////////////////////////
      if ( (tokens_i_type === asignType) && (asignation) && (tokens_i_value != ":=") ) {
        tokens_i_type = compOperatorType;
        tokens_i_value = "==";
      }
      if (tokens_i_type === asignType) {
        node = new descartesJS.Node(tokens_i_type, tokens_i_value);

        // the tree is not empty
        if (lastNode != null) {
          // the last element of the tree is an identifier
          if (lastNode.type === identifierType) {
            if (lastNode.parent){
              lastNode.parent.replaceLastChild(node);
            }

            node.addChild(lastNode);
            lastNode = node;
            asignation = true;
          }
          // the last element of the tree is a square bracket
          else if (lastNode.type === squareBracketType) {
            node.addChild(lastNode.parent);
            lastNode = node;
            asignation = true;
          }

          // otherwise
          else {
            node.type = compOperatorType;
            node.value = "==";
            asignation = true;

            // find an element in the tree having a higher precedence to the node to be added
            while ((lastNode.parent) && (getPrecedence(lastNode.parent.value) >= getPrecedence(node.value))){
              lastNode = lastNode.parent;
            }
            // if can find an ancestor in the tree having a higher precedence
            if (lastNode.parent){
              lastNode.parent.replaceLastChild(node);
              node.addChild(lastNode);
              lastNode = node;
            }

            // reached the root
            else {
              node.addChild(lastNode);
              lastNode = node;
            }
          }
        }

        // do not have last element
        else {
          console.info("Error1: en la expresion 《 " + input + " 》, en el token {valor: " + tokens_i_value + ", tipo: " + tokens_i_type + "}");
          break;
        }

        // continue with the next token
        continue;
      }

      ////////////////////////////////////////////////////////////////////////////////
      //
      // Parentheses, function, vectors and matrices
      //
      ////////////////////////////////////////////////////////////////////////////////
      // open parentheses and open square brackets
      if ( (tokens_i_type === parenthesesType) && (tokens_i_value === "(") ||
        (tokens_i_type === squareBracketType) && (tokens_i_value === "[") ) {
        node = new descartesJS.Node(tokens_i_type, tokens_i_value);

        if (tokens_i_value === "(") {
          openParentesis++;
        }

        if (tokens_i_value === "[") {
          openSquareBracket++;
        }

        // the first element of the tree
        if (lastNode === null) {
          if (tokens_i_value === "(") {
            (new descartesJS.Node("(expr)", "(expr)")).addChild(node);
          }

          if (tokens_i_value === "[") {
            (new descartesJS.Node("[expr]", "[expr]")).addChild(node);
          }

          lastNode = node;
        }
        // the tree has some element
        else {
          // the last element of the tree is an operator
          if ( (lastNode.type === operatorType) || (lastNode.type === boolOperatorType) || (lastNode.type === compOperatorType) || (lastNode.type === conditionalType) || (lastNode.type === asignType) ) {
            lastNode.addChild(node);
            lastNode = node;
          }

          // the last element is a sign
          else if (lastNode.type === signType) {
            lastNode.addChild(node);
            lastNode = node;
          }

          // the last element in the tree is an open parentheses
          else if ((lastNode.type === parenthesesType) && (lastNode.value === "(")) {
            lastNode.addChild(node);
            lastNode = node;
          }

          // the last element in the tree is an open square bracket
          else if ((lastNode.type === squareBracketType) && (lastNode.value === "[")) {
            lastNode.addChild(node);
            lastNode = node;
          }

          // the last element in the tree is a close parentheses
          else if ((lastNode.type === parenthesesType) && (lastNode.value === "()")) {
            lastNode.parent.addChild(node);
            lastNode = node;
          }

          // the last element in the tree is a close square bracket
          else if ((lastNode.type === squareBracketType) && (lastNode.value === "[]")) {
            lastNode.parent.addChild(node);
            lastNode = node;
          }

          // the last element in the tree is an identifier
          else if (lastNode.type === identifierType) {
            lastNode.addChild(node);
            lastNode = node;
          }

          // otherwise
          else {
            console.info("Error2: en la expresion 《 " + input + " 》, en el token ["+ i +"] {valor: " + tokens_i_value + ", tipo: " + tokens_i_type + "}");
            break;
          }
        }

        // continue with the next token
        continue;
      }

      // close parentheses
      else if ((tokens_i_type === parenthesesType) && (tokens_i_value === ")")) {

        openParentesis--;

        // the first element of the tree
        if (lastNode === null) {
          console.info("Error3: en la expresion 《 " + input + " 》, en el token (valor:" + tokens_i_value + ", tipo:" + tokens_i_type);
        }

        // the tree has some element
        else {
          // find the correspondign open parentheses
          while (lastNode && lastNode.parent && ((lastNode.value != "(")  || ((lastNode.value == "(") && (lastNode.type != parenthesesType)))) {
            lastNode = lastNode.parent;
          }

          // if find the parentheses match
          if ((lastNode) && (lastNode.value === "(")) {
            lastNode.value = "()";
          }

          // if not find the parentheses match
          else {
            // console.info("Error4: en la expresion 《 " + input + " 》, en el token {valor: " + tokens_i_value + ", tipo: " + tokens_i_type + "}");
            break;
          }
        }

        // continue with the next token
        continue;
      }

      // close square brackets
      else if ((tokens_i_type === squareBracketType) && (tokens_i_value === "]")) {

        openSquareBracket--;

        // the first element of the tree
        if (lastNode === null) {
          console.info("Error5: en la expresion 《 " + input + " 》, en el token (valor:" + tokens_i_value + ", tipo:" + tokens_i_type);
        }

        // the tree has some element
        else {
          // find the correspondign square brackets
          while (lastNode && lastNode.parent && ((lastNode.value != "[")  || ((lastNode.value == "[") && (lastNode.type != squareBracketType)))) {
            lastNode = lastNode.parent;
          }

          // if find the square brackets
          if ((lastNode) && (lastNode.value === "[")) {
            lastNode.value = "[]";
          }

          // if not find the square brackets
          else {
            console.info("Error6: en la expresion 《 " + input + " 》, en el token {valor: " + tokens_i_value + ", tipo: " + tokens_i_type + "}");
            break;
          }
        }

        // continue with the next token
        continue;
      }

      ////////////////////////////////////////////////////////////////////////////////
      //
      // Numbers, strings and identifiers
      //
      ////////////////////////////////////////////////////////////////////////////////
      if ((tokens_i_type === numberType) || (tokens_i_type === stringType) || (tokens_i_type === identifierType)) {
        if (tokens_i_type === identifierType) {
          node = new descartesJS.Node(tokens_i_type, tokens_i_value);
        }
        else {
          node = new descartesJS.Node(tokens_i_type, tokens_i_value);
        }

        // the first element of the tree
        if (lastNode === null) {
          lastNode = node;
        }

        // the tree has some element
        else {
          // the last element of the tree is an operator, an open parentheses, a sign or an asignation
          if ( (lastNode.type === operatorType) || (lastNode.type === compOperatorType) || (lastNode.type === boolOperatorType) || ((lastNode.type === parenthesesType) && (lastNode.value === "(")) || ((lastNode.type === squareBracketType) && (lastNode.value === "[")) || (lastNode.type === signType)  || (lastNode.type === conditionalType) || (lastNode.type === asignType)) {
            lastNode.addChild(node);
            lastNode = node;
          }

          // otherwise
          else {
            descartesJS.DEBUG.setError(descartesJS.DEBUG.EXPRESSION, input);
            // console.info("Error7: en la expresion 《 " + input + " 》, en el token {valor: " + tokens_i_value + ", tipo: " + tokens_i_type + "}");
            break;
          }
        }

        // continue with the next token
        continue;
      }

      ////////////////////////////////////////////////////////////////////////////////
      //
      // Operators
      //
      ////////////////////////////////////////////////////////////////////////////////
      if ( (tokens_i_type === operatorType) || (tokens_i_type === compOperatorType) || (tokens_i_type === boolOperatorType) ) {
        node = new descartesJS.Node(tokens_i_type, tokens_i_value);

        // the first element of the tree
        if (lastNode === null) {
          // an operator can start an expression if is a sign expression
          if ((tokens_i_value === "-") || (tokens_i_value === "+")){
            node.type = signType;
            node.value = signType + tokens_i_value;
            lastNode = node;
          }

          // an operator can start an expression if is a boolean negation
          else if (tokens_i_value === "!") {
            lastNode = node;
          }

          // otherwise
          else {
            console.info("Error8: en la expresion 《 " + input + " 》, en el token {valor: " + tokens_i_value + ", tipo: " + tokens_i_type + "}");  //throw("Error: no se puede iniciar una expresion con un operador 《 " + input + " 》")
            break;
          }
        }

        // the tree has some element
        else {
          // the last element of the tree is an operator or an open parentheses and the operator is + or -
          if ( (lastNode.type === operatorType) || (lastNode.type === compOperatorType) || (lastNode.type === boolOperatorType) || (lastNode.type === asignType) || (lastNode.type === conditionalType) || (((lastNode.type === squareBracketType) && (lastNode.value === "[")) && ((tokens_i_value === "-") || (tokens_i_value === "+") || (tokens_i_value === "!"))) || (((lastNode.type === parenthesesType) && (lastNode.value === "(")) && ((tokens_i_value === "-") || (tokens_i_value === "+") || (tokens_i_value === "!"))) ) {
            // sign of an expression
            if ((tokens_i_value === "-") || (tokens_i_value === "+")){
              node.type = signType;
              node.value = signType + tokens_i_value;
            }
            lastNode.addChild(node);
            lastNode = node;
          }

          // the last element of the tree is a number, parenthetical expression, a string or an identifier
          else if ( (lastNode.type === numberType) || ((lastNode.type === parenthesesType) && (lastNode.value === "()")) || ((lastNode.type === squareBracketType) && (lastNode.value === "[]")) || (lastNode.type === stringType) || (lastNode.type === identifierType) || (lastNode.type === conditionalType) ||(lastNode.type === asignType) ) {

            // find an element in the tree having a higher precedence to the node to be added
            while ((lastNode.parent) && (getPrecedence(lastNode.parent.value) >= getPrecedence(node.value))){
              lastNode = lastNode.parent;
            }

            // if can find an ancestor in the tree having a higher precedence
            if (lastNode.parent){
              lastNode.parent.replaceLastChild(node);
              node.addChild(lastNode);
              lastNode = node;
            }

            // reached the root
            else {
              node.addChild(lastNode);
              lastNode = node;
            }
          }

          // otherwise
          else {
            console.info("Error9: en la expresion 《 " + input + " 》, en el token {valor: " + tokens_i_value + ", tipo: " + tokens_i_type + "}");
            break;
          }
        }

        // continue with the next token
        continue;
      }

      ////////////////////////////////////////////////////////////////////////////////
      //
      // Conditional
      //
      ////////////////////////////////////////////////////////////////////////////////
      if (tokens_i_type === conditionalType) {
        node = new descartesJS.Node(tokens_i_type, tokens_i_value);

        // the tree has some element
        if (lastNode != null) {
          // the operator is ?
          if (node.value === "?") {
            openConditional++;

            // find an element in the tree having a higher precedence to the node to be added
            while ((lastNode.parent) && (getPrecedence(lastNode.parent.value) > getPrecedence(node.value))){
              lastNode = lastNode.parent;
            }
            // if can find an ancestor in the tree having a higher precedence
            if (lastNode.parent){
              lastNode.parent.replaceLastChild(node);
              node.addChild(lastNode);
              lastNode = node;
            }

            // reached the root
            else {
              node.addChild(lastNode);
              lastNode = node;
            }
          } else {
            openConditional--;

            // find the correspondign signo ? correspondiente
            while (lastNode && lastNode.parent && ((lastNode.value != "?")  || ((lastNode.value == "?") && (lastNode.type != conditionalType)))) {
              lastNode = lastNode.parent;
            }
            // if can find the ?
            if ((lastNode) && (lastNode.value === "?")) {
              lastNode.value = "?:";
            }

            // if can not find the ?
            else {
              console.info("Error10: en la expresion 《 " + input + " 》, en el token {valor: " + tokens_i_value + ", tipo: " + tokens_i_type + "}");
              break;
            }
          }
        }

        // last element do not exist
        else {
          console.info("Error11: en la expresion 《 " + input + " 》, en el token {valor: " + tokens_i_value + ", tipo: " + tokens_i_type + "}");
          break;
        }

        // continue with the next token
        continue;
      }

      ////////////////////////////////////////////////////////////////////////////////
      //
      // Separator (comma ,)
      //
      ////////////////////////////////////////////////////////////////////////////////
      if (tokens_i_type === "separator") {
        // the tree has some element
        if (lastNode != null) {
          // find in the tree an open parentheses
          while ( (lastNode.parent) && (lastNode.value != "(") && (lastNode.value != "[") ) {
            lastNode = lastNode.parent;
          }
        }

        else {
          console.info("Error12: en la expresion 《 " + input + " 》, en el token {valor: " + tokens_i_value + ", tipo: " + tokens_i_type + "}");
          break;
        }

        // continue with the next token
        continue;
      }

      console.info("Error13: en la expresion 《 " + input + " 》, en el token {valor: " + tokens_i_value + ", tipo: " + tokens_i_type + "}");
      break;
    }

    // missing or too many parentheses or square brackets
    if (openParentesis > 0) {
      descartesJS.DEBUG.setError(descartesJS.DEBUG.PARENTHESIS_CLOSING, input);
    }
    if (openParentesis < 0) {
      descartesJS.DEBUG.setError(descartesJS.DEBUG.PARENTHESIS_OPENING, input);
    }

    if (openSquareBracket > 0) {
      descartesJS.DEBUG.setError(descartesJS.DEBUG.BRACKET_CLOSING, input);
    }
    if (openSquareBracket < 0) {
      descartesJS.DEBUG.setError(descartesJS.DEBUG.BRACKET_OPENING, input);
    }
    
    // miss the second term of the conditional
    if (openConditional !=0) {
      descartesJS.DEBUG.setError(descartesJS.DEBUG.INCOMPLETE_IF, input);
    }

    root = (lastNode) ? lastNode.getRoot() : null;
    if (root) {
      root.setAllEvalFun();
    }

    return root;
  }

  /**
   * Get the precedence of an operator
   * @param {String} op the operator to get the precedence
   * @return {Number} return a number that represent the precedence
   */
  function getPrecedence(op) {
    switch(op){
      case "=":  return 1;
      case ":=": return 1;
      case "(":  return 2;
      case "[":  return 2;
      case "?":  return 2;
      case ":":  return 3;
      case "?:": return 3;
      case "|":  return 6; //check
      case "&":  return 7; //check
      case "<":  return 5;
      case "<=": return 5;
      case ">":  return 5;
      case ">=": return 5;
      case "==": return 5;
      case "!=": return 5;
      case "+":  return 6;
      case "-":  return 6;
      case "/":  return 7;
      case "*":  return 7;
      case "sign-": return 7;
      case "sign+": return 7;
      case "!":  return 8;
      case "%":  return 8;
      case "^":  return 9;
      default:   return 9;
    }
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /**
   * Register the default variables and functions of Descartes
   */
  descartesJS.Parser.prototype.registerDefaultValues = function() {
    var self = this;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // register the default variables
    self.variables["rnd"] = Math.random;
    self.variables["pi"] = self.variables["\u03C0"] = descartesJS.returnValue(Math.PI);
    self.variables["e"] = descartesJS.returnValue(Math.E);
    self.variables["Infinity"] = Infinity;
    self.variables["-Infinity"] = -Infinity;
    self.variables["isTouch"] = self.variables["esT\u00E1ctil"] = (descartesJS.hasTouchSupport) ? 1 : 0;

    // screen variables
    Object.defineProperties(self.variables, {
      "screenOrientation" : { 
        get : function() { 
          if ( window.matchMedia("(orientation: landscape)").matches ) {
            return "landscape";
          }
          return "portrait";
        }
      },
      "screenWidth" : { get : function() { return window.innerWidth; } },
      "screenHeight" : { get : function() { return window.innerHeight; } },
    });

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // register the default funtions
    self.functions["sqr"]   = function(x) { return (x*x) };
    self.functions["sqrt"]  = self.functions["ra\u00EDz"] = Math.sqrt;
    self.functions["exp"]   = Math.exp;
    self.functions["log"]   = Math.log;
    self.functions["log10"] = function(x) { return Math.log(x)/Math.log(10) };
    self.functions["abs"]   = Math.abs;
    self.functions["ent"]   = Math.floor;
    self.functions["sgn"]   = function(x) { return (x>0) ? 1 : ((x<0) ? -1 : 0) };
    self.functions["ind"]   = function(x) { return (x) ? 1 : 0 };
    self.functions["sin"]   = self.functions["sen"] = Math.sin;
    self.functions["cos"]   = Math.cos;
    self.functions["tan"]   = Math.tan;
    self.functions["cot"]   = function(x) { return 1/Math.tan(x); };
    self.functions["sec"]   = function(x) { return 1/Math.cos(x); };
    self.functions["csc"]   = function(x) { return 1/Math.sin(x); };
    self.functions["sinh"]  = self.functions["senh"] = function(x) { return (Math.exp(x)-Math.exp(-x))/2 };
    self.functions["cosh"]  = function(x) { return (Math.exp(x)+Math.exp(-x))/2; };
    self.functions["tanh"]  = function(x) { return (Math.exp(x)-Math.exp(-x))/(Math.exp(x)+Math.exp(-x)); };
    self.functions["coth"]  = function(x) { return 1/self.functions.tanh(x); };
    self.functions["sech"]  = function(x) { return 1/self.functions.cosh(x); };
    self.functions["csch"]  = function(x) { return 1/self.functions.sinh(x); };
    self.functions["asin"]  = self.functions["asen"] = Math.asin;
    self.functions["acos"]  = Math.acos;
    self.functions["atan"]  = Math.atan;
    self.functions["atan2"] = Math.atan2;
    self.functions["floor"] = Math.floor;
    self.functions["ceil"] = Math.ceil; 
    self.functions["round"] = Math.round;
    self.functions["min"]   = Math.min;
    self.functions["max"]   = Math.max;
    self.functions["_Trace_"] = self.functions["_Print_"] = function() { console.info.apply(console, arguments); return 0; };
    self.functions["_Num_"] = function(x) {
      if (typeof(x) == "number") {
        return "NaN";
      }
      else {
        x = x.replace(",", ".");
        return (parseFloat(x) == x) ? parseFloat(x) : "NaN";
      }
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    self.functions["_Stop_Audios_"] = function() { self.evaluator.parent.stopAudios(); };
    self.functions["esCorrecto"] = function(x, y, regExp) { return descartesJS.esCorrecto(x, y, self.evaluator, regExp); };
    self.functions["escorrecto"] = function(x, y, regExp) { return descartesJS.escorrecto(x, y, self.evaluator, regExp); };

    // if the lesson is inside a iframe then register the comunication functions with the parent
    if (window.parent !== window) {
      // function to set a variable value to the parent
      self.functions["parent.set"] = function(varName, value) {
        window.parent.postMessage({ type: "set", name: varName, value: value }, '*');
        return 0;
      }

      // function to update the parent
      self.functions["parent.update"] = function() {
        window.parent.postMessage({ type: "update" }, '*');
        return 0;
      }

      // function to execute a function in the parent
      self.functions["parent.exec"] = function(functionName, functionParameters) {
        window.parent.postMessage({ type: "exec", name: functionName, value: functionParameters }, '*');
        return 0;
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /**
     *
     */
     self.functions["toFixed"] = self.functions["_NumToStr_"] = self.functions["_NumACadena_"] = function(num, dec) {
      num = isNaN(parseFloat(num)) ? 0 : parseFloat(num);
      dec = dec || 0;
      return num.toFixed(parseInt(dec));
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // new string functions
    /**
     *
     */
    self.functions["charAt"] = self.functions["_charAt_"] = self.functions["_letraEn_"] = function(str, n) {
      str = (str || "").toString();
      n = (isNaN(parseInt(n))) ? 0 : parseInt(n);
      return str.charAt(n);
    };
    /**
     *
     */
    self.functions["substring"] = self.functions["_substring_"] = self.functions["_subcadena_"] = function(str, i, j) {
      str = (str || "").toString();
      i = (isNaN(parseInt(i))) ? 0 : parseInt(i);
      j = (isNaN(parseInt(j))) ? 0 : parseInt(j);

      if ( (i >= 0) && (j >= 0) ) {
        return str.substring(i, j);
      }
      else {
        if ( (i < 0) && (j >= 0) ) {
          return str.substring(j);
        }
        else if ( (j < 0) && (i >= 0)) {
          return str.substring(i);
        }
        else {
          return "";
        }
      }
    };
    /**
     *
     */
    self.functions["strLength"] = self.functions["_length_"] = self.functions["_longitud_"] = function(str) {
      return ((str || "").toString()).length;
    };
    /**
     *
     */
    self.functions["indexOf"] = self.functions["_indexOf_"] = self.functions["_\u00EDndiceDe_"] = function(str, word) {
      return ((str || "").toString()).indexOf( (word || "").toString() );
    };
    /**
     *
     */
    self.functions["lastIndexOf"] = function(str, word) {
      return ((str || "").toString()).lastIndexOf( (word || "").toString() );
    };
    /**
     *
     */
    self.functions["replace"] = self.functions["_replace_"] = self.functions["_reemplazar_"] = function(str, strTo, strWith) {
      str = (str || "").toString();
      strTo = (strTo || "").toString();
      strWith = (strWith || "").toString();

      var index = str.indexOf(strTo);
      while (index >= 0) {
        str = str.substring(0, index) + strWith + str.substring(index+strTo.length);
        index = str.indexOf(strTo);
      }
      
      return str;
    };
    /**
     *
     */
    self.functions["toLowerCase"] = function(str) {
      return ((str || "").toString()).toLowerCase();
    };
    /**
     *
     */
    self.functions["toUpperCase"] = function(str) {
      return ((str || "").toString()).toUpperCase();
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // read external values
    /**
     *
     */
    self.functions["_Load_"] = function(file) {
      var response = "";
      if (file) {
        var fileElement = document.getElementById(file);
        response = ((fileElement) && (fileElement.type == "descartes/archivo")) ? fileElement.text : descartesJS.openExternalFile(file);
      }
      return response || "";
    }
    /**
     *
     */
    self.functions["_GetValues_"] = function(file, name) {
      return self.functions._ExecBlock_(self.functions._Load_(file).replace(/&brvbar;/g, String.fromCharCode("166")), name);
    };
    /**
     *
     */
    self.functions["_GetMatrix_"] = function(file, name) {
      return self.functions._StrToMatrix_(self.functions._Load_(file).replace(/&brvbar;/g, String.fromCharCode("166")), name);
    };
    /**
     *
     */
    self.functions["_MatrixToStr_"] = function(Mstr) {
      var M = self.matrices[Mstr];
      if (M) {
        var strM = "<" + Mstr + ">\\n";

        var l = self.getVariable(Mstr + ".columnas_usadas") || M.cols || 0;
        var k = self.getVariable(Mstr + ".filas_usadas")    || M.rows || 0;
        var _val;

        for (var i=0; i<l; i++) {
          for (var j=0; j<k; j++) {
            _val = M[i][j];

            if (_val !== undefined) {
              if (typeof(_val) == "string") {
                _val = "'" + _val + "'";
              }
              else if (typeof(_val) == "number") {
                _val = descartesJS.removeNeedlessDecimals(_val.toFixed(6));
              }

              strM += _val + ((j<k-1)? (" \u00A6 ") : "");
            }
          }
          // remove the last pipe if any
          strM = strM.replace(/(\u00A6 )$/g, "") + "\\n";
        }
        
        return strM + "</" + Mstr + ">";
      }
      else {
        return "";
      }
    }
    /**
     *
     */
    self.functions["_StrToMatrix_"] = function(response, name) {
      var values = [];
      var storeValues = false;
      var findMatrix = false;
      values.type = "matrix";

      var tmpValue;

      if (response) {
        response = response.replace(/\r|\\r/g, "").split(/\n|\\n/);

        for (var i=0, l=response.length; i<l; i++) {
          // initial position of the values
          if (response[i].match("<" + name + ">")) {
            findMatrix = true;

            tmpValue = response[i].trim().split("<" + name + ">");

            if ((tmpValue.length == 2) && (tmpValue[1] != "")) {
              values.push(tmpValue[1].split(String.fromCharCode("166")).map(myMapFun));
            }

            storeValues = true;
            continue;
          }

          // final position of the values
          if (response[i].match("</" + name + ">")) {
            tmpValue = response[i].trim().split("</" + name + ">");

            if ((tmpValue.length == 2) && (tmpValue[0] != "")) {
              values.push(tmpValue[0].split(String.fromCharCode("166")).map(myMapFun));
            }

            storeValues = false;
            i = response.length;
          }

          // add elementes in between
          if (storeValues) {
            values.push(response[i].split(String.fromCharCode("166")).map(myMapFun));
          }
        }

        self.matrices[name] = values;
        self.matrices[name].rows = (values && values[0] && values[0].length) ? values[0].length : 0;
        self.matrices[name].cols = (values && values.length) ? values.length : 0;
        self.setVariable(name + ".filas", self.matrices[name].rows);
        self.setVariable(name + ".columnas", self.matrices[name].cols);
      }

      return (findMatrix) ? "OK" : "ERROR";
    }
    /**
     *
     */
    self.functions["_GetVector_"] = function(file, name) {
      return self.functions._StrToVector_(self.functions._Load_(file), name);
    }
    /**
     *
     */
    self.functions["_VectorToStr_"] = function(Vstr) {
      var V = self.vectors[Vstr];

      if (V) {
        var strV = "<" + Vstr + ">\\n";

        var l = self.getVariable(Vstr + ".long_usada") || V._size_ || 0;
        var _val;

        for (var i=0; i<l; i++) {
          _val = V[i];

          if (_val !== undefined) {
            if (typeof(_val) == "number") {
              _val = parseFloat(_val);
            }

            strV += _val + "\\n";
          }
          else {
            strV += 0 + "\\n";
          }
        }

        return strV + "</" + Vstr + ">";
      }
      else {
        return "";
      }
    }
    /**
     *
     */
    self.functions["_StrToVector_"] = function(response, name) {
      var values = [];
      var storeValues = false;
      var findVector = false;
      values.type = "vector";

      if (response) {
        response = response.replace(/\r|\\r/g, "").split(/\n|\\n/);

        for (var i=0, l=response.length; i<l; i++) {
          // initial position of the values
          if (response[i].match("<" + name + ">")) {
            findVector = true;
            storeValues = true;
            continue;
          }

          // final position of the values
          if (response[i].match("</" + name + ">")) {
            storeValues = false;
            i = response.length;
          }

          // add elementes in between
          if (storeValues) {
            values.push( myMapFun(response[i]) );
          }
        }

        values._size_ = values.length;
        self.vectors[name] = values;
        self.setVariable(name + ".long", values.length);
        self.setVariable(name + ".long_usada", values.length);
      }

      return (findVector) ? "OK" : "ERROR";
    }
    /**
     *
     */
    self.functions["_ExecStr_"] = function(response) {
      return self.functions._ExecBlock_(response, "");
    }
    /**
     *
     */
    self.functions["_ExecBlock_"] = function(response, name) {
      var values = [];
      var storeValues = (name == "");
      var tmpValue;

      if (response) {
        response = response.replace(/\r|\\r/g, "").split(/\n|\\n/);

        for (var i=0, l=response.length; i<l; i++) {

          // initial position of the values
          if (response[i].match("<" + name + ">")) {
            tmpValue = response[i].trim().split("<" + name + ">");

            if ((tmpValue.length == 2) && (tmpValue[1] != "")) {
              values = values.concat(tmpValue[1].split(String.fromCharCode("166")));
            }

            storeValues = true;
            continue;
          }

          // final position of the values
          if (response[i].match("</" + name + ">")) {
            tmpValue = response[i].trim().split("</" + name + ">");

            if ((tmpValue.length == 2) && (tmpValue[0] != "")) {
              values = values.concat(tmpValue[0].split(String.fromCharCode("166")))
            }

            storeValues = false;
            continue;
          }

          // add elementes in between
          if (storeValues) {
            values = values.concat(response[i].split(String.fromCharCode("166")));
          }
        }

        for(var i=0,l=values.length; i<l; i++) {
          tmpValue = values[i].split("=");
          tmpValue[0] = tmpValue[0].trim();

          if ((tmpValue.length == 2) && (tmpValue[0] != "")) {
            // is a string
            if (isNaN(parseFloat(tmpValue[1]))) {
              // .replace(/^\s|\s$/g, "") remove the initial white space
              self.setVariable(tmpValue[0], tmpValue[1].replace(/^\s|\s$/g, "").replace(/^'|'$/g, ""));
            }
            // is a number
            else {
              self.setVariable(tmpValue[0], parseFloat(tmpValue[1]));
            }
          }
        }
      }

      return 0;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    var anchor = document.createElement("a");
    anchor.setAttribute("target", "_blank");
    var blob;
    var blobContent = null;
    descartesJS.newBlobContent = null;
    /**
     *
     */
    self.functions["_Save_"] = function(filename, data) {
      self.evaluator.parent.removeButtonClick();
      if ((Date.now() - lastTime) > waitTime) {
        lastTime = Date.now();

        document.body.appendChild(anchor);
        blobContent = data.replace(/\\r/g, "").replace(/\\n/g, "\r\n").replace(/\\q/g, "'").replace(/\\_/g, "\\");

        blob = new Blob(["\ufeff", blobContent], {type:"text/plain;charset=utf-8"});
        anchor.setAttribute("href", window.URL.createObjectURL(blob));
        anchor.setAttribute("download", filename);
        // anchor.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(blobContent))

        if (blobContent != descartesJS.newBlobContent) {
          anchor.click();
          descartesJS.newBlobContent = blobContent;
        }

        document.body.removeChild(anchor);
      }
      return 0;
    };
    // window.addEventListener("visibilitychange", function(evt) { descartesJS.newBlobContent = null; });
    // window.addEventListener("blur", function(evt) { descartesJS.newBlobContent = null; });

    var files;
    var reader;

    var input = document.createElement("input");
    input.setAttribute("type", "file");

    input.addEventListener("change", function(evt) {
      files = evt.target.files;

      reader = new FileReader();
      /**
       * read the content of the file
       */
      reader.onload = function(evt) {
        descartesJS.addExternalFileContent(files[0].name, evt.target.result);

        self.setVariable("DJS.fileName", files[0].name);
        self.setVariable("DJS.fileContent", evt.target.result);

        if (self.getFunction(self._callback)) {
          self.getFunction(self._callback).apply(self.evaluator, []);
          self.evaluator.parent.update();
        }
        // clean the input
        input.value = "";
      }

      if (files.length > 0) {
        reader.readAsText(files[0]);
      }
    });

    /**
     *
     */
    self.functions["_Open_"] = function(callback) {
      self.evaluator.parent.removeButtonClick();
      if ((Date.now() - lastTime) > waitTime) {
        self._callback = callback;
        input.click();
        lastTime = Date.now();
      }
      return 0;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /**
     *
     */
    self.functions["_AnchoDeCadena_"] = self.functions["_strWidth_"] = function(str, font, style, size) {
      return descartesJS.getTextWidth(str, descartesJS.convertFont(font + "," + style + "," + size))
    }

    self.functions["_Rojo_"]  = self.functions["_Red_"]   = function(c) { return (new descartesJS.Color(c).r)/255; }
    self.functions["_Verde_"] = self.functions["_Green_"] = function(c) { return (new descartesJS.Color(c).g)/255; }
    self.functions["_Azul_"]  = self.functions["_Blue_"]  = function(c) { return (new descartesJS.Color(c).b)/255; }

    self.functions["DJS.typeof"] = function(o) {
      if (o.rows) { return "matrix"; }
      if (o._size_) { return "vector"; }
      return typeof(o);
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  }

  /**
   *
   */
  function myMapFun(x) {
    if (isNaN(parseFloat(x))) {
      return x.replace(/^\s|\s$/g, "").replace(/^'|'$/g, "");
    }
    else {
      return (parseFloat(x) == x) ? parseFloat(x) : x.replace(/^\s|\s$/g, "").replace(/^'|'$/g, "");
    }
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// console.log(((new descartesJS.Parser).parse("(t,func(t))")).toString());
// console.log(((new descartesJS.Parser).parse("((Aleat=0)&(Opmult=2)|(Aleat=1)&(Opmult=3))\nVerError=(Opm_ok=0)\nPaso=(Opm_ok=1)?Paso+1:Paso")).toString());
// console.log(((new descartesJS.Parser).parse("3(x+2)")).toString());
// console.log(((new descartesJS.Parser).parse("", true)).toString());
// console.log(((new descartesJS.Parser).parse("3−4·5×6÷7", true)).toString());
// console.log(((new descartesJS.Parser).parse("literal3=b=1?nombre1+&squot;(&squot;:(b=2?nombre2+&squot;(&squot;:nombre3+&squot;(&squot;)", true)).toString());
// console.log(((new descartesJS.Parser).parse("bla:=1+1", true)).toString());
// console.log(((new descartesJS.Parser).parse("bla(n0,n1)&ble(n0,n2)", true)).toString());
// console.log(((new descartesJS.Parser).parse("(a:=10)+(b:=10)", true)).toString());

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathFloor = Math.floor;

  /**
   * Descartes evaluador
   * @parent {DescartesApp} parent the parent asociated with the evaluator
   * @constructor
   */
  descartesJS.Evaluator = function (parent) {
    this.parent = parent;
    this.parser = new descartesJS.Parser(this);
    this.variables = this.parser.variables;
    this.functions = this.parser.functions;
    this.vectors   = this.parser.vectors;
    this.matrices  = this.parser.matrices;

    this.definitions = this.parser.definitions;
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  /**
   */
  descartesJS.Evaluator.prototype.setDefinition = function(name, value) {
    this.definitions[name] = value;
  }
  descartesJS.Evaluator.prototype.getDefinition = function(name) {
    return this.definitions[name];
  }
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  /**
   * Set the value to a variable
   * @param {String} name the name of the variable to set
   * @param {Object} value the value of the variable to set
   */
  descartesJS.Evaluator.prototype.setVariable = function(name, value) {
    this.variables[name] = value;
  }

  /**
   * Get the value to a variable
   * @param {String} name the name of the variable to get the value
   */
  descartesJS.Evaluator.prototype.getVariable = function(name) {
    return this.variables[name];
  }

  /**
   * Set the value of a position in a vector
   * @param {String} name the name of the vector to set
   * @param {Number} pos the position in the vector to set
   * @param {Object} value the value of the vector to set
   */
  descartesJS.Evaluator.prototype.setVector = function(name, pos, value) {
    pos = (pos<0) ? 0 : MathFloor(pos);
    this.vectors[name][pos] = value;
  }

  /**
   * Get the value to a vector
   * @param {String} name the name of the vector to get the value
   */
  descartesJS.Evaluator.prototype.getVector = function(name, pos) {
    pos = (pos<0) ? 0 : MathFloor(pos);
    return this.vectors[name][pos];
  }

  /**
   * Set the value of a position in a matrix
   * @param {String} name the name of the matrix to set
   * @param {Number} pos1 the row position in the matrix to set
   * @param {Number} pos2 the column position in the matrix to set
   * @param {Object} value the value of the matrix to set
   */
  descartesJS.Evaluator.prototype.setMatrix = function(name, pos1, pos2, value) {
    pos1 = (pos1<0) ? 0 : MathFloor(pos1);
    pos2 = (pos2<0) ? 0 : MathFloor(pos2);
    this.matrices[name][pos1][pos2] = value;
  }

  /**
   * Get the value to a matrix
   * @param {String} name the name of the matrix to get the value
   */
  descartesJS.Evaluator.prototype.getMatrix = function(name, pos1, pos2) {
    pos1 = (pos1<0) ? 0 : MathFloor(pos1);
    pos2 = (pos2<0) ? 0 : MathFloor(pos2);
    return this.matrices[name][pos1][pos2];
  }

  /**
   * Set the value to a function
   * @param {String} name the name of the function to set
   * @param {Object} value the value of the function to set
   */
  descartesJS.Evaluator.prototype.setFunction = function(name, value) {
    this.functions[name] = value;
  }

  /**
   * Get a function
   * @param {String} name the name of the function to get
   */
  descartesJS.Evaluator.prototype.getFunction = function(name) {
    return this.functions[name];
  }

  /**
   *
   */
  descartesJS.Evaluator.prototype.eval = function (expr) {
    return (expr) ? expr.evaluate(this) : 0;
  }

  // evaluator used in a range evaluation
  descartesJS.externalEvaluator = new descartesJS.Evaluator();

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var decimals;

  /**
   * A Descartes plain text (not RTF)
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} text the content text
   */
  descartesJS.TextObject = function(parent, text) {
    this.parent = parent;
    this.evaluator = parent.evaluator;
    this.decimals = parent.decimals;
    this.fixed = parent.fixed;
    this.align = parent.align || "left";
    this.anchor = parent.anchor || "a_top_left"
    this.decimal_symbol = parent.parent.decimal_symbol;

    this.w = 100;
    this.h = 100;

    this.hasContent = (text !== "");
    this.textStr = (text || "").replace(/\\{/g, "\\curlyBracketOpen ").replace(/\\}/g, "\\curlyBracketClose ").replace(/\\\[/g, "\\squareBracketOpen ").replace(/\\\]/g, "\\squareBracketClose ");
    this.oldTextStr = null;
    this.oldWidth = null;
    this.oldSize = null;
    this.oldColor = null;
    this.oldPosX = null;
    this.oldPoxY = null;

    // is a RTF text
    if (text.match(/^\{\\rtf1/)) {
      this.type = "rtfNode";
      this.text = text;
      this.textNodes = ( new descartesJS.RTFParser(parent.evaluator) ).parse(text.substring(10));
    }
    else {
      this.descarTeXParser = new descartesJS.DescarTeXParser();
      this.text = this.parseSimpleText(this.textStr);
      this.textNodes = new descartesJS.TextNode("", "textLineBlock", null, null)
    }

  }

  /**
   * 
   */
  descartesJS.TextObject.prototype.draw = function(ctx, fill, posX, posY, onlyUpdate) {
    // draw rtfText
    if (this.type === "rtfNode") {
      this.drawRTF(ctx, fill, posX, posY, onlyUpdate);
    }
    else {
      this.drawText(ctx, fill, posX, posY, onlyUpdate);
    }
  }

  /**
   * 
   */
  descartesJS.TextObject.prototype.drawText = function(ctx, fill, posX, posY, onlyUpdate) {
    var decimals = this.evaluator.eval(this.decimals);
    var width = this.evaluator.eval(this.parent.width);
    var size = this.evaluator.eval(this.parent.font_size);
    var color = (fill.getColor) ? fill.getColor() : fill;

    var newTextStr = this.textToString(this.text, decimals, this.fixed).replace(/\\{/g, "\\curlyBracketOpen ").replace(/\\}/g, "\\curlyBracketClose ").replace(/\\\[/g, "\\squareBracketOpen ").replace(/\\\]/g, "\\squareBracketClose ");

    // check if the newTextStr contains an expression
    if (newTextStr.indexOf("[") >= 0) {
      newTextStr = this.textToString(this.parseSimpleText(newTextStr), decimals, this.fixed);
    }

    if (
      (this.oldTextStr !== newTextStr) || 
      (this.oldWidth !== width) || 
      (this.oldSize !== size) || 
      (this.oldColor !== color) ||
      (this.oldPosX !== posX) || 
      (this.oldPoxY !== posY) 
    ) {
      var style = new descartesJS.TextStyle({ 
        size: size,
        family: this.parent.font_family || "arial",
        italic: this.parent.italics || false,
        bold: this.parent.bold || false,
        color: color,
        align: this.align,
        border: this.parent.border
      });

      this.textNodes = this.descarTeXParser.parse(newTextStr, this.evaluator, style);

      this.textNodes.update(posX, posY, decimals, this.fixed, this.align, this.anchor, color, width);
    }

    if (!onlyUpdate) {
      this.textNodes.draw(ctx);
    }

    this.oldTextStr = newTextStr;
    this.oldWidth = width;
    this.oldSize = size;
    this.oldColor = color;
    this.oldPosX = posX;
    this.oldPoxY = posY;
  }

  /**
   * 
   */
  descartesJS.TextObject.prototype.drawRTF = function(ctx, fill, posX, posY, onlyUpdate) {
    fill = (fill.getColor) ? fill.getColor() : fill;
    ctx.fillStyle = fill;
    ctx.strokeStyle = fill;
    ctx.textBaseline = "alphabetic";

    if (this.textNodes.style.align !== this.align) {
      this.textNodes.propagateStyle("align", this.align);
    }

    this.textNodes.update(posX, posY, this.evaluator.eval(this.decimals), this.fixed, this.align, this.anchor, fill, this.evaluator.eval(this.parent.width));

    if (!onlyUpdate) {
      this.textNodes.draw(ctx);
    }
  }

  /**
   * 
   */
  descartesJS.TextObject.prototype.parseSimpleText = function(text) {
    text = text.replace("&#x2013", "–").replace(/\&squot;/g, "'");

    var textElements = [];

    var txt = "'";
    var pos = 0;
    var lastPos = 0;
    var ignoreSquareBracket = -1;
    var charAt;
    var charAtAnt;
    var textLength = text.length;

    while (pos < textLength) {
      charAt = text.charAt(pos);
      charAtAnt = text.charAt(pos-1);

      // open square bracket scaped
      if ((charAt === "[") && (charAtAnt === "\\")) {
        textElements.push(text.substring(lastPos, pos-1) + "[");
        lastPos = pos+1;
      }

      // close square bracket scaped
      else if ((charAt === "]") && (charAtAnt === "\\")) {
        textElements.push(text.substring(lastPos, pos-1) + "]");
        lastPos = pos+1;
      }

      // if find an open square bracket
      else if ((charAt === "[") && (ignoreSquareBracket === -1)) {
        textElements.push(text.substring(lastPos, pos));
        lastPos = pos;
        ignoreSquareBracket++;
      }

      else if (charAt === "[") {
        ignoreSquareBracket++;
      }

      // if find a close square bracket add the string +'
      else if ((charAt === "]") && (ignoreSquareBracket === 0)) {
        textElements.push( this.evaluator.parser.parse(text.substring(lastPos, pos+1)) );
        lastPos = pos+1;
        ignoreSquareBracket--;
      }

      else if (text.charAt(pos) == "]") {
        ignoreSquareBracket = (ignoreSquareBracket < 0) ? ignoreSquareBracket : ignoreSquareBracket-1;
        txt = txt + text.charAt(pos);
      }

      else {
        txt = txt + text.charAt(pos);
      }

      pos++;
    }

    textElements.push(text.substring(lastPos, pos));

    return textElements;
  }

  /**
   * 
   */
  descartesJS.TextObject.prototype.textToString = function(text, decimals, fixed) {
    var txt = "";

    if (text.type !== "rtfNode") {
      var evalString;

      for(var i=0, l=text.length; i<l; i++) {
        if (typeof(text[i]) === "string") {
          txt += text[i];
        }
        else {
          evalString = this.evaluator.eval(text[i])[0][0];

          if (evalString !== "") {
            // the evaluation is a string
            if (typeof(evalString) === "string") {
              txt += evalString;
            }
            else if (evalString === Infinity) {
              txt += "Infinity";
            }
            else if (evalString === -Infinity) {
              txt += "-Infinity";
            }
            else if (isNaN(evalString) || (evalString === "NaN")) {
              txt += "NaN";
            }
            // the evaluation is a number
            else {
              evalString = parseFloat(evalString);
              
              evalString = (fixed) ? evalString.toFixed(decimals) : descartesJS.removeNeedlessDecimals(evalString.toFixed(decimals));
              txt += evalString.toString().replace(".", this.decimal_symbol);
            }
          }
        }
      }
    }

    return txt;
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
    if (descartesJS.loadLib) { return descartesJS; }
  
    var operatorRegExp = /^[\_\^]/;

    /**
     * A rtf tokenizer
     * @constructor
     */
    descartesJS.DescarTeXTokenizer = function() { };
  
    /**
     * Get a rtf parse tree from an input
     * @param {String} input the rtf text to tokenize
     */
    descartesJS.DescarTeXTokenizer.prototype.tokenize = function(input) {
      input = input.replace(/\\n/g, "\\newline ");

      var tokens = [];
      var lastToken = null;
      var pos = 0;
      var inputLenght = input.length;
      var currentChar;
      var nextChar = input.charAt(0);
      var isCommand = false;
      var inMath = false;
      var brackets_open = 0;

      // replace the operators _ and ^, for the commands \subindex{} and \superindex{} respectively
      newInput = "";
      for (var i=0; i<inputLenght; i++) {
        currentChar = input.charAt(i);
        nextChar = input.charAt(i+1);

        if ((currentChar === "\\") && (nextChar === "$")) {
          inMath = true;
        }

        if (currentChar === "{") {
          brackets_open++;
        }
        else if (currentChar === "}") {
          brackets_open--;
          if (inMath && brackets_open === 0) {
            inMath = false;
          }
        }

        if (inMath) {
          if (currentChar === "_") {
            if (nextChar === "{") {
              newInput += "\\subindex";
            }
            else {
              newInput += "\\subindex{" + nextChar + "}";
              i++;
            }
          }
          else if (currentChar === "^") {
            if (nextChar === "{") {
              newInput += "\\superindex";
            }
            else {
              newInput += "\\superindex{" + nextChar + "}";
              i++;
            }
          }
          else {
            newInput += currentChar;
          }
        }
        else {
          newInput += currentChar;
        }
      }

      input = newInput;
      nextChar = input.charAt(0);
      inputLenght = input.length;

      while (pos < inputLenght) {
        currentChar = nextChar;
        nextChar = input.charAt(pos+1);

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (isCommand) {
          if ((currentChar === "{") || (currentChar === "[") || (currentChar === "\\") || (currentChar === " ")) {
            isCommand = false;

            if (currentChar === " ") {
              lastToken = { type: "ignore" };
              tokens.push(lastToken);
            }
          }
          else {
            lastToken.value += currentChar;
          }
        }

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (!isCommand && (currentChar === "\\")) {
          isCommand = true;
          lastToken = { type: "command", value: "" };
          tokens.push(lastToken);
        }

        else if (!isCommand && ((currentChar === "{") || (currentChar === "["))) {
          lastToken = { type: "open", value: currentChar};
          tokens.push(lastToken);
        }
        else if (!isCommand && ((currentChar === "}") || (currentChar === "]"))) {
          lastToken = { type: "close", value: currentChar};
          tokens.push(lastToken);
        }
        // else if (!isCommand && (currentChar === "_")) {
        //   lastToken = { type: "command", value: "subindex" };
        //   tokens.push(lastToken);
        // }
        // else if (!isCommand && (currentChar === "^")) {
        //   lastToken = { type: "command", value: "superindex" };
        //   tokens.push(lastToken);
        // }

        else if (!isCommand) {
          if (lastToken && (lastToken.type === "text")) {
            lastToken.value += currentChar;
          }
          else if (lastToken && (lastToken.type === "ignore")) {
            tokens.pop();
            lastToken = tokens[tokens.length-1];
          }
          else {
            lastToken = { type: "text", value: currentChar };
            tokens.push(lastToken);
          }
        }

// console.log(currentChar)

        pos++;
      }
    
      return tokens;
    }
  
    return descartesJS;
  })(descartesJS || {});
  /**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
    if (descartesJS.loadLib) { return descartesJS; }
  
    /**
     * A rtf tokenizer
     * @constructor
     */
    descartesJS.DescarTeXParser = function() {
      this.tokenizer = new descartesJS.DescarTeXTokenizer();
    };
  
    /**
     * Get a rtf parse tree from an input
     * @param {String} input the rtf text to tokenize
     */
    descartesJS.DescarTeXParser.prototype.parse = function(input, evaluator, style) {
      var tokens = this.tokenizer.tokenize(input);

      // var textNodes = new descartesJS.TextNode(value, nodeType, style, evaluator);
      var textNodes = new descartesJS.TextNode("", "textBlock", style, null);
      var lastNode = new descartesJS.TextNode("", "textLineBlock", style.clone(), null);
      textNodes.addChild(lastNode);

      var commandStack = [];
      var lastCommand = null;
      var lastStyle = style;
      var styleStack = [style];
      var textParts;
      var newColor;
      var tmpNode;
      var mathMode = false;
// console.log(tokens);
      for (var i=0, l=tokens.length; i<l; i++) {
// console.log(tokens[i], "lastCommand:"+lastCommand, "tokens.type:"+tokens[i].type, "mathMode:"+mathMode);
// console.log(commandStack);
        if (tokens[i].type === "text") {
          if (lastNode.nodeType === "textLineBlock") {
            if (lastCommand === "color_parameter") {
              newColor = new descartesJS.Color(tokens[i].value, evaluator);
            }
            else {
              textParts = tokens[i].value.split(" ");
              for (var ti=0, tl=textParts.length; ti<tl; ti++) {
                if (textParts[ti] !== "") {
                  lastNode.addChild( new descartesJS.TextNode(textParts[ti], "text", lastStyle.clone(), null) );
                }
                if (ti+1 < tl) {
                  lastNode.addChild( new descartesJS.TextNode(" ", "space", lastStyle.clone(), null) );
                }
              }
            }
          }
          else {
            lastNode.addChild( new descartesJS.TextNode(tokens[i].value, "text", lastStyle.clone(), null) );
          }
        }

        else if ( (tokens[i].type === "command") && (tokens[i].value === "curlyBracketOpen") ) {
          lastNode.addChild( new descartesJS.TextNode("{", "text", lastStyle.clone(), null) );
        }
        else if ( (tokens[i].type === "command") && (tokens[i].value === "curlyBracketClose") ) {
          lastNode.addChild( new descartesJS.TextNode("}", "text", lastStyle.clone(), null) );
        }
        else if ( (tokens[i].type === "command") && (tokens[i].value === "squareBracketOpen") ) {
          lastNode.addChild( new descartesJS.TextNode("[", "text", lastStyle.clone(), null) );
        }
        else if ( (tokens[i].type === "command") && (tokens[i].value === "squareBracketClose") ) {
          lastNode.addChild( new descartesJS.TextNode("]", "text", lastStyle.clone(), null) );
        }

        else if ( (tokens[i].type === "command") && (tokens[i].value === "newline") ) {
          if (lastNode.children.length === 0) {
            lastNode.addChild( new descartesJS.TextNode("", "text", lastStyle.clone(), null) );
          }
          lastNode = new descartesJS.TextNode("", "textLineBlock", style.clone(), null);
          textNodes.addChild(lastNode);
        }
        else if ( (tokens[i].type === "command") && (tokens[i].value === "b") ) {
          lastCommand = "bold";
          commandStack.push(lastCommand);
        }
        else if ( (tokens[i].type === "command") && (tokens[i].value === "i") ) {
          lastCommand = "italic";
          commandStack.push(lastCommand);
        }
        else if ( (tokens[i].type === "command") && (tokens[i].value === "color") ) {
          lastCommand = "color";
          commandStack.push(lastCommand);
        }
        else if ( (tokens[i].type === "command") && (tokens[i].value === "c") ) {
          lastCommand = "center";
          commandStack.push(lastCommand);
        }
        else if ( (tokens[i].type === "command") && (tokens[i].value === "l") ) {
          lastCommand = "left";
          commandStack.push(lastCommand);
        }
        else if ( (tokens[i].type === "command") && (tokens[i].value === "r") ) {
          lastCommand = "right";
          commandStack.push(lastCommand);
        }
        else if ( (tokens[i].type === "command") && (tokens[i].value === "j") ) {
          lastCommand = "justify";
          commandStack.push(lastCommand);
        }

        else if ( (tokens[i].type === "command") && (tokens[i].value === "$") ) {
          lastCommand = "formula";
          commandStack.push(lastCommand);
          mathMode = true;
        }

        else if ( (tokens[i].type === "command") && (tokens[i].value === "sum") ) {
          lastCommand = "sum";
          commandStack.push(lastCommand);
        }
        else if ( (tokens[i].type === "command") && (tokens[i].value === "int") ) {
          lastCommand = "integral";
          commandStack.push(lastCommand);
        }
        else if ( (tokens[i].type === "command") && (tokens[i].value === "lim") ) {
          lastCommand = "limit";
          commandStack.push(lastCommand);
        }

        else if ( (tokens[i].type === "command") && (tokens[i].value === "sqrt") ) {
          lastCommand = "radical";
          commandStack.push(lastCommand);
        }
        

        
        else if ( (tokens[i].type === "command") && (tokens[i].value === "subindex") ) {
          lastCommand = "subIndex";
          commandStack.push(lastCommand);
        }
        else if ( (tokens[i].type === "command") && (tokens[i].value === "superindex") ) {
          lastCommand = "superIndex";
          commandStack.push(lastCommand);
        }
        else if ( (tokens[i].type === "command") && (tokens[i].value === "frac") ) {
          lastCommand = "numerator";
          commandStack.push(lastCommand);
        }


        else if ( (tokens[i].type === "open") && (tokens[i].value === "{") && (lastCommand !== null) ) {
          if ( (lastCommand === "bold") || (lastCommand === "italic") ) {
            newStyle = lastStyle.clone();
            newStyle[lastCommand] = true;
            styleStack.push( newStyle );
            lastStyle = newStyle;
          }

          else if (lastCommand === "color") {
            lastCommand = "color_parameter";
          }

          else if (lastCommand === "color_text") {
            newStyle = lastStyle.clone();
            newStyle.color = newColor;
            styleStack.push( newStyle );
            lastStyle = newStyle;
          }

          else if (
            (lastCommand === "center") ||
            (lastCommand === "left") ||
            (lastCommand === "right") ||
            (lastCommand === "justify") 
          ) {
            newStyle = lastStyle.clone();
            newStyle.align = lastCommand;
            styleStack.push( newStyle );
            lastStyle = newStyle;

            lastNode = new descartesJS.TextNode("", "textLineBlock", lastStyle.clone(), null);
            textNodes.addChild(lastNode);
          }

          else if (lastCommand === "formula") {
            newStyle = lastStyle.clone();
            newStyle.italic = true;
            styleStack.push( newStyle );
            lastStyle = newStyle;

            tmpNode = new descartesJS.TextNode("", "formula", lastStyle.clone(), null);
            lastNode.addChild(tmpNode);
            lastNode = tmpNode;
          }
          else if ( (lastCommand === "subIndex") || (lastCommand === "superIndex") ) {
            if (mathMode) {
              newStyle = lastStyle.clone();
              // newStyle.size = Math.max( Math.floor(newStyle.size*0.33), 8 );
              styleStack.push( newStyle );
              lastStyle = newStyle;

              tmpNode = new descartesJS.TextNode("", lastCommand, lastStyle.clone(), null);
              lastNode.addChild(tmpNode);
              lastNode = tmpNode;
            }
            else {
              lastNode.addChild( new descartesJS.TextNode(((lastCommand === "subIndex") ? "_" : "^" ), "text", lastStyle.clone(), null) );
            }
          }

          else if (lastCommand === "radical") {
            if (mathMode) {
              tmpNode = new descartesJS.TextNode("", "radical", lastStyle.clone(), null);
              lastNode.addChild(tmpNode);
              lastNode = tmpNode;

              newStyle = lastStyle.clone();
              // newStyle.size = Math.max( Math.floor(newStyle.size*0.5), 8 );
              styleStack.push( newStyle );
              lastStyle = newStyle;

              tmpNode = new descartesJS.TextNode("", "index", lastStyle.clone(), null);
              lastNode.addChild(tmpNode);
              lastNode = tmpNode;

              lastCommand = "index";
            }
          }
          else if (lastCommand === "index") {
            if (mathMode) {
              styleStack.pop();
              lastStyle = styleStack[styleStack.length -1];

              tmpNode = new descartesJS.TextNode("", "radicand", lastStyle.clone(), null);
              lastNode.addChild(tmpNode);
              lastNode = tmpNode;

              lastCommand = "radicand";
            }
          }


          else if ((lastCommand === "sum") || (lastCommand === "integral") || (lastCommand === "limit")) {
            if (mathMode) {
              tmpNode = new descartesJS.TextNode("", lastCommand, lastStyle.clone(), null);
              lastNode.addChild(tmpNode);
              lastNode = tmpNode;

              newStyle = lastStyle.clone();
              // newStyle.size = Math.max( Math.floor(newStyle.size*0.2), 8 );
              styleStack.push( newStyle );
              lastStyle = newStyle;

              tmpNode = new descartesJS.TextNode("", "from", lastStyle.clone(), null);
              lastNode.addChild(tmpNode);
              lastNode = tmpNode;

              lastCommand = "from";
            }
          }
          else if (lastCommand === "from") {
            if (mathMode) {
              tmpNode = new descartesJS.TextNode("", "to", lastStyle.clone(), null);
              lastNode.addChild(tmpNode);
              lastNode = tmpNode;

              lastCommand = "to";
            }
          }
          else if (lastCommand === "to") {
            if (mathMode) {
              styleStack.pop();
              lastStyle = styleStack[styleStack.length -1];

              tmpNode = new descartesJS.TextNode("", "what", lastStyle.clone(), null);
              lastNode.addChild(tmpNode);
              lastNode = tmpNode;

              lastCommand = "what";
            }
          }

          else if (lastCommand === "numerator") {
            if (mathMode) {
              tmpNode = new descartesJS.TextNode("", "fraction", lastStyle.clone(), null);
              lastNode.addChild(tmpNode);
              lastNode = tmpNode;

              newStyle = lastStyle.clone();
              // newStyle.size = Math.max( Math.floor(newStyle.size*0.1), 8 );
              styleStack.push( newStyle );
              lastStyle = newStyle;

              tmpNode = new descartesJS.TextNode("", "numerator", lastStyle.clone(), null);
              lastNode.addChild(tmpNode);
              lastNode = tmpNode;

              lastCommand = "numerator";
            }
          }
          else if (lastCommand === "denominator") {
            tmpNode = new descartesJS.TextNode("", lastCommand, lastStyle.clone(), null);
            lastNode.addChild(tmpNode);
            lastNode = tmpNode;
          }
        }

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        else if ( (tokens[i].type === "close") && (tokens[i].value === "}") && (lastCommand !== null) ) {
          if ( (lastCommand === "bold") || (lastCommand === "italic") || (lastCommand === "color_text") || (lastCommand === "color") ) {
            styleStack.pop();
            lastStyle = styleStack[styleStack.length -1];
            commandStack.pop();
            lastCommand = commandStack[commandStack.length -1];
          }
          else if (lastCommand === "color_parameter") {
              lastCommand = "color_text";
          }
          else if (
            (lastCommand === "center") ||
            (lastCommand === "left") ||
            (lastCommand === "right") ||
            (lastCommand === "justify") 
          ) {
            styleStack.pop();
            lastStyle = styleStack[styleStack.length -1];
            commandStack.pop();
            lastCommand = commandStack[commandStack.length -1];

            if ( (tokens[i+1]) && (tokens[i+1].type === "command") && (tokens[i+1].value === "newline") ) {
              lastNode = textNodes;
            }
            else {
              lastNode = new descartesJS.TextNode("", "textLineBlock", lastStyle.clone(), null);
              textNodes.addChild(lastNode);
            }
          }

          if (lastNode.nodeType === "formula") {
            mathMode = false;
            styleStack.pop();
            lastStyle = styleStack[styleStack.length -1];
            commandStack.pop();
            lastCommand = commandStack[commandStack.length -1];
            lastNode = lastNode.parent;
          }

          else if ( (lastNode.nodeType === "subIndex") || (lastNode.nodeType === "superIndex") ) {
            if (mathMode) {
              styleStack.pop();
              lastStyle = styleStack[styleStack.length -1];
              commandStack.pop();
              lastCommand = commandStack[commandStack.length -1];
              lastNode = lastNode.parent;
            }
          }

          else if (lastNode.nodeType === "index") {
            lastNode = lastNode.parent;
          }
          else if (lastNode.nodeType === "radicand") {
            commandStack.pop();
            lastCommand = commandStack[commandStack.length -1];
            lastNode = lastNode.parent.parent;
          }

          else if (lastNode.nodeType === "from") {
            lastNode = lastNode.parent;
          }
          else if (lastNode.nodeType === "to") {
            lastNode = lastNode.parent;
          }
          else if (lastNode.nodeType === "what") {
            commandStack.pop();
            lastCommand = commandStack[commandStack.length -1];
            lastNode = lastNode.parent.parent;
          }

          else if (lastNode.nodeType === "numerator") {
            lastCommand = "denominator";
            lastNode = lastNode.parent;
          }
          else if (lastNode.nodeType === "denominator") {
            styleStack.pop();
            lastStyle = styleStack[styleStack.length -1];
            commandStack.pop();
            lastCommand = commandStack[commandStack.length -1];
            lastNode = lastNode.parent.parent;
          }
        }

        // add { }
        else if ( (tokens[i].type === "open") && (tokens[i].value === "{") && (lastCommand === null) ) {
          lastNode.addChild( new descartesJS.TextNode("{", "text", lastStyle.clone(), null) );
        }
        else if ( (tokens[i].type === "close") && (tokens[i].value === "}") && (lastCommand === null) ) {
          lastNode.addChild( new descartesJS.TextNode("}", "text", lastStyle.clone(), null) );
        }


      }
      
      var currentNode;
      var nextNode;
      var joinNode = null;
      var toDelete = [];
      var tmpNode;
      // join text nodes into a word if two text nodes are together
      textNodes.children.forEach(function(line) {
        for (var i=0, l=line.children.length; i<l-1; i++) {
          currentNode = line.children[i];
          nextNode = line.children[i+1];

          if ((currentNode.nodeType === "text") && (nextNode.nodeType === "text")) {
            if (joinNode === null) {
              joinNode = currentNode;
              tmpNode = currentNode.clone();
              joinNode.changeNodeType("word");
              joinNode.value = "___" + tmpNode.value;
              joinNode.addChild(tmpNode);
            }
            tmpNode = nextNode.clone();
            joinNode.addChild(tmpNode);
            toDelete.push(nextNode);
            joinNode.value += tmpNode.value;

          }
          else {
            joinNode = null;
          }
        }
      });

      toDelete.forEach(function(node) {
        node.parent.removeChild(node);
      });
// console.log(textNodes, textNodes.normalize())

      textNodes.adjustFontSize();
      return textNodes.normalize();
    }
  
    return descartesJS;
  })(descartesJS || {});
  /**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var family;
  var familyArray = [descartesJS.sansserif_font, descartesJS.serif_font, descartesJS.monospace_font];

  /**
   * Font style for rtf text
   * @param {Number} size the size of the font
   * @param {String} family the font family name
   * @param {String} italic the flag if the text is italic
   * @param {String} bold the flag if the text is bold
   * @param {Boolean} underline the flag if the text is undelined
   * @param {Boolean} overline the flag if the text is overlined
   * @param {String} color the color of the text
   * @param {String} aling the aligment of the text
   * @constuctor
   */
  descartesJS.TextStyle = function(style) {
    // default values
    this.size = 20;
    this.family = "Arimo";
    this.italic = false;
    this.bold = false;
    this.underline = false;
    this.overline = false;
    this.color = null;
    this.align = "left";
    this.border = null;
    
    // this.familyIndex = null;

    // if the style is null or undefined then pass an empty object
    style = style || {};

    this.set(style);
  }

  /**
   * Clone a font style
   * @return {TextStyle} return a clone font style
   */
  descartesJS.TextStyle.prototype.clone = function() {
    var style = {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        style[property] = this[property];
      }
    }

    return new descartesJS.TextStyle(style);
  }

  /**
   * 
   */
  descartesJS.TextStyle.prototype.set = function(style) {
    for (var property in style) {
      if (style.hasOwnProperty(property)) {
        this[property] = style[property];
      }
    }
  }

  /**
   * 
   */
  descartesJS.TextStyle.prototype.equals = function(otherStyle) {
    var eq = true;
    for (var property in this) {
      if (this.hasOwnProperty(property)) {
        eq = eq && (this[property] === otherStyle[property]);
      }
    }
    return eq;
  }

  /**
   * Convert the font style to a string representation
   * @return {String} return the string representation of the style
   */
  descartesJS.TextStyle.prototype.toString = function() {
    if ((/arial|sansserif/i).test(this.family)) {
      family = familyArray[0];
    }
    else if ((/times|serif/i).test(this.family)) {
      family = familyArray[1];
    }
    else if ((/courier|monospaced/i).test(this.family)) {
      family = familyArray[2];
    }

    return ((this.bold ? 'bold' : '') + " " + (this.italic ? 'italic' : '') + " " + this.size + "px " + family).trim();
  }

return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  descartesJS.auxCtx = document.createElement("canvas").getContext("2d");
  
  var externalColor = "#000000";
  var externalDecimals = 2;
  var externalFixed = false;

  var radicalPathStr = "m 759,1 c -8,0 -15,4 -20,14 L 325,878 153,500 c -5,-11 -11,-14 -17,-9 L 2,596 c -5,4 17,30 22,26 l 65,-47 193,422 c 3,6 27,6 32,-4 L 773,40 V 1 Z";
  var radicalPath = new Path2D(radicalPathStr);
  radicalPath.svgData = radicalPathStr;
  var sigmaPathStr = "M 780,707 H 750 C 728,805 695,872 585,872 H 180 L 509,447 225,65 h 313 c 130,0 167,49 188,181 h 30 V 0 H 25 L 384,500 0,1000 h 729 z";
  var sigmaPath = new Path2D(sigmaPathStr);
  sigmaPath.svgData = sigmaPathStr;
  var integralPathStr = "m 150,828 c -21,88 -42,144 -83,144 -6,0 -9,-2 -9,-6 0,-9 15,-8 15,-34 0,-14 -13,-22 -27,-22 -24,0 -45,22 -45,51 0,20 21,39 56,39 97,0 141,-105 159,-176 L 375,181 c 23,-91 45,-154 89,-153 6,0 9,2 9,6 0,7 -15,13 -15,35 0,14 13,20 27,20 24,0 45,-22 45,-51 C 530,18 508,0 473,0 368,0 326,120 309,190 Z";
  var integralPath = new Path2D(integralPathStr);
  integralPath.svgData = integralPathStr;

  var factorMarginH = 0.075;
  var factorMarginV = 0.05;
  var factorPaddingH = 0.075;
  var factorPaddingV = 0.05;

  /**
   *
   */
  descartesJS.TextNode = function(value, nodeType, style, evaluator) {
    this.type = "rtfNode";
    this.evaluator = evaluator;

    this.parent = null;
    this.children = [];
    this.metrics = { ascent:0, descent:0, h:0, w:0, x:0, y:0, offsetX:0, offsetY:0, marginX:0, marginY:0, paddingX:0, paddingY:0 };

    this.value = value;
    this.style = style;
    this.changeNodeType(nodeType);

    this.drawBorder = function() {};
  }

  descartesJS.TextNode.prototype.changeNodeType = function(nodeType) {
    this.nodeType = nodeType;
    this.draw = null;
    
    switch(this.nodeType) {
      // the principal text block
      case ("textBlock"):
        this.draw = this.drawTextBlock;
        break;

      // a text line
      case ("textLineBlock"):
        this.draw = this.drawTextLineBlock;
        break;

      // a formula
      case ("formula"):
        this.draw = this.drawFormula;
        break;

      // a super index
      case ("superIndex"):
        this.draw = this.drawSuperIndex;
        break;

      // a sub index
      case ("subIndex"):
        this.draw = this.drawSubIndex;
        break;

      // a dynamic text
      case ("dynamicText"):
        this.draw = this.drawDynamicText;
        this.decimal_symbol = this.evaluator.parent.decimal_symbol;
        break;

      // a fraction
      case ("fraction"):
        this.draw = this.drawFraction;
        break;

      // a numerator or denominator
      case ("numerator"):
      case ("denominator"):
        this.draw = this.drawNumDen;
        break;

      // a radical
      case ("radical"):
        this.draw = this.drawRadical;
        break;

      // a limit
      case ("limit"):
        this.draw = this.drawLimit;
        break;

      // an integral
      case ("integral"):
        this.draw = this.drawIntegral;
        break;

      // a sum
      case ("sum"):
        this.draw = this.drawSum;
        break;

      // a matrix
      case ("matrix"):
        this.draw = this.drawMatrix;
        break;

      // a defparts element
      case ("defparts"):
        this.draw = this.drawDefparts;
        break;

      // a text or new line or math symbol
      case ("text"):
      case ("newLine"):
      case ("mathSymbol"):
        this.draw = this.drawText;
        break;

      // a black space 
      case ("space"):
        this.draw = this.drawSpace;
        break;

      // a word element
      case ("word"):
        this.draw = this.drawWord;
        break;

      // a hyperlink
      case ("hyperlink"):
        this.draw = this.drawHyperlink;
        break;

      // an index of a root or contents of a root or from value of a root
      // an index of a sum or contents of a sum or from value of a sum
      // an element
      case ("index"):
      case ("radicand"):
      case ("from"):
      case ("to"):
      case ("what"):
      case ("element"):
        this.draw = this.drawGenericBlock;
        break;

      // a component of a control
      case ("componentNumCtrl"):
        this.draw = this.drawComponentNumCtrl;
        break;

      // a component of a space
      case ("componentSpace"):
        this.draw = this.drawComponentSpace;
        break;
    }

  }

  /**
   *
   */
  descartesJS.TextNode.prototype.clone = function() {
    var cloneNode = new descartesJS.TextNode(this.value, this.nodeType, this.style.clone());

    for (var i=0, l=this.children.length; i<l; i++) {
      cloneNode.addChild(this.children[i].clone());
    }
    
    return cloneNode;
  }
  /**
   *
   */
  descartesJS.TextNode.prototype.toStr = function() {
    var str = this.value;

    for (var i=0, l=this.children.length; i<l; i++) {
      str += " " + this.children[i].toStr();
    }
    
    return str;
  }

  /**
   * 
   */
  descartesJS.TextNode.prototype.stringify = function() {
    var str = '{';

    str += '"NT":"' + this.nodeType + '",';

    str += '"V":"' + (this.value || "") + '",';

    str += '"C":[';
    for (var i=0, l=this.children.length; i<l; i++) {
      str += this.children[i].stringify() + ((i==l-1)?'':',');
    }
    str += '],';

    str += '"S":' + JSON.stringify(this.style);

    return str + '}';
  }

  /**
   * Add a child to the tree of nodes
   * @param {descartesJS.TextNode} child the child to add
   */
  descartesJS.TextNode.prototype.addChild = function(node, removeFromParent) {
    if (removeFromParent && (node.parent !== null)) {
      node.parent.removeChild(node);
    }
    // add reference to the parent
    node.parent = this;
    this.children.push(node);
  }

  /**
   * 
   */
  descartesJS.TextNode.prototype.removeChild = function(node) {
    var indexOf = this.children.indexOf(node);

    if (indexOf !== -1) {
      node.parent = null;
      this.children.splice(indexOf, 1);
    }
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.getFirstTextNode = function() {
    var node = this;

    while (node.children.length > 0) {
      node = node.children[0];
    }

    return node;
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.getLastTextNode = function() {
    var node = this;

    while (node.children.length > 0) {
      node = node.children[node.children.length-1];
    }

    return node;
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.nextSibling = function() {
    if (this.parent) {
      var current = null;
      for (var i=0, l=this.parent.children.length; i<l; i++) {
        if (current) {
          return this.parent.children[i];
        }

        if (this.parent.children[i] === this) {
          current = true;
        }
      }
    }

    return null;
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.prevSibling = function() {
    if (this.parent) {
      for (var i=0, l=this.parent.children.length-1; i<l; i++) {
        if (this.parent.children[i+1] === this) {
          return this.parent.children[i];
        }
      }
    }

    return null;
  }

  /**
   * 
   */
  descartesJS.TextNode.prototype.querySelectorAll = function(nodeType) {
    var elements = [];

    for (var i=0, l=this.children.length; i<l; i++) {
      elements = elements.concat( this.children[i].querySelectorAll(nodeType) );
    }

    if (this.nodeType === nodeType) {
      elements.push(this);
    }

    return elements;
  }

  /**
   * 
   */
  descartesJS.TextNode.prototype.insertBefore = function(referenceNode, newNode) {
    var indexOf = this.children.indexOf(referenceNode);

    if (indexOf !== -1) {
      newNode.parent = this;
      this.children.splice(indexOf, 0, newNode);
    }
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.insertAfter = function(referenceNode, newNode) {
    var indexOf = this.children.indexOf(referenceNode);

    if (indexOf !== -1) {
      newNode.parent = this;
      this.children.splice(indexOf+1, 0, newNode);
    }
  }

  /**
   * 
   */
  descartesJS.TextNode.prototype.normalize = function() {
    var emptyNodes = this.querySelectorAll("textLineBlock").concat( this.querySelectorAll("formula") ).concat( this.querySelectorAll("numerator") ).concat( this.querySelectorAll("denominator") ).concat( this.querySelectorAll("superIndex") ).concat( this.querySelectorAll("subIndex") ).concat( this.querySelectorAll("index") ).concat( this.querySelectorAll("subIndex") ).concat( this.querySelectorAll("radicand") ).concat( this.querySelectorAll("from") ).concat( this.querySelectorAll("to") ).concat( this.querySelectorAll("what") ).concat( this.querySelectorAll("element") );
    
    for (var i=0, l=emptyNodes.length; i<l; i++) {
      if (emptyNodes[i].children.length === 0) {
        emptyNodes[i].addChild(new descartesJS.TextNode("", "text", emptyNodes[i].style));
      }
    }

    var nodesWhitoutSiblings = this.querySelectorAll("formula").concat( this.querySelectorAll("fraction") ).concat( this.querySelectorAll("superIndex") ).concat( this.querySelectorAll("subIndex") ).concat( this.querySelectorAll("radical") ).concat( this.querySelectorAll("sum") ).concat( this.querySelectorAll("integral") ).concat( this.querySelectorAll("limit") ).concat( this.querySelectorAll("matrix") ).concat( this.querySelectorAll("defparts") ).concat( this.querySelectorAll("dynamicText") ).concat( this.querySelectorAll("componentNumCtrl") ).concat( this.querySelectorAll("componentSpace") );

    for (var i=0, l=nodesWhitoutSiblings.length; i<l; i++) {
      if ( (nodesWhitoutSiblings[i].prevSibling() === null) || ((nodesWhitoutSiblings[i].prevSibling() !== null) && (nodesWhitoutSiblings[i].prevSibling().nodeType !== "text")) ) {
        nodesWhitoutSiblings[i].parent.insertBefore(nodesWhitoutSiblings[i], new descartesJS.TextNode("", "text", nodesWhitoutSiblings[i].parent.style));
      }
      if ( (nodesWhitoutSiblings[i].nextSibling() === null) || ((nodesWhitoutSiblings[i].nextSibling() !== null) && (nodesWhitoutSiblings[i].nextSibling().nodeType !== "text")) ) {
        nodesWhitoutSiblings[i].parent.insertAfter(nodesWhitoutSiblings[i], new descartesJS.TextNode("", "text", nodesWhitoutSiblings[i].parent.style));
      }
    }

    return this;
  }

  /**
   * 
   */
  descartesJS.TextNode.prototype.removeEmptyText = function() {
    var textNodes = this.querySelectorAll("text");
    for (var i=0, l=textNodes.length; i<l; i++) {
      if ((textNodes[i].value === "") && (textNodes[i].parent)) {
        textNodes[i].parent.removeChild(textNodes[i]);
      }
    }
  }

  /**
   * 
   */
  descartesJS.TextNode.prototype.adjustFontSize = function(insideFormula) {
    var fontSize = this.style.size;

    if (this.nodeType === "formula") {
      insideFormula = true;
    }

    for (var i=0, l=this.children.length; i<l; i++) {
      if ((this.children[i].nodeType === "text") && (insideFormula)) {
        this.children[i].style.size = fontSize;
        this.children[i].styleString = this.children[i].style.toString();
      }

      else if (this.children[i].nodeType === "index") {
        this.children[i].style.size = Math.max( parseInt(fontSize - fontSize*0.5), 8 );
        this.children[i].styleString = this.children[i].style.toString();
        this.children[i].adjustFontSize(true);
      }

      else if (
        (this.children[i].nodeType === "to") ||
        (this.children[i].nodeType === "from")
      ) {
        this.children[i].style.size = Math.max( parseInt(fontSize - fontSize*0.2), 8 );
        this.children[i].styleString = this.children[i].style.toString();
        this.children[i].adjustFontSize(true);
      }

      else if (
        (this.children[i].nodeType === "numerator") ||
        (this.children[i].nodeType === "denominator")
      ) {
        this.children[i].style.size = Math.max( parseInt(fontSize - fontSize*0.1), 8 );
        this.children[i].styleString = this.children[i].style.toString();
        this.children[i].adjustFontSize(true);
      }      

      else if (
        (this.children[i].nodeType === "subIndex") ||
        (this.children[i].nodeType === "superIndex")
      ) {
        this.children[i].style.size = Math.max( parseInt(fontSize - fontSize*0.33), 8 );
        this.children[i].styleString = this.children[i].style.toString();
        this.children[i].adjustFontSize(true);
      }

      else {
        if (insideFormula) {
          this.children[i].style.size = fontSize;
          this.children[i].styleString = this.children[i].style.toString();
        }
        this.children[i].adjustFontSize(insideFormula);
      }
    }
  }

  /**
   * 
   */
  descartesJS.TextNode.prototype.propagateStyle = function(prop, value) {
    this.style[prop] = value;
    this.styleString = this.style.toString();

    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].propagateStyle(prop, value);
    }
  }

  /**
   * 
   */
  descartesJS.TextNode.prototype.update = function(x, y, decimals, fixed, align, anchor, color, width) {
    externalDecimals = decimals;
    externalFixed = fixed;
    externalColor = color;

    this.metrics.w = this.metrics.h = 0;

    var oldY = y;

    // word wrap, find the new lines of the text
    if (width >= 20) {
      for (var i=0; i<this.children.length; i++) {
        this.children[i].breakLines(width);
      }
    }

    var self = this;
    var lineSep;
    var line;

    for (var i=0, l=this.children.length; i<l; i++) {
      line = this.children[i];
      line.updateLine();

      line.metrics.offsetX = x;

      line.metrics.y = y;
      y += parseInt(line.metrics.ascent +0.5);
      line.metrics.offsetY = y;
      
      lineSep = parseInt(line.metrics.descent +0.5) +parseInt(1.5 + line.style.size*0.05);
      y += lineSep;

      self.metrics.h += line.metrics.h;
      self.metrics.w = Math.max(self.metrics.w, line.metrics.w);
    };

    y = oldY;
    ////////////////////////////////////////////////////
    // anchor
    anchor = anchor || "";
    // horizontal left
    if (anchor.match("right")) {
      x -= this.metrics.w;
    }
    // horizontal center
    else if (anchor.match("_center")) {
      x -= this.metrics.w/2;
    }

    // vertical bottom
    if (anchor.match("bottom")) {
      y -= this.metrics.h;
    }
    // vertical center
    else if (anchor.match("center_")) {
      y -= this.metrics.h/2;
    }
    ////////////////////////////////////////////////////


    var lines = this.children;
    for (var i=0, l=lines.length; i<l; i++) {
      if (lines[i].style.align === "left") {
        lines[i].metrics.offsetX = x;
      }
      else if (lines[i].style.align === "right") {
        lines[i].metrics.offsetX = x + this.metrics.w - lines[i].metrics.w;
      }
      else if (lines[i].style.align === "center") {
        lines[i].metrics.offsetX = x + (this.metrics.w - lines[i].metrics.w)/2;
      }
      else if ((lines[i].style.align === "justify") && (width >= 20)) {
        lineValue = (i<l-1) ? lines[i+1].value : null;
        lines[i].metrics.offsetX = x;

        if (lineValue === "wrap") {
          lines[i].justifyAux(width);
        }

      }

      lines[i].metrics.y = y;
      y += parseInt(lines[i].metrics.ascent +0.5);
      lines[i].metrics.offsetY = y;
      
      lineSep = parseInt(lines[i].metrics.descent +0.5) +parseInt(1.5 + lines[i].style.size*0.05);
      y += lineSep;
    }

  }

  /**
   * 
   */
  descartesJS.TextNode.prototype.breakLines = function(width) {
    var thisLine = this;
    var children_i;
    var lineWidth = 0;
    var finish = false;
    var childrenArray = [];

    for (var i=0, l=this.children.length; i<l; i++) {
      children_i = this.children[i];

      if (!finish) {
        if ((children_i.nodeType === "text") || (children_i.nodeType === "space")) {
          descartesJS.auxCtx.font = children_i.style.toString();
          children_i.metrics.w = descartesJS.auxCtx.measureText(children_i.value).width;
        }
        else if (children_i.nodeType === "word") {
          children_i.updateLine();
        }
        else if (children_i.nodeType === "formula") {
          children_i.updateFormula();
        }

        lineWidth += children_i.metrics.w;

        if ((lineWidth > width) && (children_i.nodeType !== "space") && (i>0)) {
          finish = true;
          childrenArray.push(children_i);
        }
      }

      else {
        childrenArray.push(children_i);
      }
    }

    if (childrenArray.length > 0) {
      var newLine = new descartesJS.TextNode("wrap", "textLineBlock", this.style.clone(), null);
      this.parent.insertAfter(thisLine, newLine);

      for (var i=0, l=childrenArray.length; i<l; i++) {
        if (childrenArray[i].parent) {
          childrenArray[i].parent.removeChild(childrenArray[i]);
        }
        newLine.addChild(childrenArray[i]);
      }
    }
  }

  /**
   * 
   */
  descartesJS.TextNode.prototype.updateLine = function(spaceWidth) {
    var thisLine = this;

    if ((this.nodeType === "textLineBlock") || (this.nodeType === "word")) {
      this.metrics.w = 0;
      this.metrics.ascent = 0;
      this.metrics.descent = 0;

      var displaceX = 0;
      var children = this.children;
      var children_i;

      for (var i=0, l=children.length; i<l; i++) {
        children_i = children[i];

        //////////////////////////////////////////////////////////
        if (children_i.nodeType === "text") {
          descartesJS.auxCtx.font = children_i.style.toString();
          var value = (children_i.value !== "") ? children_i.value : "\u200A";
          children_i.metrics = getFontMetrics(descartesJS.auxCtx.font);
          children_i.metrics.w = descartesJS.auxCtx.measureText(value).width;

          children_i.metrics.offsetX = displaceX;

          Object.defineProperties(children_i.metrics, {
            "x" : { get : function() { return thisLine.metrics.offsetX + this.offsetX } },
            "y" : { get : function() { return thisLine.metrics.offsetY + this.offsetY; } }
          });
        }

        //////////////////////////////////////////////////////////
        if (children_i.nodeType === "space") {
          descartesJS.auxCtx.font = children_i.style.toString();
          children_i.metrics = getFontMetrics(descartesJS.auxCtx.font);
          if (i === l-1) {
            children_i.metrics.w = 0;
          }
          else if (spaceWidth) {
            children_i.metrics.w = spaceWidth;
          }
          else {
            children_i.metrics.w = descartesJS.auxCtx.measureText(" ").width;
          }
  
          children_i.metrics.offsetX = displaceX;
          
          Object.defineProperties(children_i.metrics, {
            "x" : { get : function() { return thisLine.metrics.offsetX + this.offsetX; } },
            "y" : { get : function() { return thisLine.metrics.offsetY + this.offsetY; } }
          });
        }

        //////////////////////////////////////////////////////////
        else if (children_i.nodeType === "word") {
          children_i.updateLine();
  
          children_i.metrics.offsetX_aux = displaceX;
  
          Object.defineProperties(children_i.metrics, {
            "offsetX" : { get : function() { return thisLine.metrics.offsetX + this.offsetX_aux; } },
            "offsetY" : { get : function() { return thisLine.metrics.offsetY; } },
          });
        }

        //////////////////////////////////////////////////////////
        if (children_i.nodeType === "hyperlink") {
          descartesJS.auxCtx.font = children_i.styleString;
          var value = (children_i.value !== "") ? children_i.value : "\u200A";
          children_i.metrics = getFontMetrics(descartesJS.auxCtx.font);
          children_i.metrics.w = descartesJS.auxCtx.measureText(value).width;

          children_i.metrics.offsetX = displaceX;

          Object.defineProperties(children_i.metrics, {
            "x" : { get : function() { return thisLine.metrics.offsetX + this.offsetX } },
            "y" : { get : function() { return thisLine.metrics.offsetY; } }
          });

          ////
          if (!children_i.clickCacher) {
            children_i.clickCacher = document.createElement("div");
            children_i.clickCacher.setAttribute("style", "position:absolute;width:" + children_i.metrics.w + "px;height:" + children_i.metrics.h + "px;cursor:pointer;");
            children_i.clickCacher.rtfNode = children_i;
            children_i.clickCacher.action = new descartesJS.OpenURL(this.evaluator.parent, children_i.URL);
        
            children_i.clickCacher.addEventListener("click", function(evt) {
              this.rtfNode.click = true;
              this.action.execute();
              this.rtfNode.draw(this.rtfNode.ctx);
            });
          }
          ////
        }

        //////////////////////////////////////////////////////////
        if (children_i.nodeType === "componentNumCtrl") {
          children_i.componentNumCtrl = this.evaluator.parent.getControlByCId(children_i.value);

          descartesJS.auxCtx.font = children_i.styleString;
          children_i.metrics = getFontMetrics(descartesJS.auxCtx.font);
          children_i.metrics.w = children_i.componentNumCtrl.w;
          children_i.metrics.h = children_i.componentNumCtrl.h;

          children_i.metrics.offsetX = displaceX;

          Object.defineProperties(children_i.metrics, {
            "x" : { get : function() { return thisLine.metrics.offsetX + this.offsetX } },
            "y" : { get : function() { return thisLine.metrics.offsetY; } }
          });
        }

        //////////////////////////////////////////////////////////
        if (children_i.nodeType === "componentSpace") {
          children_i.componentSpace = this.evaluator.parent.getSpaceByCId(children_i.value);

          descartesJS.auxCtx.font = children_i.styleString;
          children_i.metrics = getFontMetrics(descartesJS.auxCtx.font);
          children_i.metrics.w = children_i.componentSpace.w;
          children_i.metrics.h = children_i.componentSpace.h;

          children_i.metrics.offsetX = displaceX;

          Object.defineProperties(children_i.metrics, {
            "x" : { get : function() { return thisLine.metrics.offsetX + this.offsetX } },
            "y" : { get : function() { return thisLine.metrics.offsetY; } }
          });
        }

        //////////////////////////////////////////////////////////
        else if (children_i.nodeType === "formula") {
          children_i.updateFormula();

// children_i.metrics.marginX = parseInt(1.5 + this.style.size*factorMarginH);
// children_i.metrics.marginY = parseInt(1.5 + this.style.size*factorMarginV);

// children_i.metrics.paddingX = parseInt(1.5 + this.style.size*factorPaddingH);
// children_i.metrics.paddingY = parseInt(1.5 + this.style.size*factorPaddingV);

          children_i.metrics.offsetX_aux = displaceX;

          Object.defineProperties(children_i.metrics, {
            "x" : { get : function() { return this.offsetX; } },
            "y" : { get : function() { return this.offsetY; } },

            "offsetX" : { get : function() { return thisLine.metrics.offsetX +this.marginX +this.offsetX_aux; } },
            "offsetY" : { get : function() { return thisLine.metrics.offsetY; } }
          });

          children_i.metrics.w += 2*children_i.metrics.paddingX;
          children_i.metrics.ascent += children_i.metrics.paddingY;
          children_i.metrics.descent += children_i.metrics.paddingY;
          children_i.metrics.h += 2*children_i.metrics.paddingY;

          displaceX += 2*children_i.metrics.marginX;
        }

        // line metrics
        this.metrics.w += children_i.metrics.w +2*children_i.metrics.marginX;
        this.metrics.ascent = Math.max(this.metrics.ascent, children_i.metrics.ascent);
        this.metrics.descent = Math.max(this.metrics.descent, children_i.metrics.descent);
        displaceX += children_i.metrics.w;
      }

      this.metrics.h = this.metrics.ascent + this.metrics.descent;
    }
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.updateFormula = function() {
    var thisFormula = this;

    this.metrics = { ascent:0, descent:0, h:0, w:0, x:0, y:0, offsetX:0, offsetY:0, marginX:0, marginY:0, paddingX:0, paddingY:0 };

    var children = this.children;
    var children_i;
    var displaceX = 0;

    var prevChild = { metrics : { ascent:0, descent:0, h:0, w:0, x:0, y:0, offsetX:0, offsetY:0, marginX:0, marginY:0, paddingX:0, paddingY:0 } };

    for (var i=0, l=children.length; i<l; i++) {
      children_i = children[i];

      //////////////////////////////////////////////////////////
      if (children_i.nodeType === "text") {
        descartesJS.auxCtx.font = children_i.style.toString();
        var value = (children_i.value !== "") ? children_i.value : "\u200A";
        children_i.metrics = getFontMetrics(descartesJS.auxCtx.font);
        children_i.metrics.w = descartesJS.auxCtx.measureText(value).width;

        children_i.metrics.offsetX = displaceX;

        Object.defineProperties(children_i.metrics, {
          "x" : { get : function() { return thisFormula.metrics.offsetX +thisFormula.metrics.paddingX +this.offsetX ; } },
          "y" : { get : function() { return thisFormula.metrics.offsetY; } }
        });

        displaceX += thisFormula.metrics.marginX;
      }

      
      //////////////////////////////////////////////////////////
      else if (children_i.nodeType === "dynamicText") {
        var decimals = (children_i.decimals === undefined) ? externalDecimals : children_i.evaluator.eval(children_i.decimals);
        var fixed = (children_i.fixed === undefined) ? externalFixed : children_i.fixed;
    
        var textTemp = children_i.evaluator.eval(children_i.value);
    
        // if the text is a number
        if (parseFloat(textTemp).toString() === textTemp.toString()) {
          textTemp = (fixed) ? parseFloat(textTemp).toFixed(decimals) : descartesJS.removeNeedlessDecimals((parseFloat(textTemp).toFixed(decimals)));
          textTemp = (""+textTemp).replace(".", children_i.decimal_symbol);
        }
        
        children_i.evalValue = textTemp;

        descartesJS.auxCtx.font = children_i.style.toString();
        children_i.metrics = getFontMetrics(descartesJS.auxCtx.font);

        children_i.metrics.marginX = parseInt(1.5 + this.style.size*factorMarginH);
        children_i.metrics.paddingX = parseInt(1.5 + this.style.size*factorPaddingH);

        children_i.metrics.w = descartesJS.auxCtx.measureText(textTemp).width + 2*children_i.metrics.paddingX;

        children_i.metrics.offsetX_aux = displaceX;

        Object.defineProperties(children_i.metrics, {
          "x" : { get : function() { return this.offsetX; } }, 
          "y" : { get : function() { return this.offsetY; } }, 

          "offsetX" : { get : function() { return thisFormula.metrics.offsetX +thisFormula.metrics.paddingX +this.offsetX_aux +this.marginX; } }, 
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY; } },
        });

        displaceX += 2*children_i.metrics.marginX;
      }

      //////////////////////////////////////////////////////////
      if (children_i.nodeType === "superIndex") {
        var superIndex = children_i;
        superIndex.updateFormula();

        superIndex.metrics.marginX = 0*parseInt(1.5 + this.style.size*factorMarginH);
        superIndex.metrics.paddingX = 0*parseInt(1.5 + this.style.size*factorPaddingH);
        superIndex.metrics.paddingY = parseInt(1.5 + this.style.size*factorPaddingV);

        superIndex.metrics.offsetX_aux = displaceX;

        superIndex.metrics.prevChild = prevChild;

        Object.defineProperties(superIndex.metrics, {
          "x" : { get : function() { return this.offsetX; } }, 
          "y" : { get : function() { return this.offsetY; } }, 

          "offsetX" : { get : function() { return thisFormula.metrics.offsetX +thisFormula.metrics.paddingX +this.offsetX_aux +this.marginX; } }, 
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY -this.descent +this.prevChild.metrics.descent -parseInt(2*this.prevChild.metrics.h/7); } },
        });

        superIndex.metrics.w += 2*superIndex.metrics.paddingX;
        superIndex.metrics.ascent += superIndex.metrics.paddingY;
        superIndex.metrics.descent += superIndex.metrics.paddingY;
        superIndex.metrics.h += 2*superIndex.metrics.paddingY;

        this.metrics.ascent = superIndex.metrics.descent - superIndex.metrics.prevChild.metrics.descent + parseInt(2*superIndex.metrics.prevChild.metrics.h/7) + superIndex.metrics.ascent;

        displaceX += 2*superIndex.metrics.marginX;
      }

      //////////////////////////////////////////////////////////
      else if (children_i.nodeType === "subIndex") {
        var subIndex = children_i;
        subIndex.updateFormula();

        subIndex.metrics.marginX = parseInt(1.5 + 1.25*this.style.size*factorMarginH);
        subIndex.metrics.paddingX = 0*parseInt(1.5 + 0.25*this.style.size*factorPaddingH);
        subIndex.metrics.paddingY = parseInt(1.5 + this.style.size*factorPaddingV);

        subIndex.metrics.offsetX_aux = displaceX;

        subIndex.metrics.prevChild = prevChild;

        Object.defineProperties(subIndex.metrics, {
          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return thisFormula.metrics.offsetX +thisFormula.metrics.paddingX +this.offsetX_aux +0*this.marginX; } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY +this.ascent +subIndex.metrics.prevChild.metrics.descent -parseInt(4*subIndex.metrics.prevChild.metrics.h/7); } },
        });

        // subIndex.metrics.w += 2*subIndex.metrics.paddingX;
        subIndex.metrics.w += subIndex.metrics.paddingX;
        subIndex.metrics.ascent += subIndex.metrics.paddingY;
        subIndex.metrics.descent += subIndex.metrics.paddingY;
        subIndex.metrics.h += 2*subIndex.metrics.paddingY;

        this.metrics.descent = subIndex.metrics.ascent +subIndex.metrics.prevChild.metrics.descent -parseInt(4*subIndex.metrics.prevChild.metrics.h/7) +subIndex.metrics.descent;

        // displaceX += 2*subIndex.metrics.marginX;
        displaceX += subIndex.metrics.marginX;
      }

      //////////////////////////////////////////////////////////
      else if (children_i.nodeType === "fraction") {
        var fraction = children_i;

        fraction.updateFormula();

        var components = fraction.children;
        var num = components[0];
        var den = components[1];

        fraction.metrics.marginX = parseInt(1.5 + this.style.size*factorMarginH);
        fraction.metrics.paddingX = 0* parseInt(1.5 + this.style.size*factorPaddingH);
        fraction.metrics.paddingY = 0* parseInt(1.5 + this.style.size*factorPaddingV);

        var maxWidth = Math.max(num.metrics.w, den.metrics.w) +2*fraction.metrics.paddingX;

        fraction.metrics.prevChild = prevChild;

        fraction.metrics.offsetX_aux = displaceX;
        var offsetY = parseInt(-prevChild.metrics.descent +4*prevChild.metrics.h/9);

        // fraction position
        Object.defineProperties(fraction.metrics, {
          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY +offsetY; } },

          "offsetX" : { get : function() { return thisFormula.metrics.offsetX +thisFormula.metrics.paddingX +this.marginX +this.offsetX_aux; } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY -offsetY; } },
        });

        // num position
        Object.defineProperties(num.metrics, {
          "parent" : { value : fraction },
          "maxWidth" : { value : maxWidth },

          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return this.parent.metrics.offsetX + parseInt((this.maxWidth - this.w)/2); } },
          "offsetY" : { get : function() { return this.parent.metrics.offsetY - this.descent -this.parent.metrics.paddingY; } },
        });

        // den position
        Object.defineProperties(den.metrics, {
          "parent" : { value : fraction },
          "maxWidth" : { value : maxWidth },

          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return this.parent.metrics.offsetX + parseInt((this.maxWidth - this.w)/2); } },
          "offsetY" : { get : function() { return this.parent.metrics.offsetY + this.ascent + this.parent.metrics.paddingY; } },
        });

        fraction.metrics.w = maxWidth;
        fraction.metrics.ascent = num.metrics.h +offsetY +2*fraction.metrics.paddingY;
        fraction.metrics.descent = den.metrics.h -offsetY +2*fraction.metrics.paddingY;
        fraction.metrics.h = num.metrics.h + den.metrics.h +4*fraction.metrics.paddingY;

        displaceX += 2*fraction.metrics.marginX;
      }

      //////////////////////////////////////////////////////////
      else if (children_i.nodeType === "radical") {
        var radical = children_i;

        radical.updateFormula();

        var components = radical.children;
        var index = components[0];
        var radicand = components[1];

        radical.metrics.marginX = parseInt(1.5 + this.style.size*factorMarginH);
        radical.metrics.paddingX = parseInt(1.5 + this.style.size*factorPaddingH);
        radical.metrics.paddingY = parseInt(1.5 + this.style.size*factorPaddingV);

        radical.metrics.offsetX_aux = displaceX;
        // radical position
        Object.defineProperties(radical.metrics, {
          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return thisFormula.metrics.offsetX +thisFormula.metrics.paddingX +this.marginX +this.offsetX_aux; } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY; } },
        });

        //////////////////////////////////
        // w=772, h=1000 radicalSign
        var fontSize = radical.style.size;
        radical.radicalSign = {
          w : fontSize,
          scaleX : fontSize/722,
          scaleY : radicand.metrics.h/1000,
        };
        var displaceIndex = parseInt(index.metrics.w - 2*radical.radicalSign.w/3);

        Object.defineProperties(radical.radicalSign, {
          "parent" : { value : radical },
          "displaceIndex" : { value : displaceIndex },

          "x" : { get: function() { return this.parent.metrics.offsetX +this.parent.metrics.paddingX + Math.max(this.displaceIndex, 0); } },
          "y" : { get: function() { return thisFormula.metrics.offsetY -radicand.metrics.ascent; } },
        });

        // index position
        Object.defineProperties(index.metrics, {
          "parent" : { value : radical },
          "displaceIndex" : { value : displaceIndex },
          "fontSize" : { value : fontSize },

          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return this.parent.metrics.offsetX +this.parent.metrics.paddingX + Math.max(this.displaceIndex, 0) -this.displaceIndex; } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY -this.descent -2*this.fontSize/5; } },
        });

        // radicand position
        Object.defineProperties(radicand.metrics, {
          "parent" : { value : radical },
          "displaceIndex" : { value : displaceIndex },

          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return this.parent.metrics.offsetX +this.parent.metrics.paddingX +this.parent.radicalSign.w +Math.max(this.displaceIndex, 0) } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY; } },
        });
        
        var indexWidth = (index.metrics.w < 2*radical.radicalSign.w/3) ? radical.radicalSign.w : parseInt(index.metrics.w+radical.radicalSign.w/3);

        radical.metrics.w = indexWidth +2*radical.metrics.paddingX + radicand.metrics.w;
        radical.metrics.ascent = Math.max(radicand.metrics.ascent, (index.metrics.h +2*fontSize/5)) +radical.metrics.paddingY;
        radical.metrics.descent = radicand.metrics.descent +radical.metrics.paddingY;
        radical.metrics.h = radical.metrics.ascent + radical.metrics.descent;

        displaceX += 2*radical.metrics.marginX;
      }

      //////////////////////////////////////////////////////////
      else if (children_i.nodeType === "sum") {
        var sum = children_i;

        sum.updateFormula();

        var components = sum.children;
        var sumFrom = components[0];
        var sumTo = components[1];
        var sumWhat = components[2];

        sum.metrics.marginX = parseInt(1.5 + this.style.size*factorMarginH);
        sum.metrics.paddingX = parseInt(1.5 + this.style.size*factorPaddingH);
        sum.metrics.paddingY = parseInt(1.5 + this.style.size*factorPaddingV);

        sum.metrics.offsetX_aux = displaceX;

        // sum position
        Object.defineProperties(sum.metrics, {
          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return thisFormula.metrics.offsetX +thisFormula.metrics.paddingX +this.marginX +this.offsetX_aux; } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY; } },
        });

        //////////////////////////////////
        // w=780, h=1000
        descartesJS.auxCtx.font = children_i.style.toString();
        var tmpMetric = getFontMetrics(descartesJS.auxCtx.font);
        
        var sigmaHeight = parseInt(tmpMetric.h*1.2);
        var sigmaWidth = parseInt(0.5 +sigmaHeight*780/1000);
        sum.sigmaSign = {
          w : sigmaWidth,
          h : sigmaHeight,
          scale : sigmaHeight/1000,
        };
        var sumWidth = Math.max(sumTo.metrics.w, sumFrom.metrics.w, sum.sigmaSign.w);

        sum.sigmaSign.parent = sum;
        Object.defineProperties(sum.sigmaSign, {
          "sumWidth" : { value : sumWidth },

          "x" : { get: function() { return this.parent.metrics.offsetX + this.parent.metrics.paddingX +parseInt((this.sumWidth - this.w)/2); } },
          "y" : { get: function() { return thisFormula.metrics.offsetY +tmpMetric.descent -(this.h +tmpMetric.h)/2; } },
        });

        var newBaselineTo = tmpMetric.descent -sumTo.metrics.descent -(sigmaHeight +tmpMetric.h)/2 -sum.metrics.paddingY;

        // sumTo position
        Object.defineProperties(sumTo.metrics, {
          "parent" : { value : sum },
          "sumWidth" : { value : sumWidth },
          "newBaselineTo" : { value : newBaselineTo },

          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return this.parent.metrics.offsetX + this.parent.metrics.paddingX +parseInt((this.sumWidth - this.w)/2); } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY + this.newBaselineTo; } },
        });

        var newBaselineFrom = sumFrom.metrics.ascent +tmpMetric.descent +(sigmaHeight -tmpMetric.h)/2 +sum.metrics.paddingY;

        // sumFrom position
        Object.defineProperties(sumFrom.metrics, {
          "parent" : { value : sum },
          "sumWidth" : { value : sumWidth },
          "newBaselineFrom" : { value : newBaselineFrom },

          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return this.parent.metrics.offsetX + this.parent.metrics.paddingX +parseInt((this.sumWidth - this.w)/2); } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY + this.newBaselineFrom; } },
        });

        // sumWhat position
        Object.defineProperties(sumWhat.metrics, {
          "parent" : { value : sum },
          "sumWidth" : { value : sumWidth },

          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return this.parent.metrics.offsetX + 2*this.parent.metrics.paddingX +this.sumWidth; } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY; } },
        });

        sum.metrics.w = sumWidth + sumWhat.metrics.w +3*sum.metrics.paddingX;
        sum.metrics.ascent = Math.max( sumWhat.metrics.ascent, (-newBaselineTo +sumTo.metrics.ascent) ) +sum.metrics.paddingY;
        sum.metrics.descent = Math.max( sumWhat.metrics.descent, (newBaselineFrom +sumFrom.metrics.descent) ) +sum.metrics.paddingY;
        sum.metrics.h = sum.metrics.ascent + sum.metrics.descent;

        displaceX += 2*sum.metrics.marginX;
      }
      
      //////////////////////////////////////////////////////////
      else if (children_i.nodeType === "integral") {
        var integral = children_i;

        integral.updateFormula();

        var components = integral.children;
        var integralFrom = components[0];
        var integralTo = components[1];
        var integralWhat = components[2];

        integral.metrics.marginX = parseInt(1.5 + this.style.size*factorMarginH);
        integral.metrics.paddingX = parseInt(1.5 + this.style.size*factorPaddingH);
        integral.metrics.paddingY = parseInt(1.5 + this.style.size*factorPaddingV);

        integral.metrics.offsetX_aux = displaceX;
        // integral position
        Object.defineProperties(integral.metrics, {
          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return thisFormula.metrics.offsetX +thisFormula.metrics.paddingX +this.marginX +this.offsetX_aux; } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY; } },
        });

        //////////////////////////////////
        // w=529, h=1000
        descartesJS.auxCtx.font = children_i.style.toString();
        var tmpMetric = getFontMetrics(descartesJS.auxCtx.font);

        var integralHeight = parseInt(tmpMetric.h*1.2);
        var integralWidth = parseInt(10.5 +integralHeight*529/1000);
        integral.sign = {
          w : integralWidth,
          h : integralHeight,
          scale : integralHeight/1000,
        };

        integral.sign.parent = integral;
        Object.defineProperties(integral.sign, {
          "x" : { get: function() { return this.parent.metrics.offsetX + this.parent.metrics.paddingX; } },
          "y" : { get: function() { return thisFormula.metrics.offsetY +tmpMetric.descent -(this.h +tmpMetric.h)/2; } },
        });

        var newBaselineTo = tmpMetric.descent -(integralHeight + tmpMetric.h)/2 -integralTo.metrics.descent +integralHeight/3;

        // integralTo position
        Object.defineProperties(integralTo.metrics, {
          "parent" : { value : integral },
          "integralWidth" : { value : integralWidth },
          "newBaselineTo" : { value : newBaselineTo },

          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return this.parent.metrics.offsetX + this.parent.metrics.paddingX +parseInt(4*this.integralWidth/5); } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY + this.newBaselineTo; } },
        });

        var newBaselineFrom = tmpMetric.descent +integralFrom.metrics.ascent/2;

        // integralFrom position
        Object.defineProperties(integralFrom.metrics, {
          "parent" : { value : integral },
          "integralWidth" : { value : integralWidth },
          "newBaselineFrom" : { value : newBaselineFrom },

          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return this.parent.metrics.offsetX + this.parent.metrics.paddingX +parseInt(2*this.integralWidth/5); } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY + this.newBaselineFrom; } },
        });

        var whatDisplace = Math.max( parseInt(4*integralWidth/5) + integralTo.metrics.w, parseInt(2*integralWidth/5 + integralFrom.metrics.w) ) +integral.metrics.paddingX;

        // integralWhat position
        Object.defineProperties(integralWhat.metrics, {
          "parent" : { value : integral },
          "whatDisplace" : { value : whatDisplace },

          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return this.parent.metrics.offsetX + this.parent.metrics.paddingX +this.whatDisplace; } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY; } },
        });

        integral.metrics.w = whatDisplace + integralWhat.metrics.w +2*integral.metrics.paddingX;
        integral.metrics.ascent = Math.max( integralWhat.metrics.ascent, (-newBaselineTo +integralTo.metrics.ascent) ) +integral.metrics.paddingY;
        integral.metrics.descent = Math.max( integralWhat.metrics.descent, (newBaselineFrom +integralFrom.metrics.descent), integralHeight -integral.metrics.ascent ) +integral.metrics.paddingY;
        integral.metrics.h = Math.max(integral.metrics.ascent + integral.metrics.descent, integralHeight);

        displaceX += 2*integral.metrics.marginX;
      }

      //////////////////////////////////////////////////////////
      else if (children_i.nodeType === "limit") {
        var limit = children_i;

        limit.updateFormula();

        var components = limit.children;
        var limitFrom = components[0];
        var limitTo = components[1];
        var limitWhat = components[2];

        limit.metrics.marginX = parseInt(1.5 + this.style.size*factorMarginH);
        limit.metrics.paddingX = parseInt(1.5 + this.style.size*factorPaddingH);
        limit.metrics.paddingY = parseInt(1.5 + this.style.size*factorPaddingV);

        limit.metrics.offsetX_aux = displaceX;
        // limit position
        Object.defineProperties(limit.metrics, {
          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return thisFormula.metrics.offsetX +thisFormula.metrics.paddingX +this.marginX +this.offsetX_aux; } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY; } },
        });

        //////////////////////////////////
        descartesJS.auxCtx.font = children_i.style.toString();
        var tmpMetric = getFontMetrics(descartesJS.auxCtx.font);
        var limitTextWidth = parseInt(0.5 + descartesJS.auxCtx.measureText("lím").width);
        var arrowWidth = parseInt(0.5 + descartesJS.auxCtx.measureText("→").width);

        limitWidth = Math.max(limitTextWidth, limitFrom.metrics.w + arrowWidth + limitTo.metrics.w);

        limit.limitText = {
          parent: limit,
        };
        Object.defineProperties(limit.limitText, {
          "limitWidth" : { value : limitWidth },
          "limitTextWidth" : { value : limitTextWidth },

          "x" : { get : function() { return this.parent.metrics.offsetX + this.parent.metrics.paddingX + (this.limitWidth - this.limitTextWidth)/2 } },
        });

        var newBaseline = tmpMetric.descent +Math.max(limitFrom.metrics.ascent, limitTo.metrics.ascent, 2*tmpMetric.ascent/3) +limit.metrics.paddingY;

        limit.limitArrow = {
          parent: limit,
        };
        Object.defineProperties(limit.limitArrow, {
          "newBaseline" : { value : newBaseline },

          "x" : { get : function() { return this.parent.metrics.offsetX + this.parent.metrics.paddingX +limitFrom.metrics.w} },
          "y" : { get : function() { return thisFormula.metrics.offsetY + this.newBaseline; } },
        });

        // limitFrom position
        Object.defineProperties(limitFrom.metrics, {
          "parent" : { value : limit },
          "newBaseline" : { value : newBaseline },

          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return this.parent.metrics.offsetX + this.parent.metrics.paddingX; } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY + this.newBaseline; } },
        });

        // limitTo position
        Object.defineProperties(limitTo.metrics, {
          "parent" : { value : limit },
          "arrowWidth" : { value : arrowWidth },
          "newBaseline" : { value : newBaseline },

          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },
          
          "offsetX" : { get : function() { return this.parent.metrics.offsetX + this.parent.metrics.paddingX + limitFrom.metrics.w + this.arrowWidth; } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY + this.newBaseline; } },
        });

        // limitWhat position
        Object.defineProperties(limitWhat.metrics, {
          "parent" : { value : limit },
          "limitWidth" : { value : limitWidth },

          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },
          
          "offsetX" : { get : function() { return this.parent.metrics.offsetX + 2*this.parent.metrics.paddingX + this.limitWidth; } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY; } },
        });

        limit.metrics.w = limitWidth + limitWhat.metrics.w +3*limit.metrics.paddingX;
        limit.metrics.ascent = Math.max(limitWhat.metrics.ascent, tmpMetric.ascent) +limit.metrics.paddingY;
        limit.metrics.descent = newBaseline + Math.max(limitFrom.metrics.descent, limitTo.metrics.descent) +limit.metrics.paddingY;
        limit.metrics.h = limit.metrics.ascent + limit.metrics.descent;

        displaceX += 2*limit.metrics.marginX;
      }

      //////////////////////////////////////////////////////////
      else if (children_i.nodeType === "matrix") {
        var matrix = children_i;

        matrix.updateFormula();
        
        var components = matrix.children;
        var rows = matrix.rows;
        var cols = matrix.columns;

        matrix.metrics.marginX = parseInt(1.5 + this.style.size*factorMarginH);
        matrix.metrics.paddingX = parseInt(1.5 + this.style.size*factorPaddingH);
        matrix.metrics.paddingY = parseInt(1.5 + this.style.size*factorPaddingV);

        matrix.metrics.offsetX_aux = displaceX;
        // matrix position
        Object.defineProperties(matrix.metrics, {
          "x" : { get : function() { return this.offsetX; } },
          "y" : { get : function() { return this.offsetY; } },

          "offsetX" : { get : function() { return thisFormula.metrics.offsetX +thisFormula.metrics.paddingX +this.marginX +this.offsetX_aux; } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY; } },
        });
        
        //////////////////////////////////
        descartesJS.auxCtx.font = children_i.style.toString();
        var tmpMetric = getFontMetrics(descartesJS.auxCtx.font);

        var rowsH = [];
        var colsW = [];

        var index_row;
        var index_col;

        // get the max height of the rows and the max width of the columns
        for (var j=0, k=rows*cols; j<k; j++) {
          index_row = parseInt(j/cols);
          index_col = j % cols;
          
          rowsH[index_row] = Math.max(rowsH[index_row] || 0, components[j].metrics.h);

          colsW[index_col] = Math.max(colsW[index_col] || 0, components[j].metrics.w);
        }

        var matrixW = (1+cols)*matrix.metrics.paddingX;
        for (var j=0; j<cols; j++) { matrixW += colsW[j]; };

        var matrixH = (1+rows)*matrix.metrics.paddingY;
        for (var j=0; j<rows; j++) { matrixH += rowsH[j]; };
        
        var dispY = tmpMetric.descent - tmpMetric.h/2;

        for (var j=0, k=rows*cols; j<k; j++) {
          index_row = parseInt(j/cols);
          index_col = j % cols;

          components[j].metrics.offsetX_aux = partialSum(colsW, index_col) + (colsW[index_col] - components[j].metrics.w)/2 +index_col*matrix.metrics.paddingX;
          components[j].metrics.offsetY_aux = partialSum(rowsH, index_row) + (rowsH[index_row] - components[j].metrics.h)/2 +(1+index_row)*matrix.metrics.paddingY;

          Object.defineProperties(components[j].metrics, {
            "parent" : { value : matrix },
            "matrixH" : { value : matrixH },
            "dispY" : { value : dispY },

            "x" : { get : function() { return this.offsetX; } },
            "y" : { get : function() { return this.offsetY; } },

            "offsetX" : { get : function() { return this.parent.metrics.offsetX + this.parent.metrics.paddingX + this.offsetX_aux; } },
            "offsetY" : { get : function() { return thisFormula.metrics.offsetY - this.matrixH/2 + this.ascent + this.offsetY_aux + this.dispY; } },
          });
        }

        matrix.metrics.w = matrixW ;
        matrix.metrics.ascent = matrixH/2 -dispY;
        matrix.metrics.descent = matrixH/2 +dispY;
        matrix.metrics.h = matrix.metrics.ascent + matrix.metrics.descent;

        displaceX += 2*matrix.metrics.marginX;
      }
      
      //////////////////////////////////////////////////////////
      else if (children_i.nodeType === "defparts") {
        var defparts = children_i;

        defparts.updateFormula();

        var components = children_i.children;
        var parts = children_i.parts;

        defparts.metrics.marginX = parseInt(1.5 + this.style.size*factorMarginH);
        defparts.metrics.paddingX = parseInt(1.5 + this.style.size*factorPaddingH);
        defparts.metrics.paddingY = parseInt(1.5 + this.style.size*factorPaddingV);

        defparts.metrics.offsetX_aux = displaceX;
        // defparts position
        Object.defineProperties(defparts.metrics, {
          "parent" : { value : thisFormula },

          "x" : { get : function() { return this.offsetX -2*this.marginX; } },
          "y" : { get : function() { return this.offsetY; } },
          
          "offsetX" : { get : function() { return thisFormula.metrics.offsetX +thisFormula.metrics.paddingX +3*this.marginX +this.offsetX_aux; } },
          "offsetY" : { get : function() { return thisFormula.metrics.offsetY; } },
        });

        //////////////////////////////////
        descartesJS.auxCtx.font = children_i.style.toString();
        var tmpMetric = getFontMetrics(descartesJS.auxCtx.font);

        var defpartsW = 0;
        var defpartsH = defparts.metrics.paddingY;
        var dispY = tmpMetric.descent - tmpMetric.h/2;

        for (var j=0; j<parts; j++) {
          components[j].metrics.offsetY_aux = defpartsH;

          defpartsW = Math.max(defpartsW, components[j].metrics.w);
          defpartsH += components[j].metrics.h +defparts.metrics.paddingY;
          
          Object.defineProperties(components[j].metrics, {
            "parent" : { value : defparts },
            "dispY" : { value : dispY },

            "x" : { get : function() { return this.offsetX; } },
            "y" : { get : function() { return this.offsetY; } },
            
            "offsetX" : { get : function() { return this.parent.metrics.offsetX + this.parent.metrics.paddingX; } },
            "offsetY" : { get : function() { return thisFormula.metrics.offsetY - this.parent.metrics.defpartsH/2 +this.ascent +this.offsetY_aux + this.dispY; } },
          });
        }
        defparts.metrics.defpartsH = defpartsH;

        defparts.metrics.w = defpartsW +4*defparts.metrics.paddingX;
        defparts.metrics.ascent = defpartsH/2 -dispY;
        defparts.metrics.descent = defpartsH/2 +dispY;
        defparts.metrics.h = defparts.metrics.ascent + defparts.metrics.descent;

        displaceX += 2*defparts.metrics.marginX;
      }

      //////////////////////////////////////////////////////////
      else if ( 
        (children_i.nodeType === "numerator") || 
        (children_i.nodeType === "denominator") ||
        (children_i.nodeType === "index") ||
        (children_i.nodeType === "radicand") ||
        (children_i.nodeType === "from") ||
        (children_i.nodeType === "to") ||
        (children_i.nodeType === "what") ||
        (children_i.nodeType === "element")
      ) {
        children_i.updateFormula();

        children_i.metrics.paddingX = parseInt(1.5 + this.style.size*factorPaddingH);
        children_i.metrics.paddingY = parseInt(1.5 + this.style.size*factorPaddingV);

        children_i.metrics.w += 2*children_i.metrics.paddingX;
        children_i.metrics.ascent += children_i.metrics.paddingY;
        children_i.metrics.descent += children_i.metrics.paddingY;
        children_i.metrics.h = children_i.metrics.ascent + children_i.metrics.descent;
      }

      //////////////////////////////////////////////////////////
      // asign the previous child
      prevChild = children_i;

      //////////////////////////////////////////////////////////
      this.metrics.ascent = Math.max(this.metrics.ascent, children_i.metrics.ascent);
      this.metrics.descent = Math.max(this.metrics.descent, children_i.metrics.descent);

      this.metrics.w += children_i.metrics.w +2*children_i.metrics.marginX;
      this.metrics.h = this.metrics.ascent + this.metrics.descent;
      displaceX += children_i.metrics.w;
    }
  }

  /**
   * 
   */
  descartesJS.TextNode.prototype.justifyAux = function(width) {
    // count the space children
    var spaces = 0;
    var textWidth = 0;
    for (var i=0, l=this.children.length; i<l-1; i++) {
      if (this.children[i].nodeType === "space") {
        spaces++;
      }
      else {
        textWidth += this.children[i].metrics.w;
      }
    }
    // var spaceWidth = parseInt((width - textWidth)/spaces);
    var spaceWidth = (width - textWidth)/spaces;
    this.updateLine(spaceWidth);
  }

  /**
   * 
   */
  descartesJS.TextNode.prototype.drawTextBlock = function(ctx) {
    ctx.fillStyle = externalColor;

    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].draw(ctx);
    }
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawTextLineBlock = function(ctx) {
    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].draw(ctx);
    }
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawText = function(ctx) {
    if (this.value === "") return;

    var x = this.metrics.x;
    var y = this.metrics.y;

    ctx.fillStyle = (this.style.color !== null) ? ((this.style.color.getColor) ? this.style.color.getColor() : this.style.color) : externalColor;

    ctx.font = this.style.toString();

    ctx.beginPath();

    if (this.style.overline) {
      ctx.rect(x, y -this.metrics.ascent +parseInt(1 +this.style.size/25), this.metrics.w, parseInt(1 +this.style.size/25) );
      ctx.fill();
    }
    if (this.style.underline) {
      ctx.rect(x, y +parseInt(1 +this.style.size/10), this.metrics.w, parseInt(1 +this.style.size/25) );
      ctx.fill();
    }
    if (this.style.border) {
      var tmpStroke = ctx.strokeStyle;
      ctx.lineWidth = 1 + parseInt(this.style.size/13);
      ctx.lineJoin = "round";
      ctx.miterLimit = 2;
      ctx.strokeStyle = this.style.border.getColor();
      ctx.strokeText(this.value, x, y);
      ctx.strokeStyle = tmpStroke;
    }

    ctx.fillText(this.value, x, y);

    // drawBorder
    // ctx.beginPath();
    // ctx.strokeStyle = "#ff0000";
    // ctx.lineWidth = 1;
    // ctx.rect(parseInt(this.metrics.x) +0.5, parseInt(this.metrics.y -this.metrics.ascent) +0.5, this.metrics.w, this.metrics.h);
    // ctx.stroke();

    // ctx.beginPath();
    // ctx.strokeStyle = "#0000ff";
    // ctx.lineWidth = 1;
    // ctx.moveTo(parseInt(this.metrics.x), parseInt(this.metrics.y));
    // ctx.lineTo(parseInt(this.metrics.x + this.metrics.w), parseInt(this.metrics.y));
    // ctx.stroke();

  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawWord = function(ctx) {
    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].draw(ctx);
    }
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawSpace = function(ctx) { }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawDynamicText = function(ctx) {
    var x = this.metrics.x +this.metrics.paddingX;
    var y = this.metrics.y;

    ctx.fillStyle = (this.style.color !== null) ? ((this.style.color.getColor) ? this.style.color.getColor() : this.style.color) : externalColor;
    ctx.font = this.style.toString();

    ctx.beginPath();

    if (this.style.overline) {
      ctx.rect(x, y -this.metrics.ascent +parseInt(1 +this.style.size/25), this.metrics.w, parseInt(1 +this.style.size/25) );
      ctx.fill();
    }
    if (this.style.underline) {
      ctx.rect(x, y +parseInt(1 +this.style.size/10), this.metrics.w, parseInt(1 +this.style.size/25) );
      ctx.fill();
    }

    ctx.fillText(this.evalValue, x, y);

    this.drawBorder(ctx, "blue");
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawHyperlink = function(ctx) {
    var x = this.metrics.x;
    var y = this.metrics.y;

    this.ctx = ctx;
    // add a position to the click cacher div
    if (!this.clickCacher.parentNode) {
      // ctx.canvas.parentNode.appendChild(this.clickCacher);
      if (ctx.canvas.nextSibling.className) {
        ctx.canvas.parentNode.insertBefore(this.clickCacher, ctx.canvas.nextSibling.nextSibling);
      }
      else {
        ctx.canvas.parentNode.insertBefore(this.clickCacher, ctx.canvas.nextSibling);
      }
    }
    this.clickCacher.style.left = x + "px";
    this.clickCacher.style.top  = (y - this.metrics.ascent) + "px";

    ctx.fillStyle = "blue";

    if (this.click) {
      // cover the previous text when click
      ctx.fillStyle = "white";
      ctx.fillRect(x, y -this.metrics.ascent, this.metrics.w, this.metrics.h);

      ctx.fillStyle = "red";
    }

    ctx.font = this.style.toString();

    ctx.beginPath();
    ctx.rect(x, y +parseInt(1 +this.style.size/10), this.metrics.w, parseInt(1 +this.style.size/25) );
    ctx.fill();

    ctx.fillText(this.value, x, y);
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawFormula = function(ctx) {
    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].draw(ctx);
    }
    
    this.drawBorder(ctx, "blue");
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawFraction = function(ctx) {
    // ctx.lineWidth = 6;
    ctx.lineWidth = 5;
    ctx.fillStyle = (this.style.color !== null) ? ((this.style.color.getColor) ? this.style.color.getColor() : this.style.color) : externalColor;
    ctx.beginPath();
    var hSeg = parseInt(1 +this.style.size/24);
    ctx.rect(this.metrics.x, this.metrics.offsetY -parseInt(hSeg/2), this.metrics.w, hSeg);
    ctx.fill();

    this.children[0].draw(ctx);
    this.children[1].draw(ctx);

    this.drawBorder(ctx, "blue");
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawNumDen = function(ctx) {
    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].draw(ctx);
    }

    this.drawBorder(ctx, "blue");
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawSuperIndex = function(ctx) {
    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].draw(ctx);
    }

    this.drawBorder(ctx, "blue");
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawSubIndex = function(ctx) {
    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].draw(ctx);
    }

    this.drawBorder(ctx, "blue");
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawRadical = function(ctx) {
    ctx.save();
    ctx.translate(this.radicalSign.x, this.radicalSign.y);
    ctx.scale(this.radicalSign.scaleX, this.radicalSign.scaleY);
    (descartesJS.isMsEdge) ? this.drawRadicalSign(ctx) : ctx.fill(radicalPath);
    ctx.restore();

    ctx.beginPath();
    ctx.fillRect(this.children[1].metrics.x+2.5, this.radicalSign.y -0.5, this.children[1].metrics.w -1.5, parseInt(1+this.style.size/18));

    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].draw(ctx);
    }

    this.drawBorder(ctx, "blue");
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawSum = function(ctx) {
    ctx.save();
    ctx.translate(this.sigmaSign.x, this.sigmaSign.y);
    ctx.scale(this.sigmaSign.scale, this.sigmaSign.scale);
    (descartesJS.isMsEdge) ? this.drawSigmaSign(ctx) : ctx.fill(sigmaPath);
    ctx.restore();

    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].draw(ctx);
    }

    this.drawBorder(ctx, "blue");
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawIntegral = function(ctx) {
    ctx.save();
    ctx.translate(this.sign.x, this.sign.y);
    ctx.scale(this.sign.scale, this.sign.scale);
    (descartesJS.isMsEdge) ? this.drawIntegralSign(ctx) : ctx.fill(integralPath);
    ctx.restore();

    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].draw(ctx);
    }

    this.drawBorder(ctx, "blue");
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawLimit = function(ctx) {
    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].draw(ctx);
    }

    ctx.fillStyle = (this.style.color !== null) ? ((this.style.color.getColor) ? this.style.color.getColor() : this.style.color) : externalColor;

    ctx.font = this.style.toString();

    ctx.fillText("lím", this.limitText.x, this.metrics.y);
    ctx.fillText("→", this.limitArrow.x, this.limitArrow.y);

    this.drawBorder(ctx, "blue");
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawMatrix = function(ctx) {
    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].draw(ctx);
    }

    var w = parseInt(1.5 + this.style.size/25);
    var w_2 = w/2;
    ctx.lineWidth = w;
    ctx.strokeStyle = (this.style.color !== null) ? ((this.style.color.getColor) ? this.style.color.getColor() : this.style.color) : externalColor;

    ctx.beginPath();

    ctx.moveTo(this.metrics.x +w_2 +1.5*this.metrics.marginX, this.metrics.y +w_2 -this.metrics.ascent);
    ctx.lineTo(this.metrics.x +w_2, this.metrics.y +w_2 -this.metrics.ascent);
    ctx.lineTo(this.metrics.x +w_2, this.metrics.y -w_2 -this.metrics.ascent +this.metrics.h);
    ctx.lineTo(this.metrics.x +w_2 +1.5*this.metrics.marginX, this.metrics.y -w_2 -this.metrics.ascent +this.metrics.h);

    ctx.moveTo(this.metrics.x +this.metrics.w -w_2 -1.5*this.metrics.marginX, this.metrics.y +w_2 -this.metrics.ascent);
    ctx.lineTo(this.metrics.x +this.metrics.w -w_2, this.metrics.y +w_2 -this.metrics.ascent);
    ctx.lineTo(this.metrics.x +this.metrics.w -w_2, this.metrics.y +w_2 -this.metrics.ascent +this.metrics.h);
    ctx.lineTo(this.metrics.x +this.metrics.w -w_2 -1.5*this.metrics.marginX, this.metrics.y +w_2 -this.metrics.ascent +this.metrics.h);

    ctx.stroke();

    this.drawBorder(ctx, "blue");
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawDefparts = function(ctx) {
    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].draw(ctx);
    }

    var w = parseInt(1.5 + this.style.size/25);
    var w_2 = w/2;
    ctx.lineWidth = w;
    ctx.strokeStyle = (this.style.color !== null) ? ((this.style.color.getColor) ? this.style.color.getColor() : this.style.color) : externalColor;
    ctx.beginPath();

    var x1 = 3*this.metrics.marginX;
    var x2 = x1/2;

    ctx.moveTo(this.metrics.x +w_2 +x1, this.metrics.y +w_2 -this.metrics.ascent);
    ctx.bezierCurveTo(
      this.metrics.x +w_2 +x2, this.metrics.y +w_2 -this.metrics.ascent, 
      this.metrics.x +w_2 +x2, this.metrics.y +w_2 -this.metrics.ascent,
      this.metrics.x +w_2 +x2, this.metrics.y +w_2 -this.metrics.ascent +2*this.metrics.marginX
    );
    ctx.lineTo(this.metrics.x +w_2 +x2, this.metrics.y +w_2 -this.metrics.ascent +this.metrics.h/2 -5*this.metrics.marginX);
    ctx.bezierCurveTo(
      this.metrics.x +w_2 +x2, this.metrics.y +w_2 -this.metrics.ascent +this.metrics.h/2,
      this.metrics.x +w_2 +x2, this.metrics.y +w_2 -this.metrics.ascent +this.metrics.h/2,
      this.metrics.x +w_2, this.metrics.y +w_2 -this.metrics.ascent +this.metrics.h/2
    );
    ctx.bezierCurveTo(
      this.metrics.x +w_2 +x2, this.metrics.y +w_2 -this.metrics.ascent +this.metrics.h/2,
      this.metrics.x +w_2 +x2, this.metrics.y +w_2 -this.metrics.ascent +this.metrics.h/2,
      this.metrics.x +w_2 +x2, this.metrics.y +w_2 -this.metrics.ascent +this.metrics.h/2 +5*this.metrics.marginX
    );
    ctx.lineTo(this.metrics.x +w_2 +x2, this.metrics.y +w_2 -this.metrics.ascent +this.metrics.h -2*this.metrics.marginX);
    ctx.bezierCurveTo(
      this.metrics.x +w_2 +x2, this.metrics.y -w_2 -this.metrics.ascent +this.metrics.h,
      this.metrics.x +w_2 +x2, this.metrics.y -w_2 -this.metrics.ascent +this.metrics.h,
      this.metrics.x +w_2 +x1, this.metrics.y -w_2 -this.metrics.ascent +this.metrics.h
    );
    
    ctx.stroke();

    this.drawBorder(ctx, "blue");
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawGenericBlock = function(ctx) {
    for (var i=0, l=this.children.length; i<l; i++) {
      this.children[i].draw(ctx);
    }

    this.drawBorder(ctx, "blue");
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawComponentNumCtrl = function(ctx) {
    this.componentNumCtrl.expresion = this.evaluator.parser.parse("(" + this.metrics.x + "," + (this.metrics.y-this.metrics.ascent) + "," + this.componentNumCtrl.w + "," + this.componentNumCtrl.h + ")");
    if ( (this.componentNumCtrl) && (this.componentNumCtrl.parent) && (this.componentNumCtrl.parent.readyApp) ) {
      this.componentNumCtrl.update(true);
    }
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawComponentSpace = function(ctx) {
    this.componentSpace.xExpr = this.evaluator.parser.parse(this.metrics.x.toString());
    this.componentSpace.yExpr = this.evaluator.parser.parse((this.metrics.y-this.metrics.ascent).toString());
    if ( (this.componentSpace) && (this.componentSpace.parent) && (this.componentSpace.parent.readyApp) ) {
      this.componentSpace.update(true);
    }
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawRadicalSign = function(ctx) {
    ctx.strokeStyle = 'rgba(0,0,0,0)';
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
    ctx.miterLimit = 4;
    ctx.beginPath();
    ctx.moveTo(759,1);
    ctx.bezierCurveTo(751,1,744,5,739,15);
    ctx.lineTo(325,878);
    ctx.lineTo(153,500);
    ctx.bezierCurveTo(148,489,142,486,136,491);
    ctx.lineTo(2,596);
    ctx.bezierCurveTo(-3,600,19,626,24,622);
    ctx.lineTo(89,575);
    ctx.lineTo(282,997);
    ctx.bezierCurveTo(285,1003,309,1003,314,993);
    ctx.lineTo(773,40);
    ctx.lineTo(773,1);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawSigmaSign = function(ctx) {
    ctx.strokeStyle = 'rgba(0,0,0,0)';
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
    ctx.miterLimit = 4;
    ctx.beginPath();
    ctx.moveTo(780,707);
    ctx.lineTo(750,707);
    ctx.bezierCurveTo(728,805,695,872,585,872);
    ctx.lineTo(180,872);
    ctx.lineTo(509,447);
    ctx.lineTo(225,65);
    ctx.lineTo(538,65);
    ctx.bezierCurveTo(668,65,705,114,726,246);
    ctx.lineTo(756,246);
    ctx.lineTo(756,0);
    ctx.lineTo(25,0);
    ctx.lineTo(384,500);
    ctx.lineTo(0,1000);
    ctx.lineTo(729,1000);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.drawIntegralSign = function(ctx) {
    ctx.strokeStyle = 'rgba(0,0,0,0)';
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
    ctx.miterLimit = 4;
    ctx.beginPath();
    ctx.moveTo(150,828);
    ctx.bezierCurveTo(129,916,108,972,67,972);
    ctx.bezierCurveTo(61,972,58,970,58,966);
    ctx.bezierCurveTo(58,957,73,958,73,932);
    ctx.bezierCurveTo(73,918,60,910,46,910);
    ctx.bezierCurveTo(22,910,1,932,1,961);
    ctx.bezierCurveTo(1,981,22,1000,57,1000);
    ctx.bezierCurveTo(154,1000,198,895,216,824);
    ctx.lineTo(375,181);
    ctx.bezierCurveTo(398,90,420,27,464,28);
    ctx.bezierCurveTo(470,28,473,30,473,34);
    ctx.bezierCurveTo(473,41,458,47,458,69);
    ctx.bezierCurveTo(458,83,471,89,485,89);
    ctx.bezierCurveTo(509,89,530,67,530,38);
    ctx.bezierCurveTo(530,18,508,0,473,0);
    ctx.bezierCurveTo(368,0,326,120,309,190);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  /**
   * 
   */
  descartesJS.TextNode.prototype.drawBorderSpecial = function(ctx, color) {
    ctx.beginPath();
    ctx.setLineDash([1,2]);
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.rect(parseInt(this.metrics.x) +0.5, parseInt(this.metrics.y -this.metrics.ascent) +0.5, this.metrics.w, this.metrics.h);
    ctx.stroke();
    ctx.setLineDash([]);
  }


  /**
   * 
   */
  descartesJS.TextNode.prototype.toRTF = function() {
    var fontTable = [];
    var colorTable = [];

    var children_i;
    var output = "";

    this.mergeTextNodes();

    for (var i=0, l=this.children.length; i<l; i++) {
      children_i = this.children[i];

      if (children_i.nodeType === "textLineBlock") {
        output += children_i.toRTFAux(fontTable, colorTable) + (((l>1)&&(i<l-1))? "\\par" : "");
      }
    }

    var fontTableStr = "{\\fonttbl";
    for (var i=0, l=fontTable.length; i<l; i++) {
      fontTableStr += "\\f" + i + "\\fcharset0 " + fontTable[i] + ";";
    }
    fontTableStr += "}";

    var colorTableStr = "";
    if (colorTable.length > 0) {
      colorTableStr = "{\\colortbl";
      for (var i=0, l=colorTable.length; i<l; i++) {
        colorTableStr += colorTable[i];
      }
      colorTableStr += "}";
    }

    output = "{\\rtf1\\uc0" + fontTableStr + colorTableStr + output + "}";

    return output;
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.toRTFAux = function(fontTable, colorTable) {
    var children_i;
    var lastFontFamily;
    var lastFontSize;
    var lastColor = null;

    var output = "";
    var open;
    var close;
    var tmpFontFamily;
    var tmpFontSize;
    var tmpColor;

    var tmpRTF;

    for (var i=0, l=this.children.length; i<l; i++) {
      open = close = "";

      children_i = this.children[i];

      tmpFontFamily = this.addToFontTable(children_i.style.family, fontTable);
      tmpFontSize = children_i.style.size;
      tmpColor = this.addToColorTable(children_i.style.color, colorTable);

      if ((tmpColor === null) && (colorTable.length > 0)) {
        tmpColor = this.addToColorTable(externalColor, colorTable);
      }

      if (tmpColor !== lastColor) {
        open += "\\cf" + tmpColor;
        lastColor = tmpColor;
      }

      if (tmpFontFamily !== lastFontFamily) {
        open += "\\f" + tmpFontFamily;
        lastFontFamily = tmpFontFamily;
      }
      if (tmpFontSize !== lastFontSize) {
        open += "\\fs" + (tmpFontSize*2);
        lastFontSize = tmpFontSize;
      }

      if (children_i.style.italic) {
        open += "\\i";
        close = "\\i0" + close;
      }
      if (children_i.style.bold) {
        open += "\\b";
        close = "\\b0" + close;
      }
      if (children_i.style.underline) {
        open += "\\ul";
        close = "\\ulnone" + close;
      }
      if (children_i.style.overline) {
        open += "\\ol";
        close = "\\olnone" + close;
      }

      if (children_i.nodeType === "text") {
        children_i.value = children_i.value.replace(/\\{/g, "{").replace(/\\}/g, "}").replace(/{/g, "\\{").replace(/}/g, "\\}");

        if (open !== "") {
          tmpRTF = open + " " + children_i.value + close;
        }
        else {
          if ((output !== "") && (output.charAt(output.length-1) !== "}")) {
            tmpRTF = " " + children_i.value;
          }
          else {
            tmpRTF = children_i.value;
          }
        }

        output += tmpRTF;
      }
      else if (children_i.nodeType === "formula") {
        output += "{\\*\\mjaformula" + children_i.formulaToRTF(lastFontFamily, lastFontSize, lastColor, fontTable, colorTable) + "}";
      }

      else if (children_i.nodeType === "componentSpace") {
        output += "{\\*\\component\\Space " + children_i.value + "}";
      }
      else if (children_i.nodeType === "componentNumCtrl") {
        output += "{\\*\\component\\NumCtrl " + children_i.value + "}";
      }
    }

    return output;
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.formulaToRTF = function(lastFontFamily, lastFontSize, lastColor, fontTable, colorTable) {
    var children_i;

    var output = "";
    var open;
    var close;
    var tmpFontFamily;
    var tmpFontSize;
    var tmpColor;

    for (var i=0, l=this.children.length; i<l; i++) {
      open = close = "";

      children_i = this.children[i];

      tmpFontFamily = this.addToFontTable(children_i.style.family, fontTable);
      tmpColor = this.addToColorTable(children_i.style.color, colorTable);

      if ((tmpColor === null) && (colorTable.length > 0)) {
        tmpColor = this.addToColorTable(externalColor, colorTable);
      }

      if (tmpFontFamily !== lastFontFamily) {
        open += "\\f" + tmpFontFamily;
        lastFontFamily = tmpFontFamily;
      }
      if (tmpColor !== lastColor) {
        open += "\\cf" + tmpColor;

        // change the lastColor value if the node is not a text node with empty text
        if ((children_i.nodeType !== "text") || ((children_i.nodeType === "text") && (children_i.value !== ""))) {
          lastColor = tmpColor;
        }
      }

      if (children_i.style.italic) {
        open += "\\i";
        close = "\\i0" + close;
      }
      if (children_i.style.bold) {
        open += "\\b";
        close = "\\b0" + close;
      }
      if (children_i.style.underline) {
        open += "\\ul";
        close = "\\ulnone" + close;
      }
      if (children_i.style.overline) {
        open += "\\ol";
        close = "\\olnone" + close;
      }

      if ((children_i.nodeType === "text") && (children_i.value !== "")) {
        children_i.value = children_i.value.replace(/\\{/g, "{").replace(/\\}/g, "}").replace(/{/g, "\\{").replace(/}/g, "\\}");
        if (open !== "") {
          tmpRTF = open + " " + children_i.value + close;
        }
        else {
          if (output.charAt(output.length-1) !== "}") {
            tmpRTF = " " + children_i.value;
          }
          else {
            tmpRTF = children_i.value;
          }
        }

        output += tmpRTF;
      }
      else if (children_i.nodeType === "dynamicText") {
        children_i.value = (children_i.value === "") ? " " : children_i.value;
        output += open + "{\\expr" + " " + children_i.value + "\\decimals " + (children_i.decimals || 2) + "\\fixed" + ((children_i.fixed) ? 1 : 0) + "}" + close;
      }
      else if (
        (children_i.nodeType === "fraction") ||
        (children_i.nodeType === "radical") ||
        (children_i.nodeType === "index") ||
        (children_i.nodeType === "radicand") ||
        (children_i.nodeType === "sum") ||
        (children_i.nodeType === "integral") ||
        (children_i.nodeType === "limit") ||
        (children_i.nodeType === "from") ||
        (children_i.nodeType === "to") ||
        (children_i.nodeType === "what") ||
        (children_i.nodeType === "element")
      ) {
        output += "{\\" + children_i.nodeType + children_i.formulaToRTF(lastFontFamily, lastFontSize, lastColor, fontTable, colorTable) + "}";
      }
      else if (children_i.nodeType === "numerator") {
        output += "{\\num" + children_i.formulaToRTF(lastFontFamily, lastFontSize, lastColor, fontTable, colorTable) + "}";
      }
      else if (children_i.nodeType === "denominator") {
        output += "{\\den" + children_i.formulaToRTF(lastFontFamily, lastFontSize, lastColor, fontTable, colorTable) + "}";
      }
      else if (children_i.nodeType === "superIndex") {
        output += "{\\supix" + children_i.formulaToRTF(lastFontFamily, lastFontSize, lastColor, fontTable, colorTable) + "}";
      }
      else if (children_i.nodeType === "subIndex") {
        output += "{\\subix" + children_i.formulaToRTF(lastFontFamily, lastFontSize, lastColor, fontTable, colorTable) + "}";
      }
      else if (children_i.nodeType === "matrix") {
        output += "{\\matrix\\rows "+ (children_i.rows || 2) +"\\columns "+ (children_i.columns || 2) + children_i.formulaToRTF(lastFontFamily, lastFontSize, lastColor, fontTable, colorTable) + "}";
      }
      else if (children_i.nodeType === "defparts") {
        output += "{\\defparts\\parts "+ (children_i.parts || 2) + children_i.formulaToRTF(lastFontFamily, lastFontSize, lastColor, fontTable, colorTable) + "}";
      }
      
// console.log(children_i.nodeType, children_i, open + children_i.value + close)
    }

    return output;
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.addToFontTable = function(fontType, fontTable) {
    var family;

    if (fontType.match(/times/i)) {
      family = "Times New Roman";
    }
    else if (fontType.match(/courier/i)) {
      family = "Courier New";
    }
    else if (fontType.match(/arial/i)) {
      family = "Arial";
    }

    var indexFamily = fontTable.indexOf(family);
    if (indexFamily === -1) {
      indexFamily = fontTable.length;
      fontTable.push(family);
    }

    return indexFamily;
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.addToColorTable = function(textColor, colorTable) {
    if (textColor) {
      var color = "\\red" + parseInt(textColor.substring(1, 3), 16) + "\\green" + parseInt(textColor.substring(3, 5), 16) + "\\blue" + parseInt(textColor.substring(5,7), 16) + ";";

      var colorIndex = colorTable.indexOf(color);
      if (colorIndex === -1) {
        colorIndex = colorTable.length;
        colorTable.push(color);
      }
  
      return colorIndex;
    }
    return null;
  }
  /**
   * 
   */
  descartesJS.TextNode.prototype.mergeTextNodes = function() {
    var deleteChild = [];
    var lastNode = null;
    for (var i=0, l=this.children.length; i<l; i++) {
      if (this.children[i].nodeType === "text") {
        if ((lastNode !== null) && (lastNode.nodeType === "text")) {
          if (lastNode.style.equals(this.children[i].style)) {
            this.children[i].value = lastNode.value + this.children[i].value;
            deleteChild.push(lastNode);
          }
        }
      }
      else {
        this.children[i].mergeTextNodes();
      }

      lastNode = this.children[i];
    }

    for (var i=0, l=deleteChild.length; i<l; i++) {
      this.removeChild(deleteChild[i]);
    }
  }



  function partialSum(array, index) {
    var result = 0;
    for (var i=0; i<index; i++) {
      result += array[i];
    }
    return result;
  }


  var fontMetrics = {
    "sansserif" : {
      ascent: 1854,
      descent: -434,
      lineGap: 67,
      capHeight: 1409,
      xHeight: 1082,
      unitsPerEm: 2048
    },
    "serif" : {
      ascent: 1825,
      descent: -443,
      lineGap: 87,
      capHeight: 1341,
      xHeight: 940,
      unitsPerEm: 2048
    },
    "monospace" : {
      ascent: 1705,
      descent: -615,
      lineGap: 0,
      capHeight: 1349,
      xHeight: 1082,
      unitsPerEm: 2048
    }
  };

  // https://www.freetype.org/freetype2/docs/glyphs/glyphs-3.html/

  function getFontMetrics(font) {
    // var result = { ascent:0, descent:0, lineGap:0, capHeight:0, xHeight:0, unitsPerEm:0, h:0 };
    var result = { ascent:0, descent:0, h:0, w:0, x:0, y:0, offsetX:0, offsetY:0, marginX:0, marginY:0, paddingX:0, paddingY:0 };

    if (font.trim() == "") {
      return result;
    }

    var fontSize = parseInt( font .match(/(\d+\.*)+px/)[0] );
    var fontName = (font.match("sansserif")) ? "sansserif" : ((font.match("serif")) ? "serif" : "monospace");

    // result.lineGap = fontMetrics[fontName].lineGap * fontSize / fontMetrics[fontName].unitsPerEm;

    result.ascent = Math.ceil( (fontMetrics[fontName].ascent+25) * fontSize / fontMetrics[fontName].unitsPerEm );

    result.descent = Math.ceil( Math.abs( (fontMetrics[fontName].descent-25) * fontSize / fontMetrics[fontName].unitsPerEm ) );

    result.h = result.ascent + result.descent;

    // result.lineGap = Math.ceil( fontMetrics[fontName].lineGap * fontSize / fontMetrics[fontName].unitsPerEm );

    // result.capHeight = Math.ceil( fontMetrics[fontName].capHeight * fontSize / fontMetrics[fontName].unitsPerEm );

    // result.xHeight = Math.ceil( fontMetrics[fontName].xHeight * fontSize / fontMetrics[fontName].unitsPerEm );

    return result;
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var StringFromCharCode = String.fromCharCode;
  var inputLenght;
  var tokens;
  var tokenType;
  var tokenValue;
  var pos;
  var blockNumber;
  var currentChar;
  var nextChar;
  var insideControlWord;
  var lastTokenType;
  var tmpMatch;
  var tmpText;
  var spaceFlag;

  /**
   * A rtf tokenizer
   * @constructor
   */
  descartesJS.RTFTokenizer = function() { };

  /**
   * Get a rtf parse tree from an input
   * @param {String} input the rtf text to tokenize
   */
  descartesJS.RTFTokenizer.prototype.tokenize = function(input) {
    if (input) {
      input = input.replace(/\&gt;/g, ">")
                   .replace(/\&lt;/g, "<")
                   .replace(/\&quote;/g, "''")
                   .replace(/\&squot;/g, "'")
                   .replace(/\\rquote /g, "'")
                   .replace(/\\endash /g, "-")
                   .replace(/\n/g, " ")
                   .replace(/\r/g, "")
                   .replace(/\\uc(\d+) /g, "")
                   .replace(/\\uc(\d+)/g, "");
    }
    else {
      return [];
    }

    inputLenght = input.length;
    tokens = [];
    tokenValue = "";
    pos = 0;
    blockNumber = 0;
    nextChar = input.charAt(0);
    insideControlWord = false;
    lastTokenType = "text";

    while (pos < inputLenght) {
      currentChar = nextChar;
      nextChar = input.charAt(pos+1);

      // outside a controlWord, maybe a text or init of the input
      if (!insideControlWord) {
        // found a controlWord
        if (currentChar === "\\") {
          insideControlWord = true;

          // save a text node if readed
          if (tokenValue !== "") {
            tokens.push({ type: "text", value: tokenValue });
            lastTokenType = "text";
            tokenValue = "";
          }
        }
        // open block
        else if (currentChar === "{") {
          blockNumber++;

          // save a text node if readed
          if (tokenValue !== "") {
            tokens.push({ type: "text", value: tokenValue });
            tokenValue = "";
          }

          tokens.push({ type: "openBlock", value: blockNumber });
          lastTokenType = "openBlock";
        }
        // close block
        else if (currentChar === "}") {
          // save a text node if readed
          if (tokenValue !== "") {
            tokens.push({ type: "text", value: tokenValue })
            tokenValue = "";
          }

          tokens.push({ type: "closeBlock", value: blockNumber });
          lastTokenType = "closeBlock";
          blockNumber--;
        }
        // control word
        else {
          tokenValue += currentChar;
        }
      }

      // inside a controlWord
      else {
        if ((nextChar === "\\") || (nextChar === "{") || (nextChar === "}") || (nextChar === " ") || (nextChar === ";")) {
          insideControlWord = false;
          tokenValue += currentChar;

          // if the controlWord has a space
          if (nextChar === " ") {
            pos++;
            nextChar = input.charAt(pos+1);
            spaceFlag = true;
          }
          else {
            spaceFlag = false;
          }

          // controlWord of the form \'##
          tmpMatch = tokenValue.match(/^\'([0-9a-f]{2})/);
          if (tmpMatch) {
            tmpText = "";
            if (lastTokenType === "text") {
              tmpText = tokens.pop().value;
            }

            tmpText += StringFromCharCode(parseInt(tmpMatch[1], 16)) + tokenValue.substring(3);

            tokenValue = tmpText;
          }
          else {
            // controlWord of the form \u###
            tmpMatch = tokenValue.match(/^u[0-9]+/);
            if (tmpMatch) {
              tmpText = "";
              if (lastTokenType === "text") {
                tmpText = tokens.pop().value;
              }

              tmpText += StringFromCharCode(tmpMatch[0].substring(1));

              tokenValue = tmpText;
            }
            // generic controlWord
            else {
              // escaped characters
              if ((tokenValue === "{") || (tokenValue === "}") || (currentChar == "\\")) {
                tokens.push({ type: "text", value: tokenValue +((spaceFlag)? " " : "") });
                lastTokenType = "text";
              }
              else {
                tokens.push({ type: "controlWord", value: tokenValue });
                lastTokenType = "controlWord";
              }

              tokenValue = "";
            }
          }
        }
        // escaped characters
        else if ((currentChar == "{") || (currentChar == "}") || (currentChar == "\\")) {
          insideControlWord = false;
          tokens.push({ type: "text", value: currentChar });
          lastTokenType = "text";
        }
        else {
          tokenValue += currentChar;
        }
      }

      pos++;
    }

    // if the last text token is not added
    if (tokenValue !== "") {
      tokens.push({ type: "text", value: tokenValue })
    }

    return tokens;
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var mathMax = Math.max;

  var tokens;
  var indexToken;
  var fontTable;
  var openBlockIndex;
  var tempI;
  var colorTable;
  var colorTableIndex;
  var r;
  var g;
  var b;
  var newNode;
  var lastNode;
  var lastDynamicNode;
  var lastMatrixNode;
  var lastPartsNode;
  var descartesFormula;
  var dynamicText;
  var setDecimals;
  var setRows;
  var setColumns;
  var setParts;
  var currentBlock;
  var styleStack;
  var styleStackTop;
  var blockNum;
  var formulaBlock;
  var formulaStack;
  var descartesComponentNumCtrl;
  var descartesComponentSpace;
  var descartesHyperLink;
  var rootNode;

  /**
   * Descartes RTF parser
   * @constructor
   */
  descartesJS.RTFParser = function(evaluator) {
    this.evaluator = evaluator;
    this.tokenizer = new descartesJS.RTFTokenizer();
  }

  /**
   * Parse a string and get a rtf parse tree
   * @param {String} input the input string to parse
   * @param {RTFNode} return a parse tree corresponding to the rtf input
   */
  descartesJS.RTFParser.prototype.parse = function(input) {
// console.log(input);
    tokens = this.tokenizer.tokenize(input);
    // tokens = checkMathSymboslInFormula(tokens);
    indexToken = 0;
    fontTable = {};
    tempI = 2;
// console.log(tokens);

    // build the font block
    if ( (tokens[0].type === "openBlock") && (tokens[1].value === "fonttbl") ) {
      openBlockIndex = tokens[0].value;

      while ( ((tokens[tempI].type !== "closeBlock") && (tokens[tempI].value !== openBlockIndex)) ) {
        fontTable[tokens[tempI].value] = (tokens[tempI+2].value).substring(0, (tokens[tempI+2].value).length-1);
        tempI = tempI + 3;
      }

      tempI++;
    }

    colorTable = {};
    colorTableIndex = 0;

    // build the color block
    if ( (tokens[tempI].type === "openBlock") && (tokens[tempI+1].value === "colortbl") ) {
      openBlockIndex = tokens[tempI++].value;

      tempI++;

      while ( ((tokens[tempI].type !== "closeBlock") && (tokens[tempI].value !== openBlockIndex)) ) {
        // \red###\green###\blue###;
        r = parseInt(tokens[tempI++].value.substring(3)).toString(16);
        g = parseInt(tokens[tempI++].value.substring(5)).toString(16);
        b = parseInt(tokens[tempI++].value.substring(4)).toString(16);

        // colors separator
        if (tokens[tempI].value === ";") {
          tempI++;
        }

        // #rrggbb
        colorTable[colorTableIndex++] = "#" + ((r.length < 2)? "0"+r : r) + ((g.length < 2)? "0"+g : g) + ((b.length < 2)? "0"+b : b);
      }

      tempI++;
    }

    lastDynamicNode = null;
    lastMatrixNode = null;
    lastPartsNode = null;
    descartesFormula = false;
    dynamicText = false;
    setDecimals = false;
    setRows = false;
    setColumns = false;
    setParts = false;
    currentBlock = [];
    styleStack = [ new descartesJS.TextStyle() ];
    styleStackTop = styleStack[0];

    blockNum = -1;
    formulaBlock = -1;
    formulaStack = [];

    // arquimedes rft components
    descartesComponentNumCtrl = false;
    descartesComponentSpace = false;
    descartesHyperLink = false;

    // initial nodes
    newNode = rootNode =  new descartesJS.TextNode("", "textBlock", styleStackTop, this.evaluator); // root
    lastNode = new descartesJS.TextNode("", "textLineBlock", styleStackTop, this.evaluator); // first line
    newNode.addChild(lastNode);
    rootNode.stableWidth = true;
    rootNode.hasFormula = false;

    // build the nodes
    for (var i=tempI, l=tokens.length; i<l; i++) {
      ////////////////////////////////////////////////////
      // controlWord elements
      ////////////////////////////////////////////////////
      if (tokens[i].type == "controlWord") {
        // font type
        if (fontTable[tokens[i].value]) {
          styleStackTop.set({ family: fontTable[tokens[i].value] });
        }

        // font size
        else if (tokens[i].value.match(/^fs(\d+)/)) {
          styleStackTop.set({ size: parseInt(((tokens[i].value.match(/^fs(\d+)/))[1])/2) });
        }

        // init bold text
        else if (tokens[i].value == "b") {
          styleStackTop.set({ bold: true });
          if (formulaStack.length > 0) {
            formulaStack[formulaStack.length-1].style.set({ bold: true });
          }
        }

        // end bold text
        else if (tokens[i].value == "b0") {
          styleStackTop.set({ bold: false });
          if (formulaStack.length > 0) {
            formulaStack[formulaStack.length-1].style.set({ bold: false });
          }
        }

        // init italic text
        else if (tokens[i].value == "i") {
          styleStackTop.set({ italic: true });
          if (formulaStack.length > 0) {
            formulaStack[formulaStack.length-1].style.set({ italic: true });
          }
        }

        // end italic text
        else if (tokens[i].value == "i0") {
          styleStackTop.set({ italic: false });
          if (formulaStack.length > 0) {
            formulaStack[formulaStack.length-1].style.set({ italic: false });
          }
        }

        // init underline text
        else if (tokens[i].value == "ul") {
          styleStackTop.set({ underline: true });
          if (formulaStack.length > 0) {
            formulaStack[formulaStack.length-1].style.set({ underline: true });
          }
        }

        // end underline text
        else if (tokens[i].value == "ulnone") {
          styleStackTop.set({ underline: false });
          if (formulaStack.length > 0) {
            formulaStack[formulaStack.length-1].style.set({ underline: false });
          }
        }

        // init overline text
        else if (tokens[i].value == "ol") {
          styleStackTop.set({ overline: true });
          if (formulaStack.length > 0) {
            formulaStack[formulaStack.length-1].style.set({ overline: true });
          }
        }

        // end overline text
        else if (tokens[i].value == "olnone") {
          styleStackTop.set({ overline: false });
          if (formulaStack.length > 0) {
            formulaStack[formulaStack.length-1].style.set({ overline: false });
          }
        }

        // color text
        else if (tokens[i].value.match(/^cf(\d+)/)) {
          styleStackTop.set({ color: colorTable[parseInt(tokens[i].value.substring(2))] });
          if (formulaStack.length > 0) {
            formulaStack[formulaStack.length-1].style.color = styleStackTop.color;
          }
        }

        // a new line
        else if (tokens[i].value == "par") {
          // is not necesary to add the new line node, because a new textLineBlock is added
          // lastNode.addChild( new descartesJS.TextNode("", "newLine", styleStackTop.clone()) );

          newNode = new descartesJS.TextNode("", "textLineBlock", styleStackTop.clone(), this.evaluator);

          // find a textBlock to add the new line
          if (lastNode.nodeType != "textBlock") {
            lastNode = lastNode.parent;

            while (lastNode.nodeType != "textBlock") {
              lastNode = lastNode.parent;
            }
          }

          lastNode.addChild(newNode);
          lastNode = newNode;
        }

        // descartes formula
        else if (tokens[i].value == "mjaformula") {
          rootNode.hasFormula = true;
          formulaBlock = blockNum;
          descartesFormula = true;

          newNode = new descartesJS.TextNode("", "formula", styleStackTop.clone(), this.evaluator);
          lastNode.addChild(newNode);
          lastNode = newNode;

          formulaStack[formulaStack.length-1] = newNode;
        }

        // fraction, sum, integral and limit
        else if ((tokens[i].value == "fraction") ||
                 (tokens[i].value == "radicand") ||
                 (tokens[i].value == "radical") ||
                 (tokens[i].value == "what") ||
                 (tokens[i].value == "sum") ||
                 (tokens[i].value == "integral") ||
                 (tokens[i].value == "limit")
                ) {
          var tmpStyle = formulaStack[formulaStack.length-2].style.clone();

          newNode = new descartesJS.TextNode("",  tokens[i].value, tmpStyle, this.evaluator);

          // add the new node to the element previous to the top, because the top contains the new element to add
          formulaStack[formulaStack.length-2].addChild(newNode);

          // the new element is the stack top
          formulaStack[formulaStack.length-1] = newNode;
        }

        // root index
        else if (tokens[i].value == "index") {
          var tmpStyle = formulaStack[formulaStack.length-2].style.clone();

          // the size of the font can not be less than 8
          tmpStyle.size = mathMax( parseInt(tmpStyle.size - tmpStyle.size*0.5), 8 );

          newNode = new descartesJS.TextNode("", tokens[i].value, tmpStyle, this.evaluator);

          // add the new node to the element previous to the top, because the top contains the new element to add
          formulaStack[formulaStack.length-2].addChild(newNode);

          // the new element is the stack top
          formulaStack[formulaStack.length-1] = newNode;
        }

        // limits of sum and integral
        else if (
          (tokens[i].value == "to") ||
          (tokens[i].value == "from") 
        ) {
          var tmpStyle = formulaStack[formulaStack.length-2].style.clone();

          // the size of the font can not be less than 8
          tmpStyle.size = mathMax( parseInt(tmpStyle.size - tmpStyle.size*0.2), 8 );

          newNode = new descartesJS.TextNode("", tokens[i].value, tmpStyle, this.evaluator);

          // add the new node to the element previous to the top, because the top contains the new element to add
          formulaStack[formulaStack.length-2].addChild(newNode);

          // the new element is the stack top
          formulaStack[formulaStack.length-1] = newNode;
        }

        // numerator or denominator of a fraction
        else if ((tokens[i].value == "num") || (tokens[i].value == "den")) {
          var tmpStyle = formulaStack[formulaStack.length-2].style.clone();

          // the size of the font can not be less than 8
          tmpStyle.size = mathMax( Math.round(tmpStyle.size - tmpStyle.size*0.1), 8 );

          if (tokens[i].value == "num") {
            newNode = new descartesJS.TextNode("", "numerator", tmpStyle, this.evaluator);
          }
          else if (tokens[i].value == "den") {
            newNode = new descartesJS.TextNode("", "denominator", tmpStyle, this.evaluator);
          }

          // add the new node to the element previous to the top, because the top contains the new element to add
          formulaStack[formulaStack.length-2].addChild(newNode);

          // the new element is the stack top
          formulaStack[formulaStack.length-1] = newNode;
        }

        // subindex or superindex
        else if ((tokens[i].value == "subix") || (tokens[i].value == "supix")) {
          var tmpStyle = formulaStack[formulaStack.length-2].style.clone();

          // the size of the font can not be less than 8
          tmpStyle.size = mathMax( Math.floor(tmpStyle.size - tmpStyle.size*0.33), 8 );

          if (tokens[i].value == "subix") {
            newNode = new descartesJS.TextNode("", "subIndex", tmpStyle, this.evaluator);
          }
          else if (tokens[i].value == "supix") {
            newNode = new descartesJS.TextNode("", "superIndex", tmpStyle, this.evaluator);
          }

          newNode.originalStyle = formulaStack[formulaStack.length-2].style.clone();

          // add the new node to the element previous to the top, because the top contains the new element to add
          formulaStack[formulaStack.length-2].addChild(newNode);

          // the new element is the stack top
          formulaStack[formulaStack.length-1] = newNode;
        }

        // defparts, a matrix or an element
        else if ( (tokens[i].value == "defparts") || (tokens[i].value == "matrix") || (tokens[i].value == "element") ) {
          var tmpStyle = formulaStack[formulaStack.length-2].style.clone();

          newNode = new descartesJS.TextNode("", tokens[i].value, tmpStyle, this.evaluator);

          // add the new node to the element previous to the top, because the top contains the new element to add
          formulaStack[formulaStack.length-2].addChild(newNode);

          // the new element is the stack top
          formulaStack[formulaStack.length-1] = newNode;

          if (tokens[i].value == "defparts") {
            lastPartsNode = newNode;
          }
          else if (tokens[i].value == "matrix") {
            lastMatrixNode = newNode;
          }
        }

        // number of parts
        else if (tokens[i].value == "parts") {
          setParts = true;
        }

        // number of rows
        else if (tokens[i].value == "rows") {
          setRows = true;
        }

        // number of columns
        else if (tokens[i].value == "columns") {
          setColumns = true;
        }

        // dynamic text
        else if (tokens[i].value == "expr") {
          rootNode.stableWidth = false;
          dynamicText = true;
        }

        // number of decimals in the text
        else if (tokens[i].value == "decimals") {
          setDecimals = true;
        }

        // fixed representation activated
        else if (tokens[i].value == "fixed1") {
          lastDynamicNode.fixed = true;
        }

        // fixed representation desactivated
        else if (tokens[i].value == "fixed0") {
          lastDynamicNode.fixed = false;
        }

        // a component
        else if (tokens[i].value == "component") { }

        // a control component
        else if (tokens[i].value == "NumCtrl") {
          descartesComponentNumCtrl = true;
        }

        // a space component
        else if (tokens[i].value == "Space") {
          descartesComponentSpace = true;
        }

        // hyperlink
        else if (tokens[i].value == "hyperlink") {
          descartesHyperLink = true;
        }
      }

      ////////////////////////////////////////////////////
      // text elements
      ////////////////////////////////////////////////////
      if (tokens[i].type == "text") {
        // set the number of parts
        if (setParts) {
          lastPartsNode.parts = (parseInt(tokens[i].value));
          setParts = false;
        }

        // set the number of rows
        else if (setRows) {
          lastMatrixNode.rows = (parseInt(tokens[i].value));
          setRows = false;
        }

        // set the number of columns
        else if (setColumns) {
          lastMatrixNode.columns = (parseInt(tokens[i].value));
          setColumns = false;
        }

        // set the number of decimals
        else if (setDecimals) {
          // lastDynamicNode.decimals = tokens[i].value;
          lastDynamicNode.decimals = this.evaluator.parser.parse( tokens[i].value +"");
          setDecimals = false;
        }

        // hyperlink content
        else if (descartesHyperLink) {
          textContent = ((tokens[i].value).split("|"))[0];
          tmpStyle = styleStackTop.clone();

          newNode = new descartesJS.TextNode(textContent, "hyperlink", tmpStyle, this.evaluator);
          newNode.URL = ((tokens[i].value).split("|"))[1];

          if (lastNode.nodeType != "textLineBlock") {
            lastNode = lastNode.parent;

            while (lastNode.nodeType != "textLineBlock") {
              lastNode = lastNode.parent;
            }
          }

          lastNode.addChild(newNode);

          descartesHyperLink = false;
        }

        // a control component content
        else if (descartesComponentNumCtrl) {
          newNode = new descartesJS.TextNode(tokens[i].value, "componentNumCtrl", styleStackTop.clone(), this.evaluator);

          lastNode.addChild(newNode);

          descartesComponentNumCtrl = false;
        }

        // a space component content
        else if (descartesComponentSpace) {
          newNode = new descartesJS.TextNode(tokens[i].value, "componentSpace", styleStackTop.clone(), this.evaluator);

          lastNode.addChild(newNode);

          descartesComponentSpace = false;
        }

        // dynamic text content
        else if (dynamicText) {
          var tmpStyle = formulaStack[formulaStack.length-2].style.clone();

          // textContent = tokens[i].value;
          textContent = this.evaluator.parser.parse(tokens[i].value);

          newNode = new descartesJS.TextNode(textContent, "dynamicText", tmpStyle, this.evaluator);

          // add the new node to the element previous to the top, because the top contains the new element to add
          formulaStack[formulaStack.length-2].addChild(newNode);

          // the new element is the stack top
          formulaStack[formulaStack.length-1] = newNode;

          // save the reference to the last dynamic node, to asign the number of decimals and the fixed representation
          lastDynamicNode = newNode;

          dynamicText = false;
        }

        // no formula text
        else if ((!dynamicText) && (!descartesFormula)) {
          textContent = tokens[i].value;

          newNode = new descartesJS.TextNode(textContent, "text", styleStackTop.clone(), this.evaluator);

          if (lastNode.nodeType != "textLineBlock") {
            lastNode = lastNode.parent;

            while (lastNode.nodeType != "textLineBlock") {
              lastNode = lastNode.parent;
            }
          }

          lastNode.addChild(newNode);
        }

        // formula text
        else if ((!dynamicText) && (descartesFormula)) {
          textContent = tokens[i].value;

          newNode = new descartesJS.TextNode(textContent, "text", formulaStack[formulaStack.length-1].style.clone(), this.evaluator);

          // add the new node to the top of the formulas stack
          formulaStack[formulaStack.length-1].addChild(newNode);
        }
      }

      ////////////////////////////////////////////////////
      // other elements
      ////////////////////////////////////////////////////

      // init a rtf block, expression or formula
      else if (tokens[i].type == "openBlock") {
        blockNum = tokens[i].value;

        styleStackTop = styleStackTop.clone();
        styleStack.push(styleStackTop);

        formulaStack.push(null);
      }

      // close a rtf block, expression or formulas
      else if (tokens[i].type == "closeBlock") {
        if (tokens[i].value == formulaBlock) {
          formulaBlock = -1;
          descartesFormula = false;
          lastNode = lastNode.parent;
        }

        styleStack.pop();
        styleStackTop = styleStack[styleStack.length-1];

        formulaStack.pop();
      }

      // mathematical symbols parentheses
      else if ( (tokens[i].type == "(") || (tokens[i].type == ")") ) {
        var tmpStyle = formulaStack[formulaStack.length-1].style.clone();
        tmpStyle.italic = "";

        newNode = new descartesJS.TextNode(tokens[i].type, "mathSymbol", tmpStyle, this.evaluator);

        // add the new node to the top of the formulas stack
        formulaStack[formulaStack.length-1].addChild(newNode);
      }

      // mathematical symbols +, -, *,  =
      else if ( (tokens[i].type == "+") || (tokens[i].type == "-") || (tokens[i].type == "*") || (tokens[i].type == "=") ) {
        newNode = new descartesJS.TextNode(tokens[i].type, "mathSymbol", formulaStack[formulaStack.length-1].style.clone(), this.evaluator);

        // add the new node to the top of the formulas stack
        formulaStack[formulaStack.length-1].addChild(newNode);
      }

      // unknown elements
      else {
//         console.log("Desconocido ", tokens[i]);
      }
    }

    return rootNode.normalize();
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathFloor = Math.floor;
  var parent;
  var evaluator;
  var parser;
  var thisID;
  var newH;
  var newW;
  var parentH;
  var parentW;
  var temp;
  var OxExpr;
  var OyExpr;

  var tmpContainer;
  var boundingRect;
  var tmpDisplay;
  var containerClass;
  var pos;

  /**
   * Descartes space
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the graphic
   */
  descartesJS.Space = function(parent, values) {
    var self = this;
    /**
     * Descartes application
     * type {DescartesApp}
     * @private
     */
    self.parent = parent;

    /**
     * object for parse and evaluate expressions
     * type {Evaluator}
     * @private
     */
    self.evaluator = self.parent.evaluator;

    evaluator = self.evaluator;
    parser = evaluator.parser;

    /**
     * identifier
     * type {String}
     */
    self.id = "";

    /**
     * initial values
     * type {String}
     * @private
     */
    self.values = values;

    /**
     * type
     * type {String}
     * @private
     */
    self.type = "R2";

    /**
     * x position
     * type {Node}
     * @private
     */
    self.xExpr = parser.parse("0");

    /**
     * y position
     * type {Node}
     * @private
     */
    self.yExpr = parser.parse("0");

    /**
     * width
     * type {Number}
     * @private
     */
    self.w = parseInt(parent.container.width);

    /**
     * height
     * type {Number}
     * @private
     */
    self.h = parseInt(parent.container.height);

    /**
     * drawif condition
     * type {Node}
     * @private
     */
    self.drawif = parser.parse("1");

    /**
     * fixed space condition
     * type {Boolean}
     * @private
     */
    self.fixed = (parent.version === 2);

    /**
     * scale
     * type {Number}
     * @private
     */
    self.scale = 48;

    /**
     * displacement x of the origin
     * type {Number}
     * @private
     */
    self.Ox = 0;

    /**
     * displacement y of the origin
     * type {Number}
     * @private
     */
    self.Oy = 0;

    /**
     * background image
     * type {Image}
     * @private
     */
    self.image = new Image();
    self.image.onload = function() {
      this.ready = 1;
    }

    /**
     * background image file name
     * type {String}
     * @private
     */
    self.imageSrc = "";

    /**
     * how the background image is positioned
     * type {String}
     * @private
     */
    self.bg_display = "topleft";

    /**
     * background color
     * type {String}
     * @private
     */
    self.background = new descartesJS.Color( ((/DescartesJS.class/i).test(parent.code) || (parent.arquimedes)) ? "f0f8fa" : "ffffff" );

    /**
     * net condition and color
     * type {String}
     * @private
     */
    self.net = (parent.version != 2) ? new descartesJS.Color("c0c0c0") : "";

    /**
     * net 10 condition and color
     * type {String}
     * @private
     */
    self.net10 = (parent.version != 2) ? new descartesJS.Color("808080") : "";

    /**
     * axes condition and color
     * type {String}
     * @private
     */
    self.axes = (parent.version != 2) ? new descartesJS.Color("808080") : "";

    /**
     * coordinate text condition and color
     * type {String}
     * @private
     */
    self.text = new descartesJS.Color("ffafaf");

    /**
     * condition to draw the axis numbers
     * type {Boolean}
     * @private
     */
    self.numbers = false;

    /**
     * x axis text
     * type {String}
     * @private
     */
    self.x_axis = (parent.version != 2) ? "" : " ";

    /**
     * y axis text
     * type {String}
     * @private
     */
    self.y_axis = self.x_axis;

    /**
     * sensitive to mose movements condition
     * type {Boolean}
     * @private
     */
    self.sensitive_to_mouse_movements = false;

    /**
     * component identifier (rtf text positioning)
     * type {String}
     * @private
     */
    self.cID = ""

    /**
     * mouse x position
     * type {Number}
     * @private
     */
    self.mouse_x = 0;

    /**
     * mouse y position
     * type {Number}
     * @private
     */
    self.mouse_y = 0;

    /**
     * the controls
     * type {Array<Controls>}
     * @private
     */
    self.ctrs = [];

    /**
     * the graphic controls
     * type {Array<Controls>}
     * @private
     */
    self.graphicsCtr = [];

    /**
     * the graphics
     * type {Array<Graphics>}
     * @private
     */
    self.graphics = [];

    /**
     * the background graphics
     * type {Array<Graphics>}
     * @private
     */
    self.backGraphics = [];

    /**
     * z index of the elements
     * @type {Number}
     * @private
     */
    self.zIndex = parent.zIndex;

    self.plecaHeight = parent.plecaHeight || 0;
    self.displaceRegionNorth = parent.displaceRegionNorth || 0;
    self.displaceRegionWest = parent.displaceRegionWest || 0;

    // traverse the values to replace the defaults values of the object
    for (var propName in values) {
      // verify the own properties of the object
      if (values.hasOwnProperty(propName)) {
        self[propName] = values[propName];
      }
    }

    // self.init();
    self.initSpace();
  }

  /**
   * Init the values of the space
   */
  descartesJS.Space.prototype.initSpace = function() {
    var self = this;

    parent = self.parent;
    evaluator = self.evaluator;
    thisID = self.id;

    if (!self.resizable) {
      self.displaceRegionNorth = parent.displaceRegionNorth || 0;
      self.displaceRegionSouth = parent.displaceRegionSouth || 0;
      self.displaceRegionEast = parent.displaceRegionEast || 0;
      self.displaceRegionWest = parent.displaceRegionWest || 0;

      parentW = parseInt(parent.container.width);
      parentH = parseInt(parent.container.height);

      // percentage dimensions
      if (self.wExpr != undefined) {
        self.w = parseInt(parentW - self.displaceRegionWest - self.displaceRegionEast)*parseFloat(self.wExpr)/100;
      }
      if (self.hExpr != undefined) {
        self.h = parseInt(parentH - self.displaceRegionNorth - self.displaceRegionSouth)*parseFloat(self.hExpr)/100;
      }

      // get the x and y position
      if (self.xPercentExpr != undefined) {
        self.xExpr = evaluator.parser.parse((parseInt(parentW - self.displaceRegionWest - this.displaceRegionEast)*parseFloat(self.xPercentExpr)/100).toString());
      }
      if (self.yPercentExpr != undefined) {
        self.yExpr = evaluator.parser.parse((parseInt(parentH - self.displaceRegionNorth - self.displaceRegionSouth)*parseFloat(self.yPercentExpr)/100).toString());
      }

      self.x = evaluator.eval(self.xExpr) + self.displaceRegionWest;
      self.y = evaluator.eval(self.yExpr) + self.plecaHeight + self.displaceRegionNorth;

      // if the container exist then modify it's x and y position
      if (self.container) {
        self.container.style.left = self.x + "px";
        self.container.style.top  = self.y + "px";
      }

      if (self.y >= 0) {
        newH = parentH - self.y;
        if (self.h > newH) {
          self.h = newH;
        }
      } 
      else {
        newH = self.h + self.y;
        self.h = (newH >= parentH) ? parentH : newH;
      }

      if (self.x >= 0) {
        newW = parentW - self.x;
        if (self.w > newW) {
          self.w = newW;
        }
      } 
      else {
        newW = self.w + self.x;
        self.w = (newW >= parentW) ? parentW : newW;
      }
    }

    // if the space has a background image then get the image from the loader
    if ( (self.imageSrc != "") || !(/vacio.gif$/i).test(self.imageSrc.trim()) ) {
      self.image = parent.getImage(self.imageSrc);
    }

    // Ox
    // if specified with a percentage
    if (self.OxExpr) {
      OxExpr = self.OxExpr;
      if (OxExpr[OxExpr.length-1] === "%") {
        self.Ox = self.w*parseFloat(OxExpr)/100;
      }
      // if not specified with a percentage
      else {
        temp = parseFloat(OxExpr);

        // whether to convert the value to a number the values ​​are different
        if (temp != OxExpr) {
          temp = 0;
        }
        self.Ox = temp;
      }
    }

    // Oy
    // if specified with a percentage
    if (self.OyExpr) {
      OyExpr = self.OyExpr;
      if (OyExpr[OyExpr.length-1] === "%") {
        self.Oy = self.h*parseFloat(OyExpr)/100;
      }
      // if not specified with a percentage
      else {
        temp = parseFloat(OyExpr);

        // whether to convert the value to a number the values ​​are different
        if (temp != OyExpr) {
          temp = 0;
        }
        self.Oy = temp;
      }
    }

    // register the space variables
    // ## Descartes 2 patch ## //
    if ((self.id !== "") && (parent.version !== 2)) {
      evaluator.setVariable(thisID + "._w", self.w);
      evaluator.setVariable(thisID + "._h", self.h);
      evaluator.setVariable(thisID + ".escala", self.scale);
      evaluator.setVariable(thisID + ".Ox", self.Ox);
      evaluator.setVariable(thisID + ".Oy", self.Oy);
      evaluator.setVariable(thisID + ".mouse_x", 0);
      evaluator.setVariable(thisID + ".mouse_y", 0);
      evaluator.setVariable(thisID + ".mouse_pressed", 0);
      evaluator.setVariable(thisID + ".mouse_clicked", 0);
      evaluator.setVariable(thisID + ".clic_izquierdo", 0);
    }
    else {
      temp = evaluator.getVariable("_w");
      if (temp === undefined) { temp = self.w; };
      evaluator.setVariable("_w", temp);

      temp = evaluator.getVariable("_h");
      if (temp === undefined) { temp = self.h; };
      evaluator.setVariable("_h", temp);

      temp = evaluator.getVariable("escala");
      if (temp === undefined) { temp = self.scale; };
      evaluator.setVariable("escala", temp);

      temp = evaluator.getVariable("Ox");
      if (temp === undefined) { temp = self.Ox; };
      evaluator.setVariable("Ox", temp);

      temp = evaluator.getVariable("Oy");
      if (temp === undefined) { temp = self.Oy; };
      evaluator.setVariable("Oy", temp);

      evaluator.setVariable("mouse_x", 0);
      evaluator.setVariable("mouse_y", 0);
      evaluator.setVariable("mouse_pressed", 0);
      evaluator.setVariable("mouse_clicked", 0);
      evaluator.setVariable("clic_izquierdo", 0);

      if ((parent.version == 2) && (self.x_axis === "") && (self.y_axis === "")) {
        self.axes = "";
      }
    }

    self.w_2 = self.w/2;
    self.h_2 = self.h/2;
  }

  /**
   * Add a control to the list of controls of the space
   * @param {Control} ctr is the control to add
   */
  descartesJS.Space.prototype.addCtr = function(ctr) {
    if (ctr.type === "graphic") {
      this.graphicsCtr.push(ctr);
    }
    else {
      this.ctrs.push(ctr);
    }
  }

  /**
   * Add a graphic to the list of graphics of the space
   * @param {Graphic} gra is the graphic to add
   */
  descartesJS.Space.prototype.addGraph = function(gra, is3D) {
    // add only graphs with the type of the space
    if ( ((this.type === "R2") && is3D) || ((this.type === "R3") && !is3D) ) {
      return;
    }

    if ((gra.background) && (this.type !== "R3")) {
      this.backGraphics.push(gra);
    }
    else {
      this.graphics.push(gra);
    }
  }

  /**
   * Change the click to 0
   */
  descartesJS.Space.prototype.clearClick = function() {
    this.evaluator.setVariable(this.mclickedString, 0);
    this.evaluator.setVariable(this.mclicizquierdoString, 0);
  }


  /**
   * Calculate the position relative to the X axis
   * @param {Number} x ths position
   * @return {Number} return the position relative to the X axis
   */
  descartesJS.Space.prototype.getRelativeX = function(x) {
    return ((x >> 0) - this.w_2 - this.Ox)/this.scale;
  }

  /**
   * Calculate the position relative to the Y axis
   * @param {Number} y ths position
   * @return {Number} return the position relative to the Y axis
   */
  descartesJS.Space.prototype.getRelativeY = function(y) {
    return (-(y >> 0) + this.h_2 + this.Oy)/this.scale;
  }

  /**
   * Calculate the position absolute respect to the canvas coordinate system
   * @param {Number} x ths position
   * @return {Number} return the position absolute to the X axis
   */
  descartesJS.Space.prototype.getAbsoluteX = function(x) {
    return (x*this.scale + this.w_2 + this.Ox);
  }

  /**
   * Calculate the position absolute respect to the canvas coordinate system
   * @param {Number} y ths position
   * @return {Number} return the position absolute to the Y axis
   */
  descartesJS.Space.prototype.getAbsoluteY = function(y) {
    return (-y*this.scale + this.h_2 + this.Oy);
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var self;

  /**
   * Descartes 2D space
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the graphic
   */
  descartesJS.SpaceExternal = function(parent) {
    self = this;
    self.parent = parent;

    self.width = 228;
    self.vSpace = 25;

    // create the principal container
    self.container = document.createElement("div");
    self.container.setAttribute("style", "box-sizing:border-box;border-style:ridge;border-width:5px;border-color:gray;box-shadow:#000 0 0 25px 5px;overflow-y:scroll;overflow-x:hidden;position:fixed;left:0;top:0;z-index:10000;width:" + (self.width +27) + "px;height:460px;background-color:#63b4fb");

    self.movable = document.createElement("div");
    self.movable.setAttribute("style", " position:absolute;left:0;top:0;width:" + (self.width +27) + "px;height:" + self.vSpace + "px;line-height:" + self.vSpace + "px;background-color:#ddd;cursor:move;padding-left:75px;font-family:Sans-Serif;font-size:18px;");
    self.movable.innerHTML = "Descartes";
    self.container.appendChild(self.movable);

    self.ctrs = [];
  }

  descartesJS.SpaceExternal.prototype.init = function() {
    document.body.appendChild(this.container);

    self = this;
    var parser = self.parent.evaluator.parser;
    var fontSizeDefaultButtons = "15";

    for (var i=0,l=self.ctrs.length; i<l; i++) {
      self.ctrs[i].expresion = parser.parse("(0," + (self.vSpace + 23 + i*35) + "," + (self.width) + ",35)");
      self.ctrs[i].update();
    }

    self.numCtr = l;

    // create the credits button
    var btnAbout = new descartesJS.Button(self.parent, { 
      region: "external",
      name: (self.language == "english") ? "about" : "cr\u00E9ditos",
      font_size: parser.parse(fontSizeDefaultButtons),
      expresion: parser.parse("(0," + self.vSpace + "," + (self.width/2) + ",25)")
    });
    btnAbout.actionExec = { execute: descartesJS.showAbout };
    btnAbout.update();

    // create the configuration button
    var btnConfig = new descartesJS.Button(self.parent, { 
      region: "external",
      name: "config",
      font_size: parser.parse(fontSizeDefaultButtons),
      action: "config",
      expresion: parser.parse("(" + (self.width/2) + "," + self.vSpace + "," + (self.width/2) + ",25)")
    });
    btnConfig.update();

    // create the init button
    var btnInit = new descartesJS.Button(self.parent, { 
      region: "external",
      name: (self.language == "english") ? "init" : "inicio",
      font_size: parser.parse(fontSizeDefaultButtons),
      action: "init",
      expresion: parser.parse("(0," + (self.vSpace + 23 + l*35) + "," + (self.width/2) + ",25)")
    });
    btnInit.update();

    // create the clear button
    var btnClear = new descartesJS.Button(self.parent, { 
      region: "external",
      name: (self.language == "english") ? "clear" : "limpiar",
      font_size: parser.parse(fontSizeDefaultButtons),
      action: "clear",
      expresion: parser.parse("(" + (self.width/2) + "," + (self.vSpace + 23 + l*35) + "," + (self.width/2) + ",25)")
    });
    btnClear.update();

    // create the clear button
    var btnClose = new descartesJS.Button(self.parent, { 
      region: "external",
      name: (self.language == "english") ? "close" : "cerrar",
      font_size: parser.parse(fontSizeDefaultButtons),
      expresion: parser.parse("(" + (self.width/4) + "," + (self.vSpace + 46 + l*35) + "," + (self.width/2) + ",25)")
    });
    btnClose.update();
    btnClose.btn.addEventListener("click", function(evt) {
      self.hide();
    });

    self.setPositionAndSize();

    // add the events for the movement
    /**
     *
     */
    function onMouseMove(evt) {
      self.newPos = descartesJS.getCursorPosition(evt, document.body);
      self.container.style.left = self.initialPosition.x + (self.newPos.x - self.oldPos.x)*descartesJS.cssScale + "px";
      self.container.style.top  = self.initialPosition.y + (self.newPos.y - self.oldPos.y)*descartesJS.cssScale + "px";
    }

    /**
     *
     */
    function onMouseUp(evt) {
      evt.preventDefault();

      document.body.removeEventListener("mousemove", onMouseMove);
      document.body.removeEventListener("mouseup", onMouseUp);
    }

    /**
     *
     */
    function onMouseDown(evt) {
      evt.preventDefault();

      self.oldPos = descartesJS.getCursorPosition(evt, document.body);
      self.initialPosition = { x: self.container.offsetLeft, y: self.container.offsetTop };

      document.body.addEventListener("mousemove", onMouseMove);
      document.body.addEventListener("mouseup", onMouseUp);
    }

    self.movable.addEventListener("mousedown", onMouseDown);

    self.hide();
  }

  /**
   * Add a control to the list of controls of the space
   * @param {Control} ctr is the control to add
   */
  descartesJS.SpaceExternal.prototype.addCtr = function(ctr) {
    this.ctrs.push(ctr);
  }

  /**
   *
   */
  descartesJS.SpaceExternal.prototype.show = function() {
    this.setPositionAndSize();
    this.container.style.display = "block";
  }

  /**
   *
   */
  descartesJS.SpaceExternal.prototype.hide = function() {
    this.container.style.display = "none";
  }

  /**
   *
   */
  descartesJS.SpaceExternal.prototype.setPositionAndSize = function() {
    self = this;
    var newHeight = self.vSpace + 46 + self.numCtr*35 + 25 + 10;

    self.container.style.left = Math.max((parseInt(window.innerWidth - self.width)/2), 0) + "px";
    self.container.style.top = "5px";

    // minimun space
    if (window.innerHeight < (self.vSpace + 75)) {
      self.container.style.height = (self.vSpace + 75) + "px";
    }
    else if (newHeight > (window.innerHeight-10)) {
      self.container.style.height = window.innerHeight-10;
    }
    else {
      self.container.style.height = newHeight + "px";
    }
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathFloor = Math.floor;
  var MathRound = Math.round;
  var PI2 = Math.PI*2;
  var minScale = 0.000001;
  var maxScale = 1000000;

  var axisFont = descartesJS.convertFont("SansSerif,PLAIN,12");
  var mouseTextFont = descartesJS.convertFont("Monospaced,PLAIN,12");

  var elapsedTime = 10;

  var self;

  var evaluator;
  var parent;
  var ctx;

  var changeX;
  var changeY;
  var thisGraphics_i;
  var thisCtrs_i;

  var rsc;
  var dec;
  var wh_temp;

  var w;
  var h;
  var x;
  var y;
  var Ox;
  var Oy;
  var x1;
  var x2;
  var y1;
  var y2;

  var coordTxt_X;
  var coordTxt_Y;
  var coordTxt;
  var coordTxtW;
  var mouseX;
  var mouseY;
  var posX;
  var posY;

  var disp;

  var wModExpr;
  var hModExpr;

  /**
   * Descartes 2D space
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the graphic
   */
  descartesJS.Space2D = function(parent, values) {
    // call the parent constructor
    descartesJS.Space.call(this, parent, values);

    self = this;

    self.ratio = parent.ratio;

    // create the canvas
    self.canvas = document.createElement("canvas");
    self.canvas.setAttribute("id", self.id + "_canvas");
    self.canvas.setAttribute("class", "DescartesSpace2DCanvas");

    self.backCanvas = document.createElement("canvas");
    self.backCanvas.setAttribute("id", self.id + "_background");

    self.canvas.style.zIndex = self.zIndex;
    self.canvas.width  = self.backCanvas.width  = self.w *self.ratio;
    self.canvas.height = self.backCanvas.height = self.h *self.ratio;
    self.canvas.style.width  = self.backCanvas.style.width  = self.w + "px";
    self.canvas.style.height = self.backCanvas.style.height = self.h + "px";

    // get context
    self.ctx = self.canvas.getContext("2d");
    self.backCtx = self.backCanvas.getContext("2d");
    self.ctx.imageSmoothingEnabled = self.backCtx.imageSmoothingEnabled = false;

    // create a graphic control container
    self.graphicControlContainer = document.createElement("div");
    self.graphicControlContainer.setAttribute("id", self.id + "_graphicControls");
    self.graphicControlContainer.setAttribute("style", "position:absolute;left:0;top:0;z-index:" + self.zIndex + ";");

    // create a control container
    self.numericalControlContainer = document.createElement("div");
    self.numericalControlContainer.setAttribute("id", self.id + "_numericalControls");
    self.numericalControlContainer.setAttribute("style", "position:absolute;left:0;top:0;z-index:" + self.zIndex + ";");

    // create the principal container
    self.container = document.createElement("div");
    self.container.setAttribute("id", self.id);
    self.container.setAttribute("class", "DescartesSpace2DContainer");
    self.container.setAttribute("style", "left:" + self.x + "px;top:" + self.y + "px;z-index:" + self.zIndex + ";");

    // ### ARQUIMEDES ###
    // the default arquimedes add a border to the container
    if ((self.parent.arquimedes) && (self.background.getColor() === "#f0f8fa")) {
      // self.container.style.border = "1px solid #b8c4c8";
      self.container.style.boxShadow = "0 0 5px 0 #b8c4c8";
    }
    // ### ARQUIMEDES ###

    // add the elements to the container
    self.container.appendChild(self.backCanvas);
    self.container.appendChild(self.canvas);
    self.container.appendChild(self.graphicControlContainer);
    self.container.appendChild(self.numericalControlContainer);

    parent.container.insertBefore(self.container, parent.loader);

    // variable to expose the image of the space
    var id_name = self.id + ".image";
    self.parent.images[id_name] = self.canvas;
    self.parent.images[id_name].ready = 1;
    self.parent.images[id_name].complete = self.parent.images[id_name].canvas = true;
    self.evaluator.setVariable(id_name, id_name);

    // variable to expose the image of the background space
    var id_back = self.id + ".back";
    self.parent.images[id_back] = self.backCanvas;
    self.parent.images[id_back].ready = 1;
    self.parent.images[id_back].complete = self.parent.images[id_back].canvas = true;
    self.evaluator.setVariable(id_back, id_back);

    var tmpStr = ((self.id !== "") && (parent.version !== 2)) ? self.id + "." : "";
    self.OxStr    = tmpStr + "Ox";
    self.OyStr    = tmpStr + "Oy";
    self.scaleStr = tmpStr + "escala";
    self.wStr     = tmpStr + "_w";
    self.hStr     = tmpStr + "_h";
    self.mxStr    = tmpStr + "mouse_x";
    self.myStr    = tmpStr + "mouse_y";
    self.mpressedStr = tmpStr + "mouse_pressed";
    self.mclickedStr = tmpStr + "mouse_clicked";
    self.mclickIzqStr = tmpStr + "clic_izquierdo";

    self.click = 0;

    if(self.resizable) {
      self.wModExpr = parent.evaluator.parser.parse(self.wModExpr);
      self.hModExpr = parent.evaluator.parser.parse(self.hModExpr);
    }

    // register the mouse and touch events
    if (self.id !== "descartesJS_stage") {
      self.addEvents();
    }
    else {
      self.stage_height = 0;
      self.canvas.oncontextmenu = function (evt) { return false; };
    }
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Space
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Space2D, descartesJS.Space);

  /**
   * Init the space
   */
  descartesJS.Space2D.prototype.init = function() {
    self = this;

    // call the init of the parent
    // self.uber.init.call(self);
    this.initSpace();

    // update the size of the canvas if has some regions
    if (self.canvas) {
      self.old_w = self.w;
      self.old_h = self.h;
      self.canvas.width  = self.backCanvas.width  = self.w *self.ratio;
      self.canvas.height = self.backCanvas.height = self.h *self.ratio;
      self.canvas.style.width  = self.backCanvas.style.width  = self.w + "px";
      self.canvas.style.height = self.backCanvas.style.height = self.h + "px";
    }

    if (self.id === "descartesJS_stage") {
      self.setArquimedesHeight();

      if ((descartesJS.TextController) && (!self.textController)) {
        var textNodes = null;
        if ((self.backGraphics[0]) && (self.backGraphics[0].text) && (self.backGraphics[0].text.textNodes)) {
          textNodes = self.backGraphics[0].text.textNodes;
        }

        if (textNodes) {
          var defaultStyle = { fontFamily:"Times New Roman", fontSize:"30px",fontStyle:"normal", fontWeight:"normal", textDecoration:"none", decimals:2, fixed:false };

          self.textController = new descartesJS.TextController(
            this,
            self.container,
            self.backCanvas,
            textNodes,
            defaultStyle,
            "000000"
          );
        }
      }

    }
  }

  /**
   * Update the space
   * @param {Boolean} firstTime condition if is the first time in draw the space
   */
  descartesJS.Space2D.prototype.update = function(firstTime) {
    self = this;
    evaluator = self.evaluator;
    parent = self.parent;

    // prevents the change of the width and height from an external change
    if (!self.resizable) {
      evaluator.setVariable(self.wStr, self.w);
      evaluator.setVariable(self.hStr, self.h);
    }
    // check the draw if condition
    self.drawIfValue = evaluator.eval(self.drawif) > 0;

    // draw the space
    if (self.drawIfValue) {

      //////////////////////////////////////////////////////////////////////////////////
      // change in the space size
      if (self.resizable) {
        wModExpr = self.evaluator.eval(self.wModExpr);
        hModExpr = self.evaluator.eval(self.hModExpr);
        
        if ((self.old_w != wModExpr) || (self.old_h != hModExpr)) {
          self.w = wModExpr;
          self.h = hModExpr;
          self.w_2 = self.w/2;
          self.h_2 = self.h/2;
          evaluator.setVariable(self.wStr, self.w);
          evaluator.setVariable(self.hStr, self.h);
          self.old_w = self.w;
          self.old_h = self.h;
          self.canvas.width  = self.backCanvas.width  = self.w *self.ratio;
          self.canvas.height = self.backCanvas.height = self.h *self.ratio;
          self.canvas.style.width  = self.backCanvas.style.width  = self.w + "px";
          self.canvas.style.height = self.backCanvas.style.height = self.h + "px";
          firstTime = true;
        }
      }
      //////////////////////////////////////////////////////////////////////////////////

      changeX = (self.x !== (evaluator.eval(self.xExpr) + self.displaceRegionWest));
      changeY = (self.y !== (evaluator.eval(self.yExpr) + parent.plecaHeight  + self.displaceRegionNorth));

      // check if the space has change
      self.spaceChange = firstTime ||
                         changeX ||
                         changeY ||
                         (self.drawBefore !== self.drawIfValue) ||
                         (self.Ox !== evaluator.getVariable(self.OxStr)) ||
                         (self.Oy !== evaluator.getVariable(self.OyStr)) ||
                         (self.scale !== evaluator.getVariable(self.scaleStr)) ||
                         (self.backColor !== self.background.getColor());

      self.x = (changeX) ? evaluator.eval(self.xExpr) + self.displaceRegionWest : self.x;
      self.y = (changeY) ? evaluator.eval(self.yExpr) + parent.plecaHeight + self.displaceRegionNorth : self.y;
      self.Ox = evaluator.getVariable(self.OxStr);
      self.Oy = evaluator.getVariable(self.OyStr);
      self.scale = evaluator.getVariable(self.scaleStr);
      self.drawBefore = self.drawIfValue;

      // check if the scale is not below the lower limit or not above the upper limit
      self.scale = Math.max(minScale, Math.min(maxScale, self.scale));
      evaluator.setVariable(self.scaleStr, self.scale);

      // if some property change then adjust the container style
      if ((changeX) || (changeY)) {
        self.container.style.left = self.x + "px";
        self.container.style.top  = self.y + "px";
      }

      self.container.style.display = "block";

      // draw the trace
      self.drawTrace = (!self.spaceChange) && (((!self.fixed)&&(!self.click)) || (self.fixed));

      if (self.spaceChange) {
        self.backCtx.setTransform(self.ratio, 0, 0, self.ratio, 0, 0);
        self.drawBackground();
      }
      self.ctx.setTransform(self.ratio, 0, 0, self.ratio, 0, 0);
      self.draw();
    }
    // hide the space
    else {
      self.container.style.display = "none";
    }
  }

  /**
   * Draw the space background
   */
  descartesJS.Space2D.prototype.drawBackground = function() {
    self = this;
    evaluator = self.evaluator;
    ctx = self.backCtx;

    // draw the background color
    ctx.clearRect(0, 0, self.backCanvas.width, self.backCanvas.height);
    self.backColor = self.background.getColor();
    ctx.fillStyle = self.backColor;

    ctx.fillRect(0, 0, self.backCanvas.width, self.backCanvas.height);

    // draw the background image if any
    if ( (self.image) && (self.image.src != "") && (self.image.ready) && (self.image.complete) ) {
      if (self.bg_display === "topleft") {
        ctx.drawImage(self.image, 0, 0);
      }
      else if (self.bg_display === "stretch") {
        ctx.drawImage(self.image, 0, 0, self.w, self.h);
      }
      else if (self.bg_display === "patch") {
        ctx.fillStyle = ctx.createPattern(self.image, "repeat");
        ctx.fillRect(0, 0, self.w, self.h);
      }
      else if (self.bg_display === "imgcenter") {
        ctx.drawImage(self.image, (self.w-self.image.width)/2, (self.h-self.image.height)/2);
      }
    }

    rsc = self.scale;
    dec = 0;
    wh_temp = ((self.w+self.h) < 0) ? 0 : (self.w+self.h);

    while (rsc>(wh_temp)) {
      rsc/=10;
      dec++;
    }
    while (rsc<(wh_temp)/10) {
      rsc*=10;
    }

    ctx.lineWidth = 1;

    // draw the big net
    if (self.net !== "") {
      ctx.strokeStyle = self.net.getColor();
      self.drawMarks(ctx, rsc/10, -1);
    }

    // draw the finnest net
    if ( ((self.parent.version !== 2) && (self.net10 !== "")) ||
         ((self.parent.version === 2) && (self.net !== "") && (self.net10 !== ""))
       ) {
      ctx.strokeStyle = self.net10.getColor();
      self.drawMarks(ctx, rsc, -1);
    }

    // draw the axes
    if (self.axes !== "") {
      var ignore_axis = "";
      if (self.x_axis == "no") {
        ignore_axis+= "x";
      }
      if (self.y_axis == "no") {
        ignore_axis+= "y";
      }

      ctx.strokeStyle = self.axes.getColor();

      ctx.beginPath();
      // x axis
      if ((self.x_axis != "no") && ((self.x_axis !== "") || (self.parent.version !== 2))) {
        ctx.moveTo(0, MathFloor(self.h/2+self.Oy)+.5);
        ctx.lineTo(self.w, MathFloor(self.h/2+self.Oy)+.5);
      }

      // y axis
      if ((self.y_axis != "no") && ((self.y_axis !== "") || (self.parent.version !== 2))) {
        ctx.moveTo(MathFloor(self.w/2+self.Ox)+.5, 0);
        ctx.lineTo(MathFloor(self.w/2+self.Ox)+.5, self.h);
      }

      ctx.lineWidth = 1.2;
      ctx.stroke();
      ctx.lineWidth = 1;

      self.drawMarks(ctx, rsc, 4, ignore_axis);
      self.drawMarks(ctx, rsc/2, 2, ignore_axis);
      self.drawMarks(ctx, rsc/10, 1, ignore_axis);
    }

    // draw the axis names
    if ((self.x_axis !== "") || (self.y_axis !== "")) {
      ctx.fillStyle = (self.axes !== "") ? self.axes.getColor() : "#000";

      ctx.font = axisFont;
      ctx.textAlign = "right";
      ctx.textBaseline = "alphabetic";
      if (self.x_axis != "no") {
        ctx.fillText(self.x_axis, MathFloor(self.w)-2, MathFloor(self.h/2+self.Oy)+12);
      }
      if (self.y_axis != "no") {
        ctx.fillText(self.y_axis, MathFloor(self.w/2+self.Ox)-2, 12);
      }
    }

    // draw the axis numbers
    if ((self.numbers) && (self.axes != "")) {
      ctx.fillStyle = self.axes.getColor();
      ctx.font = axisFont;
      ctx.textAlign = "start";
      ctx.textBaseline = "bottom";

      if (rsc > ((self.w+self.h)/2)) {
        self.drawNumbers(ctx, rsc/5, (rsc<=self.scale)?dec+1:dec);
      }
      else if (rsc > ((self.w+self.h)/4)) {
        self.drawNumbers(ctx, rsc/2, (rsc<=self.scale)?dec+1:dec);
      }
      else {
        self.drawNumbers(ctx, rsc, dec);
      }
    }

    // draw the background graphics
    for (var i=0, l=this.backGraphics.length; i<l; i++) {
      this.backGraphics[i].draw();
    }
  }

  descartesJS.Space2D.prototype.setArquimedesHeight = function() {
    var self = this;

    self.update(true);

    if ((self.backGraphics.length > 0) && (self.backGraphics[0].text.textNodes.metrics.h !== self.stage_height)) {
      self.stage_height = self.backGraphics[0].text.textNodes.metrics.h;

      var bottom = 0;
      if (self.backGraphics.length > 1) {
        bottom = self.backGraphics[1].text.textNodes.metrics.h +25;
      }
      self.h = self.stage_height + bottom + 75;

      // creative commons banner
      if (self.backGraphics.length > 1) {
        self.backGraphics[1].expresion = self.evaluator.parser.parse("[" + self.backGraphics[1].exprX + "," + (self.stage_height+bottom) + "]");
      }
      if (self.backGraphics.length > 2) {
        self.backGraphics[2].expresion = self.evaluator.parser.parse("[" + self.backGraphics[2].exprX + "," + (self.stage_height+bottom+25) + "]");
      }

      self.canvas.width  = self.backCanvas.width  = self.w *self.ratio;
      self.canvas.height = self.backCanvas.height = self.h *self.ratio;
      self.canvas.style.width  = self.backCanvas.style.width  = self.w + "px";
      self.canvas.style.height = self.backCanvas.style.height = self.h + "px";

      self.parent.container.style.height = (self.h + self.plecaHeight) + "px";

      self.update(true);
    }
  }


  /**
   * Draw the space
   */
  descartesJS.Space2D.prototype.draw = function() {
    self = this;
    ctx = self.ctx;

    ctx.clearRect(0, 0, self.canvas.width, self.canvas.height);

    // draw the no background graphics
    for (var i=0, l=self.graphics.length; i<l; i++) {
      thisGraphics_i = self.graphics[i];

      if ((thisGraphics_i.trace !== "") && (self.drawTrace)) {
        thisGraphics_i.drawTrace();
      }

      thisGraphics_i.draw();
    }

    // draw the graphic controls
    for (var i=0, l=self.graphicsCtr.length; i<l; i++) {
      self.graphicsCtr[i].draw();
    }

    // draw the text showing the mouse postion
    if ((self.text != "") && (self.click) && (self.whichBtn === "L")) {
      ctx.save();
      ctx.fillStyle = self.text.getColor();
      ctx.strokeStyle = ctx.fillStyle;
      ctx.lineWidth = 1;
      ctx.font = mouseTextFont;
      ctx.textAlign = "center";
      ctx.textBaseline = "alphabetic";

      coordTxt_X = (self.scale <= 1) ? ((self.mouse_x).toFixed(0)) : (self.mouse_x).toFixed((self.scale).toString().length);
      coordTxt_Y = (self.scale <= 1) ? ((self.mouse_y).toFixed(0)) : (self.mouse_y).toFixed((self.scale).toString().length);
      coordTxt = "(" + coordTxt_X + "," + coordTxt_Y + ")";
      coordTxtW = MathFloor(ctx.measureText(coordTxt).width/2);
      mouseX = self.getAbsoluteX(self.mouse_x);
      mouseY = self.getAbsoluteY(self.mouse_y);
      posX = MathFloor(mouseX);
      posY = MathFloor(mouseY-10);

      // prevents the mouse position text get out of the space
      if ((posX+coordTxtW) > self.w) {
        posX = self.w-coordTxtW;
      }
      else if ((posX-coordTxtW) < 0) {
        posX = coordTxtW;
      }
      if ((posY+1) > self.h) {
        posY = self.h;
      }
      else if ((posY-14) < 0) { // 14 is aproximately the text height
        posY = 15;
      }

      ctx.fillText(coordTxt, posX, posY);

      ctx.beginPath();
      ctx.arc(mouseX, mouseY, 2.5, 0, PI2, true);
      ctx.stroke();
      ctx.restore();
    }
  }

  /**
   * Draw the axis marks in the space
   * @param {CanvasRenderingContext2D} ctx the rendering context to draw
   * @param {Number} rsc
   * @param {Number} sz
   */
  descartesJS.Space2D.prototype.drawMarks = function(ctx, rsc, sz, ignore) {
    w = this.w;
    h = this.h;

    x1 = 0;
    y1 = 0;
    x2 = w;
    y2 = h;
    Ox = MathFloor(w/2+this.Ox);
    Oy = MathFloor(h/2+this.Oy);

    if (sz >= 0) {
      x1 = Ox-sz;
      x2 = Ox+sz;
      y1 = Oy-sz;
      y2 = Oy+sz;
    }

    ctx.beginPath();

    if ((!ignore) || ((ignore) && (!ignore.match("x")))) {
      for (var i=-MathRound(Ox/rsc); (x = Ox + MathRound(i*rsc)) < w; i++) {
        ctx.moveTo(x+.5, y1+.5);
        ctx.lineTo(x+.5, y2+.5);
      }
    }
    if ((!ignore) || ((ignore) && (!ignore.match("y")))) {
      for (var i=-MathRound(Oy/rsc); (y = Oy + MathRound(i*rsc)) < h; i++) {
        ctx.moveTo(x1+.5, y+.5);
        ctx.lineTo(x2+.5, y+.5);
      }
    }

    ctx.stroke();
  }

  /**
   * Draw the axis numbers
   * @param {CanvasRenderingContext2D} ctx the rendering context to draw
   * @param {Number} rsc
   * @param {Number} dec
   */
  descartesJS.Space2D.prototype.drawNumbers = function(ctx, rsc, dec) {
    w = this.w;
    h = this.h;

    Ox = MathFloor(w/2+this.Ox);
    Oy = MathFloor(h/2+this.Oy);

    for (var i=-MathRound(Ox/rsc); (x = Ox + MathRound(i*rsc)) < w; i++) {
      ctx.fillText(parseFloat( (i*rsc/this.scale).toFixed(4) ), x+1, Oy-2);
    }

    for (var i=-MathRound(Oy/rsc); (y = Oy + MathRound(i*rsc)) < h; i++) {
      if (parseFloat( (-i*rsc/this.scale) ) !== 0) {
        ctx.fillText(parseFloat( (-i*rsc/this.scale).toFixed(4) ), Ox+5, y+5);
      }
    }
  }

  /**
   * Register the mouse and touch events
   */
  descartesJS.Space2D.prototype.addEvents = function() {
    var self = this;
    self.posZoom = self.posZoomNew = null;

    // prevent the context menu display
    self.canvas.oncontextmenu = function (evt) { return false; };

    ///////////////////////////////////////////////////////////////////////////
    // Registro de eventos de touch
    ///////////////////////////////////////////////////////////////////////////
    if (this.sensitive_to_mouse_movements) {
      this.canvas.addEventListener("touchmove",  onSensitiveToMouseMovements);
    }
    this.canvas.addEventListener("touchstart", onTouchStart);

    /**
     * @param {Event} evt
     * @private
     */
    function onTouchStart(evt) {
      // remove the focus of the controls
      window.focus();
      document.activeElement.blur();

      // try to preserve the slide gesture in tablets
      if ((!self.evaluator.variables[self.id + ".DESCARTESJS_no_fixed"]) && (self.fixed) && (!self.sensitive_to_mouse_movements)) {
        return;
      }

      self.parent.clearClick();

      self.click = 1;
      self.evaluator.setVariable(self.mpressedStr, 1);
      self.evaluator.setVariable(self.mclickedStr, 0);
      self.evaluator.setVariable(self.mclickIzqStr, 0);

      // deactivate the graphic controls
      self.parent.deactivateGraphiControls();

      onSensitiveToMouseMovements(evt);

      window.addEventListener("touchmove", onMouseMove);
      window.addEventListener("touchend", onTouchEnd);

      evt.stopPropagation();
      evt.preventDefault();
    }

    /**
     * @param {Event} evt
     * @private
     */
    function onTouchEnd(evt) {
      // remove the focus of the controls
      window.focus();
      document.activeElement.blur();

      // try to preserve the slide gesture in tablets
      if ((!self.evaluator.variables[self.id + ".DESCARTESJS_no_fixed"]) && (self.fixed) && (!self.sensitive_to_mouse_movements)) {
        return;
      }

      self.click = 0;
      self.evaluator.setVariable(self.mpressedStr, 0);
      self.evaluator.setVariable(self.mclickedStr, 1);
      self.evaluator.setVariable(self.mclickIzqStr, 1);

      window.removeEventListener("touchmove", onMouseMove);
      window.removeEventListener("touchend", onTouchEnd);

      evt.stopPropagation();
      evt.preventDefault();

      self.parent.update();
    }

    ///////////////////////////////////////////////////////////////////////////
    // Registro de eventos de mouse
    ///////////////////////////////////////////////////////////////////////////
    if (this.sensitive_to_mouse_movements) {
      this.canvas.addEventListener("mousemove", onSensitiveToMouseMovements);
    }
    this.canvas.addEventListener("mousedown", onMouseDown);

    /**
     * dbclick
     */
    this.canvas.addEventListener("dblclick", function(evt) {
      // self.parent.externalSpace.show();
    });

    /**
     * @param {Event} evt
     * @private
     */
    function onMouseDown(evt) {
      // remove the focus of the controls
      window.focus();
      document.activeElement.blur();

      evt.stopPropagation();
      evt.preventDefault();

      self.parent.clearClick();

      self.click = 1;

      // deactivate the graphic controls
      self.parent.deactivateGraphiControls();

      self.whichBtn = descartesJS.whichBtn(evt);

      if (self.whichBtn === "R") {
        window.addEventListener("mouseup", onMouseUp);

        self.posZoom = (descartesJS.getCursorPosition(evt, self.container)).y;
        self.posZoomNew = self.posZoom;

        // if not fixed add a zoom manager
        if (!self.fixed) {
          self.tempScale = self.scale;

          window.addEventListener("mousemove", onMouseMoveZoom);
        }
      }
      else if (self.whichBtn === "L") {
        self.evaluator.setVariable(self.mpressedStr, 1);
        self.evaluator.setVariable(self.mclickedStr, 0);
        self.evaluator.setVariable(self.mclickIzqStr, 0);

        onSensitiveToMouseMovements(evt);

        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("mouseup", onMouseUp);
      }
    }

    /**
     * @param {Event} evt
     * @private
     */
    function onMouseUp(evt) {
      // remove the focus of the controls
      document.activeElement.blur();
      window.focus();

      evt.stopPropagation();
      evt.preventDefault();

      self.click = 0;
      self.evaluator.setVariable(self.mpressedStr, 0);
      self.evaluator.setVariable(self.mclickedStr, 1);
      self.evaluator.setVariable(self.mclickIzqStr, 1);

      if (self.whichBtn === "R") {
        window.removeEventListener("mousemove", onMouseMoveZoom);

        // show the external space
        if ((self.posZoom == self.posZoomNew) && (descartesJS.showConfig)) {
          self.parent.externalSpace.show();
          self.posZoom = false;
          self.posZoomNew = true;
        }
      }

      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", onMouseUp);

      // deactivate control
      self.parent.deactivateGraphiControls();

      self.parent.update();
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onSensitiveToMouseMovements(evt) {
      self.posAnte = descartesJS.getCursorPosition(evt, self.container);
      self.mouse_x = self.getRelativeX(self.posAnte.x);
      self.mouse_y = self.getRelativeY(self.posAnte.y);
      self.evaluator.setVariable(self.mxStr, self.mouse_x);
      self.evaluator.setVariable(self.myStr, self.mouse_y);

      self.evaluator.setVariable(self.mclickedStr, 0);
      self.evaluator.setVariable(self.mclickIzqStr, 0);

      self.parent.update();
    }

    /**
     * @param {Event} evt
     * @private
     */
    function onMouseMoveZoom(evt) {
      evt.preventDefault();

      self.posZoomNew = (descartesJS.getCursorPosition(evt, self.container)).y;

      self.evaluator.setVariable(self.scaleStr, self.tempScale + (self.tempScale/45)*((self.posZoom-self.posZoomNew)/10));

      self.parent.update();
    }

    /**
     * @param {Event} evt
     * @private
     */
    function onMouseMove(evt) {
      evt.preventDefault();
      evt.stopPropagation();

      // if the space is not fixed, then change the origin coordinates
      if (!self.fixed) {
        self.posNext = descartesJS.getCursorPosition(evt, self.container);
        disp = { x: (self.posAnte.x - self.posNext.x),
                 y: (self.posAnte.y - self.posNext.y) };

        self.evaluator.setVariable(self.OxStr, (self.Ox - disp.x));
        self.evaluator.setVariable(self.OyStr, (self.Oy - disp.y));
      }

      onSensitiveToMouseMovements(evt);
    }

    document.addEventListener("visibilitychange", function(evt) {
      onMouseUp(evt);
    });

  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var MathFloor = Math.floor;
  var MathRound = Math.round;
  var MathMax   = Math.max;
  var MathCos   = Math.cos;
  var MathSin   = Math.sin;
  var MathSqrt  = Math.sqrt;
  var MathPI_2  = Math.PI/2;
  var tiltAngle = 0;
  var cosTiltAngle = Math.cos(tiltAngle);
  var sinTiltAngle = Math.sin(tiltAngle);
  var tanTiltAngle = Math.tan(tiltAngle);
  var minScale = 0.000001;
  var maxScale = 1000000;

  var evaluator;
  var parent;
  var self;
  var thisGraphics_i;
  var thisGraphicsNext;
  var primitives;
  var primitivesLength;
  var changeX;
  var changeY;
  var dispX;
  var dispY;

  var dx;
  var dy;
  var dz;
  var t;

  var angle;
  var cosAngle;
  var sinAngle;
  var newV1;

  var r;
  var g;
  var b;
  var dl3;
  var intensity = [];
  var I;
  var c;
  var normal;
  var toEye;
  var aveDistanceToEye;
  var unitToEye;

  var t_rr;
  var r_rr;
  var N_rr;

  var observerSet;

  // :-/
  var cfactor = 3;

  var auxVertex;

  /**
   * Descartes 3D space
   * @constructor
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the graphic
   */
  descartesJS.Space3D = function(parent, values) {
    // call the parent constructor
    descartesJS.Space.call(this, parent, values);

    self = this;

    // create the canvas
    self.backCanvas = document.createElement("canvas");
    self.backCanvas.setAttribute("id", self.id + "_background");
    self.backCanvas.setAttribute("width", self.w + "px");
    self.backCanvas.setAttribute("height", self.h + "px");
  
    self.canvas = document.createElement("canvas");
    self.canvas.setAttribute("id", self.id + "_canvas");
    self.canvas.setAttribute("width", self.w + "px");
    self.canvas.setAttribute("height", self.h + "px");
    self.canvas.setAttribute("class", "DescartesSpace3DCanvas");
    self.canvas.setAttribute("style", "z-index: " + self.zIndex + ";");
    self.ctx = self.canvas.getContext("2d");
    self.ctx.imageSmoothingEnabled = false;

    // variable to expose the image of the space
    var id_name = self.id + ".image";
    self.parent.images[id_name] = self.canvas;
    self.parent.images[id_name].ready = 1;
    self.parent.images[id_name].complete = true;
    self.parent.images[id_name].canvas = true;
    self.evaluator.setVariable(id_name, id_name);

    // create a graphic control container
    self.graphicControlContainer = document.createElement("div");
    self.graphicControlContainer.setAttribute("id", self.id + "_graphicControls");
    self.graphicControlContainer.setAttribute("style", "position:absolute;left:0px;top:0px;z-index:" + self.zIndex + ";");

    // create a control container
    self.numericalControlContainer = document.createElement("div");
    self.numericalControlContainer.setAttribute("id", self.id + "_numericalControls");
    self.numericalControlContainer.setAttribute("style", "position:absolute;left:0px;top:0px;z-index:" + self.zIndex + ";");

    // create the principal container
    self.container = document.createElement("div");
    self.container.setAttribute("id", self.id);
    self.container.setAttribute("class", "DescartesSpace3DContainer");
    self.container.setAttribute("style", "left:" + self.x + "px;top:" + self.y + "px;z-index:" + self.zIndex + ";");

    // add the elements to the container
    self.container.appendChild(self.backCanvas);
    self.container.appendChild(self.canvas);
    self.container.appendChild(self.graphicControlContainer);
    self.container.appendChild(self.numericalControlContainer);

    parent.container.insertBefore(self.container, parent.loader);

    self.eye = { x: 0, y: 0, z: 0 };

    self.lights = [ 
      { x: 50, y:  50, z: 70},
      { x: 50, y: -50, z: 30},
      { x: 20, y:   0, z: -80},
      { x:  0, y:   0, z: 0}
    ];
    for (var i=0, l=self.lights.length; i<l; i++) {
      self.lights[i] = descartesJS.normalize3D(self.lights[i]);
    }
    self.light3 = { x:0, y:0, z:0 };

    self.intensity = [.4, .5, .3, 0];
    self.userIntensity = 0;
    self.dim = 1;
    self.tmpIntensity = [];

    self.OxStr = self.id + ".Ox";
    self.OyStr = self.id + ".Oy";
    self.scaleStr = self.id + ".escala";
    self.wStr = self.id + "._w";
    self.hStr = self.id + "._h";
    self.obsStr = self.id + ".observador";
    self.ojoXStr = self.id + ".Ojo.x";
    self.ojoYStr = self.id + ".Ojo.y";
    self.ojoZStr = self.id + ".Ojo.z";
    self.rotZStr = self.id + ".rot.z";
    self.rotYStr = self.id + ".rot.y";
    self.userIDimStr = self.id + ".userIlum.dim";
    self.userIIStr = self.id + ".userIlum.I";
    self.userIxStr = self.id + ".userIlum.x";
    self.userIyStr = self.id + ".userIlum.y";
    self.userIzStr = self.id + ".userIlum.z";

    // set the value to the rotation variables
    self.evaluator.setVariable(self.rotZStr, 0);
    self.evaluator.setVariable(self.rotYStr, 0);
    self.evaluator.setVariable(self.userIDimStr, self.dim);
    self.evaluator.setVariable(self.userIIStr, self.userIntensity);
    self.evaluator.setVariable(self.userIxStr, 0);
    self.evaluator.setVariable(self.userIyStr, 0);
    self.evaluator.setVariable(self.userIzStr, 0);

    // function to calc the position of a external point
    auxVertex = new descartesJS.Primitive3D( { vertices: [new descartesJS.Vector4D(0, 0, 0, 1)],
                                               type: "vertex"
                                             },
                                             self );
    self.evaluator.setFunction(self.id + "._X3D2D_", function(x, y, z) {
      auxVertex.vertices[0].x = x;
      auxVertex.vertices[0].y = y;
      auxVertex.vertices[0].z = z;
      auxVertex.computeDepth(self)
      return auxVertex.projVert[0].x;
    });
    self.evaluator.setFunction(self.id + "._Y3D2D_", function(x, y, z) {
      auxVertex.vertices[0].x = x;
      auxVertex.vertices[0].y = y;
      auxVertex.vertices[0].z = z;
      auxVertex.computeDepth(self)
      return auxVertex.projVert[0].y;
    });
    //

    if(self.resizable) {
      self.wModExpr = parent.evaluator.parser.parse(self.wModExpr);
      self.hModExpr = parent.evaluator.parser.parse(self.hModExpr);
    }
    // self.ratio = parent.ratio;
    self.ratio = 1;


    // register the mouse and touch events
    self.addEvents();
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Space
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.Space3D, descartesJS.Space);

  /**
   * Init the space
   */
  descartesJS.Space3D.prototype.init = function(checkObserver) {
    self = this;

    // call the init of the parent
    // self.uber.init.call(self);
    self.initSpace();

    // update the size of the canvas if has some regions
    if (self.canvas) {
      self.canvas.width  = self.backCanvas.width  = self.w;
      self.canvas.height = self.backCanvas.height = self.h;
      self.canvas.style.width  = self.backCanvas.style.width  = self.w + "px";
      self.canvas.style.height = self.backCanvas.style.height = self.h + "px";
    };

    self.w_2 = self.w/2;
    self.h_2 = self.h/2;

    self.w_plus_h = self.w + self.h;

    self.oldMouse = {x: 0, y: 0};

    ////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////
    var rescale = (self.h/1080)*(40/self.scale);
    self.S = { 
      x: -20.6*rescale,
      y: 0,
      z: 0,
    };
    self.Ojo = {
      x: 3*self.w_2,
      // x: 30*self.w_2,
      y: 0,
      z: 0
    };
    self.evaluator.setVariable(self.ojoXStr, self.Ojo.x);
    self.evaluator.setVariable(self.ojoYStr, self.Ojo.y);
    self.evaluator.setVariable(self.ojoZStr, self.Ojo.z);

    ////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////
  }

  /**
   * Update the space
   * @param {Boolean} firstTime condition if is the first time in draw the space
   */
  descartesJS.Space3D.prototype.update = function(firstTime) {
    self = this;
    evaluator = self.evaluator;
    parent = self.parent;

    // prevents the change of the width and height from an external change
    evaluator.setVariable(self.wStr, self.w);
    evaluator.setVariable(self.hStr, self.h);

    // check the draw if condition
    self.drawIfValue = evaluator.eval(self.drawif) > 0;

    if (self.drawIfValue) {
      //////////////////////////////////////////////////////////////////////////////////
      // change in the space size
      if (self.resizable) {
        wModExpr = self.evaluator.eval(self.wModExpr);
        hModExpr = self.evaluator.eval(self.hModExpr);

        if ((self.old_w != wModExpr) || (self.old_h != hModExpr)) {
          self.w = wModExpr;
          self.h = hModExpr;
          self.w_2 = self.w/2;
          self.h_2 = self.h/2;
          evaluator.setVariable(self.wStr, self.w);
          evaluator.setVariable(self.hStr, self.h);
          self.old_w = self.w;
          self.old_h = self.h;
          self.canvas.width  = self.backCanvas.width  = self.w *self.ratio;
          self.canvas.height = self.backCanvas.height = self.h *self.ratio;
          self.canvas.style.width  = self.backCanvas.style.width  = self.w + "px";
          self.canvas.style.height = self.backCanvas.style.height = self.h + "px";
          firstTime = true;

          var rescale = (self.h/1080)*(40/self.scale);
          self.S = { 
            x: -20.6*rescale,
            y: 0,
            z: 0,
          };
          self.Ojo = {
            x: 3*self.w_2,
            // x: 30*self.w_2,
            y: 0,
            z: 0
          };
          self.evaluator.setVariable(self.ojoXStr, self.Ojo.x);
          self.evaluator.setVariable(self.ojoYStr, self.Ojo.y);
          self.evaluator.setVariable(self.ojoZStr, self.Ojo.z);

        }
      }
      //////////////////////////////////////////////////////////////////////////////////

      changeX = (self.x !== (evaluator.eval(self.xExpr) + self.displaceRegionWest));
      changeY = (self.y !== (evaluator.eval(self.yExpr) + parent.plecaHeight  + self.displaceRegionNorth));

      // check if the space has change
      self.spaceChange = firstTime ||
                         changeX ||
                         changeY ||
                         (self.drawBefore !== self.drawIfValue) ||
                         (self.Ox !== evaluator.getVariable(self.OxStr)) ||
                         (self.Oy !== evaluator.getVariable(self.OyStr)) ||
                         (self.Ojo.x !== evaluator.getVariable(self.ojoXStr)) ||
                         (self.Ojo.y !== evaluator.getVariable(self.ojoYStr)) ||
                         (self.Ojo.z !== evaluator.getVariable(self.ojoZStr)) ||
                         (self.scale !== evaluator.getVariable(self.scaleStr));

      self.x = (changeX) ? evaluator.eval(self.xExpr) + self.displaceRegionWest : self.x;
      self.y = (changeY) ? evaluator.eval(self.yExpr) + parent.plecaHeight + self.displaceRegionNorth : self.y;
      self.Ojo.x = evaluator.getVariable(self.ojoXStr);
      self.Ojo.y = evaluator.getVariable(self.ojoYStr);
      self.Ojo.z = evaluator.getVariable(self.ojoZStr);
      self.Ox = evaluator.getVariable(self.OxStr);
      self.Oy = evaluator.getVariable(self.OyStr);
      self.scale = evaluator.getVariable(self.scaleStr);
      self.drawBefore = self.drawIfValue;

      if ((firstTime) || (self.observer == undefined)) {
        // check if the observer is the name of some control
        for (var i=0, l=self.parent.controls.length; i<l; i++) {
          if (self.parent.controls[i].id === self.obsStr) {
            observerSet = true;
          }
        }

        if (observerSet) {
          self.observer = evaluator.getVariable(self.obsStr) || (self.w_plus_h) * 2.5;
        }
        else {
          self.observer = (self.w_plus_h) * 2.5;
        }

        self.observer = MathMax(self.observer, 0.25*(self.w_plus_h));

        evaluator.setVariable(self.obsStr, self.observer);
      }

      // check if the scale is not below the lower limit
      if (self.scale < minScale) {
        self.scale = minScale;
        evaluator.setVariable(self.scaleStr, minScale);
      }
      // check if the scale is not above the upper limit
      else if (self.scale > maxScale) {
        self.scale = maxScale;
        evaluator.setVariable(self.scaleStr, maxScale);
      }

      // if some property change then adjust the container style
      if ((changeX) || (changeY)) {
        self.container.style.left = self.x + "px";
        self.container.style.top = self.y + "px";
      }

      self.container.style.display = "block";

      self.dim = evaluator.getVariable(self.userIDimStr);
      self.userIntensity = evaluator.getVariable(self.userIIStr);
      // user defined light
      self.light3 = { x: parseInt(evaluator.getVariable(self.userIxStr)),
                      y: parseInt(evaluator.getVariable(self.userIyStr)),
                      z: parseInt(evaluator.getVariable(self.userIzStr))
                    };

      self.updateCamera();

      // draw the geometry
      self.draw();
    }
    // hide the space
    else {
      self.container.style.display = "none";
    }
  }

  /**
   *
   */
  descartesJS.Space3D.prototype.updateCamera = function() {
    // self = this;

    // self.D = self.observer / cfactor;
    // self.eye.x = self.D/self.scale;
    // self.eye.y = 0;
    // self.eye.z = self.D/self.scale*tanTiltAngle;

    this.eye = descartesJS.scalarProduct3D(this.Ojo, 1/this.scale);
// console.log(this.eye, this.Ojo)
  }

  /**
   *
   */
  descartesJS.Space3D.prototype.rotateVertex = function(v) {
    // Z rotation
    angle = descartesJS.degToRad(self.evaluator.getVariable(self.rotZStr));
    cosAngle = MathCos(angle);
    sinAngle = MathSin(angle);

    newV1 = { 
      x: v.x*cosAngle - v.y*sinAngle,
      y: v.x*sinAngle + v.y*cosAngle,
      z: v.z
    };

    // Y rotation
    angle  = descartesJS.degToRad(self.evaluator.getVariable(self.rotYStr));
    cosAngle  = MathCos(angle);
    sinAngle  = MathSin(angle);

    return { 
      x: newV1.z*sinAngle + newV1.x*cosAngle,
      y: newV1.y,
      z: newV1.z*cosAngle - newV1.x*sinAngle
    };
  }

  /**
   *
   */
  descartesJS.Space3D.prototype.project = function(v) {
    self = this;

    var oldProj = this.evaluator.getVariable("URL.oldProj");
    oldProj = true;

    if (oldProj) {
    // old projection
      var lambda = (self.eye.x) / (v.x - self.eye.x);
      var pV = {
        x: self.getAbsoluteX( lambda*( self.eye.y - v.y) ),
        y: self.getAbsoluteY( lambda*( self.eye.z - v.z) ),
        z: self.eye.x - v.x
        // z: self.scale*(self.eye.x - v.x)
      };
  // console.log(v, pV)
      return pV;
    }
    else {
      // new projection
      var _SE = (self.eye.x);
      var fctr = _SE / (-self.S.x + _SE - v.x);
      var pV = {
        x: self.getAbsoluteX( fctr*(v.y - self.S.y) ),
        y: self.getAbsoluteY( fctr*(v.z - self.S.z) ),
        z: self.scale*(self.eye.x - v.x)
      };
  // console.log("nueva", v, pV);
      return pV;
    }
  }

  /**
   *
   */
  descartesJS.Space3D.prototype.computeColor = function(color, primitive, metal) {
    if (color.match("rgba")) {
      color = descartesJS.RGBAToHexColor(color);
    }
    else if (color.match("#")) {
      color = new descartesJS.Color(color.substring(1));
    }

    toEye = descartesJS.subtract3D(this.eye, primitive.average);
    aveDistanceToEye = descartesJS.norm3D(toEye);
    unitToEye = descartesJS.scalarProduct3D(toEye, 1/aveDistanceToEye);

    this.lights[3] = descartesJS.subtract3D(this.light3, primitive.average);
    dl3 = descartesJS.norm3D(this.lights[3]);

    for (var i=0, l=this.intensity.length-1; i<l; i++) {
      intensity[i] = this.intensity[i]*this.dim;
    }
    intensity[3] = ((this.userIntensity*this.userIntensity)/dl3) || 0;

    I = (metal) ? this.dim/2 : this.dim/4;
    c = 0;

    normal = (primitive.direction < 0) ? primitive.normal : descartesJS.scalarProduct3D(primitive.normal, -1);

    for (var i=0, l=this.lights.length; i<l; i++) {
      if (metal) {
        c = Math.max( 0, descartesJS.dotProduct3D(reflectedRay(this.lights[i], normal), unitToEye) );
        c = c*c*c;
      }
      else {
        c = Math.max(0, descartesJS.dotProduct3D(this.lights[i], normal));
      }

      I+= intensity[i]*c;
    }
    I = Math.min(I, 1);

    r = MathFloor(color.r*I);
    g = MathFloor(color.g*I);
    b = MathFloor(color.b*I);

    return "rgba(" + r + "," + g + "," + b + "," + color.a + ")";
  }

  /**
   *
   */
  function reflectedRay(l, uN) {
    t_rr = descartesJS.subtract3D(l, descartesJS.scalarProduct3D(uN, descartesJS.dotProduct3D(l, uN)));
    r_rr = descartesJS.add3D(l, descartesJS.scalarProduct3D(t_rr, -2));
    N_rr = descartesJS.norm3D(r_rr);
    if (N_rr !== 0) {
      return descartesJS.scalarProduct3D(r_rr, 1/N_rr);
    }
    return descartesJS.scalarProduct3D(l, -1);
  }

  //********************************************************************************************************************
  //********************************************************************************************************************
  //********************************************************************************************************************

  /**
   * Draw the primitives of the graphics, the primitives are obtained from the update step
   */
  descartesJS.Space3D.prototype.draw = function() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = this.background.getColor();
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    // draw the background image if any
    if ( (this.image) && (this.image.src != "") && (this.image.ready) && (this.image.complete) ) {
      if (this.bg_display === "topleft") {
        this.ctx.drawImage(this.image, 0, 0);
      }
      else if (this.bg_display === "stretch") {
        this.ctx.drawImage(this.image, 0, 0, this.w, this.h);
      }
      else if (this.bg_display === "patch") {
        this.ctx.fillStyle = ctx.createPattern(this.image, "repeat");
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      }
      else if (this.bg_display === "center") {
        this.ctx.drawImage(this.image, (this.w-this.image.width)/2, (this.h-this.image.height)/2);
      }
    }

    // if not interact with the space
    if (!this.click) {
      // update the graphics to build its primitives
      for(var i=0, l=this.graphics.length; i<l; i++) {
        this.graphics[i].update();
      }
      
      this.primitives = [];
      // split the primitives if needed
      if (this.split) {
        for (var i=0, l=this.graphics.length; i<l; i++) {
          thisGraphics_i = this.graphics[i];

          for (var j=i+1; j<l; j++) {
            thisGraphicsNext = this.graphics[j];

            thisGraphics_i.splitFace(thisGraphicsNext);
            thisGraphicsNext.splitFace(thisGraphics_i);
          }

          this.primitives = this.primitives.concat( thisGraphics_i.primitives || [] );
        }
      }
      else {
        for (var i=0, l=this.graphics.length; i<l; i++) {
          thisGraphics_i = this.graphics[i];

          if (thisGraphics_i.split) {
            for (var j=i+1; j<l; j++) {
              thisGraphicsNext = this.graphics[j];

              if (thisGraphicsNext.split) {
                thisGraphics_i.splitFace(thisGraphicsNext);
              }
            }
          }

          this.primitives = this.primitives.concat( thisGraphics_i.primitives || [] );
        }
      }
      // end split
    }

    for(var i=0, l=this.primitives.length; i<l; i++) {
      this.primitives[i].computeDepth(this);
    }

    this.primitives = this.primitives.sort(function (a, b) { return b.depth - a.depth; });
    
    // draw the primitives
    if (this.render === "painter") {
      this.drawPainter(this.primitives);
    }
    else {
      for(var i=0, l=this.primitives.length; i<l; i++) {
        this.primitives[i].draw(this.ctx, this);
      }
    }

    // draw the graphic controls
    for (var i=0, l=this.graphicsCtr.length; i<l; i++) {
      this.graphicsCtr[i].draw();
    }
  }

  /**
   *
   */
  descartesJS.Space3D.prototype.drawPainter = function(primitives) {
    var self = this;
    var l = primitives.length;

    for (var i=0; i<l; i++) {
      primitives[i].drawn = false;
      primitives[i].draw(this.ctx, this);
    }

    var V = [];
    var drawface = [];
    var drawix = 0;
    var NC = primitives.length;
    var epsilon0 = 0.001;
    var epsilon = epsilon0;
    var NCa;
    var oneDrawn;
    var canDraw;

    while (true) {
      NCa = NC;
      oneDrawn = false;
      for (var i=0; i<l; i++) {
        if (!primitives[i].drawn) {
          canDraw = true;
          for (var j=0; j<l; j++) {
            if ( (j!=i) && 
                 (!primitives[j].drawn) && 
                 (primitives[i].inFrontOf(V, primitives[j], epsilon))
                ) {
              canDraw = false;
              break;
            }
          }
          if (canDraw) {
            NC--;
            drawface[drawix++] = primitives[i];
            primitives[i].drawn = true;
            oneDrawn = true;
          }
        }
      }
      if (NC == 0) { // PA ended CORRECTLY"
        break;
      } 
      else if (NC == NCa) { // Can't continue;
        epsilon=epsilon*10;

        if (epsilon>0.1) {
//          console.log("Error in Painter Algorithm");
          for (var i=0; i<l; i++) {
            if (!primitives[i].drawn) {
              drawface[drawix++] = primitives[i];
              primitives[i].drawn = true;
            }
          }
          break;
        }
      } 
      else {
        epsilon = epsilon0;
      }
    }

    // draw the primitives
    for (var i=0; i<l; i++) {
      drawface[i].draw(this.ctx, this);
    }
  }

  /**
   * 
   */
  descartesJS.Space3D.prototype.rayFromEye = function(x, y) {
    return {
      x: -this.eye.x,
      y: (x - (this.w_2 + this.Ox))/this.scale - this.eye.y,
      z: ((this.h_2 + this.Oy) - y)/this.scale - this.eye.z
    };
  }


//********************************************************************************************************************
//********************************************************************************************************************
//********************************************************************************************************************

  /**
   * Register the mouse and touch events
   */
  descartesJS.Space3D.prototype.addEvents = function() {
    var self = this;
    var lastTime = 0;

    this.canvas.oncontextmenu = function () { return false; };

    this.canvas.addEventListener("touchstart", onTouchStart);

    /**
     * @param {Event} evt
     * @private
     */
    function onTouchStart(evt) {
      // remove the focus of the controls
      window.focus();
      document.activeElement.blur();

      self.click = 1;
      self.evaluator.setVariable(self.id + ".mouse_pressed", 1);

      // se desactivan los controles graficos
      self.parent.deactivateGraphiControls();

      self.posAnte = descartesJS.getCursorPosition(evt, self.container);
      self.oldMouse.x = self.getRelativeX(self.posAnte.x);
      self.oldMouse.y = self.getRelativeY(self.posAnte.y);

      onSensitiveToMouseMovements(evt);

      window.addEventListener("touchmove", onMouseMove);
      window.addEventListener("touchend", onTouchEnd);

      // if ((!self.fixed) || (self.sensitive_to_mouse_movements)) {
        evt.preventDefault();
      // }
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onTouchEnd(evt) {
      // remove the focus of the controls
      window.focus();
      document.activeElement.blur();

      self.click = 0;
      self.evaluator.setVariable(self.id + ".mouse_pressed", 0);

      window.removeEventListener("touchmove", onMouseMove, false);
      window.removeEventListener("touchend", onTouchEnd, false);

      evt.preventDefault();

      self.parent.update();
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    ///////////////////////////////////////////////////////////////////////////
    this.canvas.addEventListener("mousedown", onMouseDown);

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseDown(evt) {
      // remove the focus of the controls
      document.body.focus();

      self.click = 1;

      // se desactivan los controles graficos
      self.parent.deactivateGraphiControls();

      self.whichBtn = descartesJS.whichBtn(evt);

      if (self.whichBtn === "R") {
        window.addEventListener("mouseup", onMouseUp);

        self.posObserver = (descartesJS.getCursorPosition(evt, self.container)).x;
        self.posObserverNew = self.posObserver;

        self.posZoom = (descartesJS.getCursorPosition(evt, self.container)).y;
        self.posZoomNew = self.posZoom;

        // if fixed add a zoom manager
        if (!self.fixed) {
          self.tempScale = self.scale;
          self.tempObserver = self.observer;
          window.addEventListener("mousemove", onMouseMoveZoom);
        }
      }

      else if (self.whichBtn == "L") {
        self.evaluator.setVariable(self.id + ".mouse_pressed", 1);

        self.posAnte = descartesJS.getCursorPosition(evt, self.container);
        self.oldMouse.x = self.getRelativeX(self.posAnte.x);
        self.oldMouse.y = self.getRelativeY(self.posAnte.y);

        onSensitiveToMouseMovements(evt);

        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("mouseup", onMouseUp);
      }

      evt.preventDefault();
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseUp(evt) {
      // remove the focus of the controls
      document.body.focus();

      self.click = 0;
      self.evaluator.setVariable(self.id + ".mouse_pressed", 0);
      evt.preventDefault();

      if (self.whichBtn === "R") {
        window.removeEventListener("mousemove", onMouseMoveZoom, false);

        // show the external space
        if ((self.posZoom == self.posZoomNew) && (descartesJS.showConfig)) {
          self.parent.externalSpace.show();
        }
      }

      window.removeEventListener("mousemove", onMouseMove, false);
      window.removeEventListener("mouseup", onMouseUp, false);

      self.parent.update();
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onSensitiveToMouseMovements(evt) {
      self.posAnte = descartesJS.getCursorPosition(evt, self.container);
      self.mouse_x = self.getRelativeX(self.posAnte.x);
      self.mouse_y = self.getRelativeY(self.posAnte.y);
      self.evaluator.setVariable(self.id + ".mouse_x", self.mouse_x);
      self.evaluator.setVariable(self.id + ".mouse_y", self.mouse_y);

      // limit the number of updates in the lesson
      // if (Date.now() - lastTime > 70) {
        self.parent.update();
        lastTime = Date.now();
      // }
    }

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseMoveZoom(evt) {
      evt.preventDefault();

      self.posZoomNew = (descartesJS.getCursorPosition(evt, self.container)).y;
      self.evaluator.setVariable(self.scaleStr, self.tempScale + (self.tempScale/45)*((self.posZoom-self.posZoomNew)/10));

      self.posObserverNew = (descartesJS.getCursorPosition(evt, self.container)).x;
      self.evaluator.setVariable(self.obsStr, self.tempObserver - (self.posObserver-self.posObserverNew)*2.5);

      self.parent.update();
    }

    this.disp = {x: 0, y: 0};

    /**
     *
     * @param {Event} evt
     * @private
     */
    function onMouseMove(evt) {
      if ((!self.fixed) && (self.click)) {
        dispX = (self.getAbsoluteX(self.oldMouse.x)  - self.getAbsoluteX(self.mouse_x))/4;
        dispY = (-self.getAbsoluteY(self.oldMouse.y) + self.getAbsoluteY(self.mouse_y))/4;

        if ((dispX !== self.disp.x) || (dispY !== self.disp.y)) {
          self.alpha = descartesJS.degToRad( self.evaluator.getVariable(self.rotZStr));
          self.beta  = descartesJS.degToRad(-self.evaluator.getVariable(self.rotYStr));

          self.alpha = descartesJS.radToDeg(self.alpha) - dispX;
          self.beta  = descartesJS.radToDeg(self.beta)  - dispY;

          // set the value to the rotation variables
          self.evaluator.setVariable(self.rotZStr, self.alpha);
          self.evaluator.setVariable(self.rotYStr, -self.beta);

          self.disp.x = dispX;
          self.disp.y = dispY;

          self.oldMouse.x = self.getRelativeX(self.posAnte.x);
          self.oldMouse.y = self.getRelativeY(self.posAnte.y);
        }

        onSensitiveToMouseMovements(evt);

        evt.preventDefault();
      }
    }

    /**
     * dbclick
     */
    this.canvas.addEventListener("dblclick", function(evt) {
      // self.parent.externalSpace.show();
    });
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var evaluator;
  var changeX;
  var changeY;
  var file;
  var self;
  var scrollVar;

  /**
   * Descartes IFrame space
   * @constructor 
   * @param {DescartesApp} parent the Descartes application
   * @param {String} values the values of the graphic
   */
  descartesJS.SpaceHTML_IFrame = function(parent, values) {
    // call the parent constructor
    descartesJS.Space.call(this, parent, values);

    evaluator = this.parent.evaluator;

    //
    if (this._w_ != undefined) {
      var tmpW = evaluator.parser.parse(this._w_);
      if (tmpW.type != "number") {
        this._w_ = tmpW;
      }
      else {
        this._w_ = undefined;
      }
    }
    //
    if (this._h_ != undefined) {
      var tmpH = evaluator.parser.parse(this._h_);
      if (tmpH.type != "number") {
        this._h_ = tmpH;
      }
      else {
        this._h_ = undefined;
      }
    }
    //

    // if the web browser is firefox then a problem ocurrs with a none visible iframe
    this.isFirefox = (/firefox/i).test(window.navigator.userAgent);

    this.file = (this.file) ? this.file.trim() : "";

    // if the file name is an expression
    if (this.file.match(/^\[/) && this.file.match(/\]$/)) {
      this.file = evaluator.parser.parse(this.file.substring(1, this.file.length-1));
    }
    // if the file name is a string
    else if (this.file.match(/^\'/) && this.file.match(/\'$/)) {
      this.file = evaluator.parser.parse(this.file);
    }
    // if is not an expression or a string, then is a string without single quotes
    else {
      this.file = evaluator.parser.parse("'" + this.file + "'");
    }
    
    // register the previous open file
    this.oldFile = evaluator.eval(this.file);    
    
    this.MyIFrame = document.createElement("iframe");
    if (this.oldFile != 0) {
      this.MyIFrame.setAttribute("src", this.oldFile);
    }
    this.MyIFrame.setAttribute("marginheight", 0);
    this.MyIFrame.setAttribute("marginwidth", 0);
    this.MyIFrame.setAttribute("frameborder", 0);
    this.MyIFrame.setAttribute("scrolling", "auto");
    this.MyIFrame.setAttribute("style", "position:static;left:0;top:0;");

    this.container = document.createElement("div");
    this.container.setAttribute("id", this.id);

    var strStyle = (descartesJS.isIOS) ? "overflow:scroll;-webkit-overflow-scrolling:touch;overflow-scrolling:touch;" : "";
    this.container.setAttribute("style", strStyle + "position:absolute;width:" + this.w + "px;height:" + this.h + "px;left:" + this.x + "px;top:" + this.y + "px;z-index:" + this.zIndex + ";background-repeat:no-repeat;background-position:center;");
    this.container.appendChild(this.MyIFrame);

    //
    if (this.imageSrc) {
      this.container.style.backgroundImage = "url(" + this.imageSrc +")";
    }
    //

    this.parent.container.insertBefore(this.container, this.parent.loader);

    // register the comunication functions
    var self = this;

    this.MyIFrame.onload = function(evt) {
      var iframe = this;

      // set a value to a variable
      function iframeSet(varName, value) {
        iframe.contentWindow.postMessage({ type: "set", name: varName, value: value }, "*");
        return 0;
      }      
      self.evaluator.setFunction(self.id + ".set", iframeSet);

      // update the scene
      function iframeUpdate() {
        iframe.contentWindow.postMessage({ type: "update" }, "*");
        return 0;
      }      
      self.evaluator.setFunction(self.id + ".update", iframeUpdate);
      
      // exec a funcion of the scene
      function iframeExec(functionName, functionParameters) {
        iframe.contentWindow.postMessage({ type: "exec", name: functionName, value: functionParameters }, "*");
        return 0;
      }
      self.evaluator.setFunction(self.id + ".exec", iframeExec);

      //
      function iframeChangeConfig(filename) {
        if (filename) {
          let content;

          if (descartesJS.cacheFiles[filename]) {
            content = descartesJS.cacheFiles[filename];
          }
          else {
            let embedElement = document.getElementById(filename);
            if ((embedElement) && (embedElement.type === "descartes/embed")) {
              content = embedElement.textContent;
            }
            else {
              content = descartesJS.openExternalFile(filename);
            }
            content = (new DOMParser()).parseFromString(content, "text/html").querySelector("ajs");
            content = (content) ? content.innerHTML : "";
            descartesJS.cacheFiles[filename] = content;
          }

          iframe.contentWindow.postMessage({ type: "change_config", filename:filename, content: content }, "*");
        }
        return 0;
      }
      self.evaluator.setFunction(self.id + ".changeConf", iframeChangeConfig);

      //
      self.ImReady = !self.isFirefox;
      if (!self.isFirefox) {
        self.container.style.visibility = "visible";
        self.container.style.opacity = "1";
        self.container.style.zIndex = self.zIndex;
        self.container.style.display = (self.drawIfValue) ? "block" : "none";
      }
      self.MyIFrame.style.visibility = "visible";
      self.container.style.backgroundImage = "";
    }

    this.update = this.iframeUpdate;

    // a scroll variable to determine if the scroll is show or not
    this.evaluator.setVariable(this.id + "._scroll", 0);
  }
  
  ////////////////////////////////////////////////////////////////////////////////////
  // create an inheritance of Space
  ////////////////////////////////////////////////////////////////////////////////////
  descartesJS.extend(descartesJS.SpaceHTML_IFrame, descartesJS.Space);
  
  /**
   * Init the space
   */
  descartesJS.SpaceHTML_IFrame.prototype.init = function() {
    self = this;
    
    // call the init of the parent
    // self.uber.init.call(self);
    self.initSpace();

    // update the size of the iframe if has some regions
    if (self.MyIFrame) {
      self.MyIFrame.style.width  = self.w + "px";
      self.MyIFrame.style.height = self.h + "px";
      self.MyIFrame.style.left   = self.x + "px";
      self.MyIFrame.style.top    = self.y + "px";
    }
  }

  /**
   * Update the space
   */
  descartesJS.SpaceHTML_IFrame.prototype.iframeUpdate = function(firstTime) {
    evaluator = this.evaluator;

    this.drawIfValue = evaluator.eval(this.drawif) > 0;

    if (this.ImReady) {
      this.container.style.display = (this.drawIfValue) ? "block" : "none";
    }
    else {
      this.container.style.visibility = (this.drawIfValue) ? "visible" : "hidden";
      this.container.style.opacity = (this.drawIfValue) ? "1" : "0";
      this.container.style.zIndex = (this.drawIfValue) ? this.zIndex : -1000;
    }

    if (this.drawIfValue) {
      this.MyIFrame.contentWindow.focus();

      if (firstTime) {
        this.x = Infinity;
        this.y = Infinity;
      }

      changeX = (this.x !== (evaluator.eval(this.xExpr) + this.displaceRegionWest));
      changeY = (this.y !== (evaluator.eval(this.yExpr) + this.parent.plecaHeight  + this.displaceRegionNorth));
      this.x = (changeX) ? evaluator.eval(this.xExpr) + this.displaceRegionWest : this.x;
      this.y = (changeY) ? evaluator.eval(this.yExpr) + this.parent.plecaHeight  + this.displaceRegionNorth : this.y;

      if (this._w_ != undefined) {
        var new_w = evaluator.eval(this._w_);
        if (this.w !== new_w) {
          this.container.style.width = this.MyIFrame.style.width  = new_w + "px";
          this.w = new_w;
        }
      }
      if (this._h_ != undefined) {
        var new_h = evaluator.eval(this._h_);
        if (this.h !== new_h) {
          this.container.style.height = this.MyIFrame.style.height  = new_h + "px";
          this.h = new_h;
        }
      }

      // if the position change
      if ((changeX) || (changeY)) {
        this.container.style.left = this.x + "px";
        this.container.style.top = this.y + "px";
      }

      file = evaluator.eval(this.file);
      if (file !== this.oldFile) {
        //
        this.ImReady = false;
        if (!this.isFirefox) {
          this.container.style.display = "block";
          this.container.style.visibility = (this.drawIfValue) ? "visible" : "hidden";
          this.container.style.opacity = (this.drawIfValue) ? "1" : "0";
          this.container.style.zIndex = (this.drawIfValue) ? this.zIndex : -1000;
        }
        //
        if (this.imageSrc) {
          this.container.style.backgroundImage = "url(" + this.imageSrc +")";
        }
        //
        this.MyIFrame.style.visibility = "hidden";
        this.oldFile = file;
        // prevent add history entries when the source of an iframe change
        this.MyIFrame.contentWindow.location.replace(file);
      }
     
      scrollVar = evaluator.getVariable(this.id + "._scroll");
      
      if (scrollVar == 1) {
        this.MyIFrame.setAttribute("scrolling", "yes");
        this.MyIFrame.style.overflow = "";
      }
      else if (scrollVar == -1) {
        this.MyIFrame.setAttribute("scrolling", "no");
        this.MyIFrame.style.overflow = "hidden";
      }
      else {
        this.MyIFrame.setAttribute("scrolling", "auto");
        this.MyIFrame.style.overflow = "";
      }
    }
    else {
      // remove focus of the iframe
      this.MyIFrame.contentWindow.blur();
    }
  }
  
  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var scale = 1;
  var original_scale = 1.3;
  var original_w = 880;
  var original_h = 840;
  var barWidth = 726;
  var barHeight = 14;


  /**
   * Descartes loader
   * @constructor
   * @param {<applet>} applet the applet to interpret
   */
  descartesJS.DescartesLoader = function(descartesApp) {
    var self = this;

    this.children = descartesApp.children;
    this.lessonParser = descartesApp.lessonParser;
    this.images = descartesApp.images;
    this.images.length = descartesApp.images.length;
    this.audios = descartesApp.audios;
    this.audios.length = descartesApp.audios.length;
    this.descartesApp = descartesApp;

    this.imgLoader = document.createElement("div");
    this.imgLoader.setAttribute("class", "DescartesLoaderImage")

    this.progress = document.createElement("progress");
    this.progress.setAttribute("class", "PBL");
    this.progress.setAttribute("value", 0);
    this.progress.setAttribute("max", 100);

    // has a value in the parameter image_loader
    if (descartesApp.imgLoader) {
      // this.imgLoader.setAttribute("style", "background-image:url(" + descartesApp.imgLoader + ");background-size:contain;width:" + descartesApp.width + "px;height:" + descartesApp.height + "px;");
      this.imgLoader.setAttribute("style", "background-image:url(" + descartesApp.imgLoader + ");background-size:contain;");
    }
    else {
      scale = (descartesApp.width < descartesApp.height) ? (descartesApp.width/(original_w*original_scale)) : (descartesApp.height/(original_h*original_scale));
      scale = (scale > 2.5) ? 2.5 : scale;

      // this.imgLoader.setAttribute("style", "background-image:url(" + descartesJS.loaderImg.src + ");background-position:50% 33.5%;background-size:"+ (original_w*scale) +"px;width:" + descartesApp.width + "px;height:" + descartesApp.height + "px;");
      this.imgLoader.setAttribute("style", "background-image:url(" + descartesJS.loaderImg.src + ");background-position:50% 33.5%;background-size:"+ (original_w*scale) +"px;");

      this.progress.setAttribute("style", "visibility:visible; left:"+ ((descartesApp.width-barWidth*scale)/2) +"px; top:"+ ( descartesApp.height*33.5/100 + (original_h+100)*scale/2 ) +"px; width:"+ (barWidth*scale) +"px; height:"+ (barHeight*scale) +"px;");
    }

    descartesApp.loader.appendChild(this.imgLoader);
    descartesApp.loader.appendChild(this.progress);

    descartesApp.firstRun = false;

    this.initPreloader();
  }

  /**
   * Init the preload of images and audios
   */
  descartesJS.DescartesLoader.prototype.initPreloader = function() {
    var children = this.children;
    var images = this.images;
    var audios = this.audios;
    var regExpImage = /[\w\.\-//]*(\.png|\.jpg|\.gif|\.svg)/gi;
    var regExpAudio = /[\w\.\-//]*(\.ogg|\.oga|\.mp3|\.wav)/gi;

    // add the license image for arquimedes lessons
    var licenceFile = "lib/DescartesCCLicense.png";
    images[licenceFile] = descartesJS.getCCLImg();
    images[licenceFile].addEventListener('load', function() { this.ready = 1; });
    images[licenceFile].addEventListener('error', function() { this.errorload = 1; });

    var imageFilename;
    var imageTmp;
    var audioFilename;
    var i, j, l, il, al;
    // check all children in the applet
    for (i=0, l=children.length; i<l; i++) {
      if (children[i].name === "rtf") {
        continue;
      }

      // macro patch, search images inside the macro
      if (children[i].value.match(/'macro'|'makro'/g)) {
        var filename = "";
        var response;

        var values = this.lessonParser.split(children[i].value);
        for (var v_i=0, v_l=values.length; v_i<v_l; v_i++) {
          if (babel[values[v_i][0]] === "expresion") {
            filename = values[v_i][1];
          }
        }

        if (filename) {
          // the macro is embeded in the webpage
          var macroElement = document.getElementById(filename);

          if ((macroElement) && (macroElement.type == "descartes/macro")) {
            response = macroElement.text;
          }
          // the macro is in an external file
          else {
            response = descartesJS.openExternalFile(filename);
          }
        }

        if (response) {
          imageFilename = response.match(regExpImage);
          if (imageFilename) {
            for (j=0, il=imageFilename.length; j<il; j++) {
              imageTmp = imageFilename[j];

              // if the filename is not VACIO.GIF or vacio.gif
              if (!(imageTmp.toLowerCase().match(/vacio.gif$/)) && ((imageTmp.substring(0, imageTmp.length-4)) != "") ) {
                images[imageTmp] = new Image();
                images[imageTmp].addEventListener('load', function() { this.ready = 1; });
                images[imageTmp].addEventListener('error', function() { this.errorload = 1; });
                images[imageTmp].src = imageTmp;
              }
            }
          }
        }
      }
      // macro patch

      // check if the children has an image filename
      imageFilename = (children[i].value).match(regExpImage);

      // if imageFilename has a match then add the images
      if (imageFilename) {
        for (j=0, il=imageFilename.length; j<il; j++) {
          imageTmp = imageFilename[j];

          // if the filename is not VACIO.GIF or vacio.gif
          if (!(imageTmp.toLowerCase().match(/vacio.gif$/)) && ((imageTmp.substring(0, imageTmp.length-4)) != "") ) {
            images[imageTmp] = new Image();
            images[imageTmp].addEventListener('load', function() { this.ready = 1; });
            images[imageTmp].addEventListener('error', function() { this.errorload = 1; });
            images[imageTmp].src = imageTmp;
          }
        }
      }

      // check if the children has an audio filename
      audioFilename = (children[i].value).match(regExpAudio);

      // if audioFilename has a match then add the audios
      if (audioFilename) {
        for (j=0, al=audioFilename.length; j<al; j++) {
          this.initAudio(audioFilename[j]);
        }
      }
    }

    // count how many images
    for (var propName in images) {
      if (images.hasOwnProperty(propName)) {
        this.images.length++;
      }
    }

    // count how many audios
    for (var propName in audios) {
      if (audios.hasOwnProperty(propName)) {
        this.audios.length++;
      }
    }

    var self = this;
    var total = this.images.length + this.audios.length;
    if (total > 0) {
      this.progress.setAttribute("max", total);
    }

    /**
     * Function that checks if all the media are loaded
     */
    var checkLoader = function() {
      self.readys = 0;

      // how many images are loaded
      for (var propName in images) {
        if (images.hasOwnProperty(propName)) {
          if ( (images[propName].ready) || (images[propName].errorload) ) {
            self.readys++;
          }
        }
      }

      // how many audios are loaded
      for (var propName in audios) {
        if (audios.hasOwnProperty(propName)) {
          if ( (audios[propName].ready) || (audios[propName].errorload) ) {
            self.readys++;
          }
        }
      }

      // update the progress bar
      self.progress.setAttribute("value", self.readys);

      // if the number of count elements is different to the total then execute again checkLoader
      if (self.readys != total) {
        descartesJS.setTimeout(checkLoader, 1);
      }
      // if the number of count elements is equal to the total, then clear the timer and init the build of the app
      else {
        descartesJS.clearInterval(self.timer);
        self.descartesApp.initBuildApp();
      }
    }

    // first execution of checkLoader
    checkLoader();
  }

  /**
   * Add a new audio to the array of audios
   * @param {String} file the filename of the new audio
   */
  descartesJS.DescartesLoader.prototype.initAudio = function(file) {
    var audios = this.audios;

    audios[file] = new Audio(file);
    audios[file].filename = file;

    var onCanPlayThrough = function() {
      this.ready = 1;
    }

    var onError = function() {
      if (!this.canPlayType("audio/" + this.filename.substring(this.filename.length-3)) && (this.filename.substring(this.filename.length-3) == "mp3")) {
        audios[file] = new Audio(this.filename.replace("mp3", "ogg"));
        audios[file].filename = this.filename.replace("mp3", "ogg");
        audios[file].addEventListener('canplaythrough', onCanPlayThrough);
        audios[file].addEventListener('load', onCanPlayThrough);
        audios[file].addEventListener('error', onError);
        audios[file].load();
      }
      else {
        console.log("El archivo '" + file + "' no puede ser reproducido");
        this.errorload = 1;
      }
    }
    audios[file].addEventListener('canplaythrough', onCanPlayThrough);
    audios[file].addEventListener('load', onCanPlayThrough);
    audios[file].addEventListener('error', onError);

    if (descartesJS.hasTouchSupport) {
      audios[file].load();
      audios[file].play();
      descartesJS.setTimeout( function(){
        // console.log("detenido");
        audios[file].pause();
      }, 20);
      audios[file].ready = 1;
    } else {
      audios[file].load();
    }
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  var tmpVal;
  var scaleToFitX;
  var scaleToFitY;
  var optimalRatio;
  
  var licenseA = "{\\rtf1\\uc0{\\fonttbl\\f0\\fcharset0 Arial;}"+
                 "{\\f0\\fs34 __________________________________________________________________________________\\par \\fs22 "+
                 "                                       Los contenidos de esta unidad did\u00e1ctica interactiva est\u00e1n bajo una {\\*\\hyperlink licencia Creative Commons|http://creativecommons.org/licenses/by-nc-sa/4.0/}, si no se indica lo contrario.\\par "+
                 "                                       La unidad did\u00e1ctica fue creada con Arqu\u00edmedes, que es un producto de c\u00f3digo abierto, {\\*\\hyperlink Creditos|http://arquimedes.matem.unam.mx/Descartes5/creditos/conCCL.html}\\par "+
                 "}";

  /**
   * Descartes application interpreted with JavaScript
   * @constructor
   * @param {<applet>} applet the applet to interpret
   */
  descartesJS.DescartesApp = function(applet) {
    this.animation = { playing:false, play:function(){}, stop:function(){},  reinit:function(){} };

    this.ratio = descartesJS._ratio;

    /**
     * applet code
     * @type {<applet>}
     * @private
     */
    this.applet = applet;

    /**
     * container of the java applet
     * @type {<HTMLelement>}
     * @private
     */
    this.parentC = applet.parentNode;

    /**
     * width of the applet
     * @type {Number}
     * @private
     */
    this.width = parseFloat( applet.getAttribute("width") );

    /**
     * height of the applet
     * @type {Number}
     * @private
     */
    this.height = parseFloat( applet.getAttribute("height") );

    /**
     * decimal symbol
     * @type {String}
     * @private
     */
    this.decimal_symbol = ".";
    this.decimal_symbol_regexp = new RegExp("\\.", "g");

    /**
     * language of the lesson
     * type {String}
     * @private
     */
    this.language = "espa\u00F1ol";

    /**
     * parameters of the applet
     * type {Array.<param>}
     * @private
     */
    this.children = applet.getElementsByTagName("param");

    // set the license attribute
    descartesJS.ccLicense = true;
    for (var i=0,l=this.children.length; i<l; i++) {
      if (this.children[i].name === "CreativeCommonsLicense") {
        descartesJS.ccLicense = !(this.children[i].value === "no");
      }
    }

    /**
     * string that determines what kind of descartes lesson is
     * @type {String}
     * @private
     */
    this.code = applet.getAttribute("code");

    /**
     *
     */
    this.saveState = [];

    /**
     * images used in the applet
     * type {Array.<Image>}
     * @private
     */
    this.images = { length: -1 };

    /**
     * audios used in the applet
     * type {Array.<Audio>}
     * @private
     */
    this.audios = { length: -1 };

    /**
     * variable to record if the applet is interpreted for the first time, used to show the loader screen
     * type {Boolean}
     * @private
     */
    this.firstRun = true;

    // function to prevent undefined error
    this.scaleToFit = function() {};

    // init the interpretation
    this.init()
  }

  /**
   * Init the variables needed for parsing and create the descartes scene
   */
  descartesJS.DescartesApp.prototype.init = function() {
    // stop the animation, if the action init executes maybe the animation is playing
    this.stop();

    /**
     * evaluator and parser of expressions
     * type {Evaluator}
     * @private
     */
    this.evaluator = new descartesJS.Evaluator(this);

    // get the url paremeter if any
    this.getURLParameters();

    /**
     * parser of elements in the lesson
     * @type {LessonParser}
     * @private
     */
    this.lessonParser = new descartesJS.LessonParser(this);

    /**
     * variable that tell whether the lesson is an arquimedes lesson
     * type {Boolean}
     * @private
     */
    this.arquimedes = (/DescartesWeb2_0|Arquimedes|Discurso/i).test(this.code);

    // licences for arquimedes
    this.licenseA = (descartesJS.ccLicense) ? licenseA : "";

    var children = this.children;
    var children_i;
    var heightRTF = 0;
    var heightButtons = 0;
    var licenceHeight = (descartesJS.ccLicense) ? 90 : 0;

    for (var i=0, l=children.length; i<l; i++) {
      children_i = children[i];

      // get the rtf height
      if (children_i.name == "rtf_height") {
        heightRTF = parseInt(children_i.value) || this.height;
      }

      // get the buttons height
      if (babel[children_i.name] == "Buttons") {
        this.buttonsConfig = this.lessonParser.parseButtonsConfig(children_i.value);
        heightButtons = this.buttonsConfig.height;
      }

      // get image source for the loader
      if (children_i.name == "image_loader") {
        this.imgLoader = children_i.value;
      }

      // get the cover of the scene
      if (children_i.name == "expand") {
        if (children_i.value == "cover") {
          this.expand = children_i.value;
        }
        else if (children_i.value == "fit") {
          this.scaleToFit = scaleToFit;
        }
      }

      // set the docBase for the elements in the resources
      if (children_i.name == "docBase") {
        this.docBase = children_i.value;
        var base = document.createElement("base");
        base.setAttribute("id", "descartesJS_base");
        base.setAttribute("href", this.docBase);
        document.head.appendChild(base);
      }
    }

    // cover space
    if (this.expand) {
      if (this.expand == "cover") {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
      }
    }

    // configure an arquimedes lesson
    if (this.arquimedes) {
      this.ratio = 1;
      // modify the lesson height if has rtf height parameter
      if (heightRTF) {
        this.height =  heightRTF + heightButtons + licenceHeight; // 70 is the height of the licence image
      }
    }

    /**
     * array to store the lesson spaces
     * type {Array.<Space>}
     * @private
     */
    this.spaces = [];

    /**
     * external region
     * type {Space}
     * @private
     */
    if (this.externalSpace) {
      document.body.removeChild(this.externalSpace.container);
    }
    this.externalSpace = new descartesJS.SpaceExternal(this);

    /**
     * north region
     * type {Space}
     * @private
     */
    this.northSpace = {container: document.createElement("div"), controls: []};

    /**
     * south region
     * type {Space}
     * @private
     */
    this.southSpace = {container: document.createElement("div"), controls: []};

    /**
     * east region
     * type {Space}
     * @private
     */
    this.eastSpace = {container: document.createElement("div"), controls: []};

    /**
     * west region
     * type {Space}
     * @private
     */
    this.westSpace = {container: document.createElement("div"), controls: []};

    /**
     * region to show text fields for editable content
     * type {Space}
     * @private
     */
    this.editableRegion = {container: document.createElement("div"), textFields: []};

    /**
     *
     */
    if (descartesJS.Editor) { this.editor = new descartesJS.Editor(this); }

    /**
     * array to store the lesson controls
     * type {Array.<Control>}
     * @private
     */
    this.controls = [];

    /**
     * array to store the lesson auxiliaries
     * type {Array.<Auxiliary>}
     * @private
     */
    this.auxiliaries = [];

    /**
     * array to store the lesson events
     * type {Array.<Event>}
     * @private
     */
    this.events = [];

    /**
     * the z index for order the graphics
     * @type {Number}
     * @private
     */
    this.zIndex = 0;

    /**
     * tabulation index for the text fields
     * @type {Number}
     * @private
     */
    this.tabindex = 0;

    /**
     * pleca height
     * @type {Number}
     * @private
     */
    this.plecaHeight = 0;

    /**
     * number of iframes in the lesson
     * @type {Number}
     * @private
     */
    this.nIframes = 0;

    // code needed for reinit the lesson
    if (this.container != undefined) {
      this.parentC.removeChild(this.container);
    }

    this.container = document.createElement("div");
    this.loader = document.createElement("div");

    // append the lesson container to the java applet container
    // this.parentC.appendChild(this.container);
    this.parentC.insertBefore(this.container, this.parentC.firstChild);
    this.container.width = this.width;
    this.container.height = this.height;
    this.container.setAttribute("class", "DescartesAppContainer");
    this.container.setAttribute("style", "width:" + this.width + "px;height:" + this.height + "px;");

    //
    this.scaleToFit();
    //

    // add the loader
    this.container.appendChild(this.loader);
    this.loader.width = this.width;
    this.loader.height = this.height;
    this.loader.setAttribute("class", "DescartesLoader");
    this.loader.setAttribute("style", "width:" + this.width + "px;height:" + this.height + "px;z-index:1000;");

    // if have an image, the background is transparent
    if (this.imgLoader) {
      this.loader.style.backgroundColor = "rgba(0,0,0,0)";
    }

    // first run
    if (this.firstRun) {
      this.descartesLoader = new descartesJS.DescartesLoader(this);
    } else {
      this.initBuildApp();
    }
  }

  /**
   * Init the parsing and creation of objects for the descartes lesson
   */
  descartesJS.DescartesApp.prototype.initBuildApp = function() {
    descartesJS.showConfig = true;

    var children = this.children;
    var children_i;
    var lessonParser = this.lessonParser;

    var tmpSpaces = [];
    var tmpControls = [];
    var tmpAuxiliaries = [];
    var tmpGraphics = [];
    var tmp3DGraphics = [];
    var tmpAnimations = [];

    // check all the children
    for(var i=0, l=children.length; i<l; i++) {
      children_i = children[i];

      // find if the scene is editable
      if (babel[children_i.name] == "editable") {
        descartesJS.showConfig = (babel[children_i.value] == 'false') ? false : true;
        continue;
      }

      // find the language of the lesson
      if (babel[children_i.name] == "language") {
        this.language = children_i.value;
        continue;
      }

      // find the parameters for the pleca
      if (children_i.name == "pleca") {
        var divPleca = lessonParser.parsePleca(children_i.value, this.width);
        this.container.insertBefore(divPleca, this.loader);
        this.plecaHeight = (divPleca.imageHeight) ? divPleca.imageHeight : divPleca.offsetHeight;
        continue;
      }

      // find the parameters for the exterior space
      if (babel[children_i.name] == "Buttons") {
        this.buttonsConfig = lessonParser.parseButtonsConfig(children_i.value);
        continue;
      }

      // find the decimal symbol
      if (babel[children_i.name] == "decimal_symbol") {
        this.decimal_symbol = children_i.value;
        this.decimal_symbol_regexp = new RegExp("\\" + this.decimal_symbol, "g");
        continue;
      }

      // find the descartes version
      if (babel[children_i.name] == "version") {
        this.version = parseInt(children_i.value);
        continue;
      }

      // find the language of the lesson
      if (babel[children_i.name] == "language") {
        this.language = children_i.value;
        continue;
      }

      // ##ARQUIMEDES## //
      // find the rtf text of an arquimedes lesson
      if (children_i.name == "rtf") {
        var posX = (this.width-780)/2;
        var posY = (parseInt(this.height) -this.plecaHeight -this.buttonsConfig.height -45);

        tmpGraphics.push("space='descartesJS_stage' type='text' expresion='[10,20]' background='yes' text='" + children_i.value.replace(/'/g, "&squot;") + "'");
        tmpGraphics.push("space='descartesJS_stage' type='text' expresion='[" + posX + "," + (posY-25) + "]' background='yes' text='" + this.licenseA + "'");
        if (descartesJS.ccLicense) {
          tmpGraphics.push("space='descartesJS_stage' type='image' expresion='[" + (posX+15) + "," + posY + "]' background='yes' abs_coord='yes' file='lib/DescartesCCLicense.png'");
        }

        continue;
      }
      // ##ARQUIMEDES## //

      // if the name of the children start with "E" then is a space
      if (children_i.name.charAt(0) == "E") {
        if (children_i.value.match(/'HTMLIFrame'/)) {
          this.nIframes++;
        }

        tmpSpaces.push(children_i.value);
        continue;
      }

      // if the name of the children start with "C_" then is a control
      if ((/^C_/).test(children_i.name)) {
        tmpControls.push(children_i.value);
        continue;
      }

      // if the name of the children start with "A_" then is an auxiliary
      if ((/^A_/).test(children_i.name)) {
        tmpAuxiliaries.push(children_i.value);
        continue;
      }

      // if the name of the children start with "G" then is a graphic
      if ((/^G_/).test(children_i.name)) {
        // prevenir usar un canvas pseudo retina
        if (children_i.value.match(/type='fill'|tipo='relleno'|tipus='ple'|mota='betea'|type='plein'|tipo='recheo'|tipo='curva_piena'|tipo='preencher'|tipus='ple'/)) {
          this.ratio = 1;
        }
        tmpGraphics.push(children_i.value);
        continue;
      }

      // if the name of the children start with "S" then is a tridimensional graphic
      if ((/^S_/).test(children_i.name)) {
        tmp3DGraphics.push(children_i.value);
        continue;
      }

      // if the name of the children is "Animation" then is an animation
      if (babel[children_i.name] == "Animation") {
        tmpAnimations.push(children_i.value);
        continue;
      }
    }

    // the scenario region is only visible in arquimedes lessons
    this.stage = {container: document.createElement("div"), scroll: 0};
    this.stage.container.setAttribute("id", "descartesJS_Stage");

    // if descartesJS.TextController exist then make trasparent the color of the canvas, because the selection canvas is white
    this.stage.stageSpace = this.lessonParser.parseSpace("tipo='R2' id='descartesJS_stage' fondo='" + ((descartesJS.TextController) ? "ffffffff" : "blanco") +"' x='0' y='0' fijo='yes' red='no' red10='no' ejes='no' text='no' ancho='" + this.width + "' alto='" + this.height + "'");
    this.stage.container.appendChild(this.stage.stageSpace.container);

    // ##ARQUIMEDES## //
    // if arquimedes then add the container of the scenario region
    if (this.arquimedes) {
      this.container.appendChild(this.stage.container);
      this.spaces.push(this.stage.stageSpace);
    }
    // ##ARQUIMEDES## //

    // init the spaces
    var tmpSpace;
    for (var i=0, l=tmpSpaces.length; i<l; i++) {
      tmpSpace = lessonParser.parseSpace(tmpSpaces[i]);

      // ##ARQUIMEDES## //
      if (this.arquimedes) {
        this.stage.container.appendChild(tmpSpace.container);
      }
      // ##ARQUIMEDES## //

      // create and add a space to the list of spaces
      this.spaces.push(tmpSpace);

      // increase the z index for the next space is placed on the above space
      this.zIndex++;
    }

    // init the graphics
    var tmpGraph;
    for (var i=0, l=tmpGraphics.length; i<l; i++) {
      descartesJS.DEBUG.elemIndex = i;
      tmpGraph = lessonParser.parseGraphic(tmpGraphics[i]);
      if (tmpGraph) {
        this.editableRegionVisible = this.editableRegionVisible || (tmpGraph.visible);
        tmpGraph.space.addGraph(tmpGraph);
      }
    }

    // init the tridimensional graphics
    var tmp3DGraph;
    for (var i=0, l=tmp3DGraphics.length; i<l; i++) {
      tmpGraph = lessonParser.parse3DGraphic(tmp3DGraphics[i]);
      if (tmpGraph) {
        tmpGraph.space.addGraph(tmpGraph, true);
      }
    }

    // init the controls
    for (var i=0, l=tmpControls.length; i<l; i++) {
      this.controls.push( lessonParser.parseControl(tmpControls[i]) );
    }

    // init the auxiliary
    for (var i=0, l=tmpAuxiliaries.length; i<l; i++) {
      lessonParser.parseAuxiliar(tmpAuxiliaries[i]);
    }

    // init the animation
    for (var i=0, l=tmpAnimations.length; i<l; i++) {
      this.animation = lessonParser.parseAnimation(tmpAnimations[i]);
    }

    // configure the regions
    this.configRegions();

    this.updateAuxiliaries();
    // beware
    this.updateAuxiliaries();
    // beware

    for (var i=0, l=this.controls.length; i<l; i++) {
      this.controls[i].init();
    }
    this.updateControls();

    this.updateSpaces(true);

    // finish the interpretation
    var self = this;
    if (this.nIframes) {
      descartesJS.setTimeout(function() { self.finishInit(); }, 200*this.nIframes);
    }
    else {
      this.finishInit();
    }
  }

  /**
   * Finish the interpretation
   */
  descartesJS.DescartesApp.prototype.finishInit = function() {
    this.evaluator.setVariable("decimalSymbol", this.decimal_symbol);
    this.update();

    // hide the loader
    this.loader.style.display = "none";

    // if the window parent is diferente from the current window, then is embedded in an iFrame
    if (window.parent !== window) {
      this.parentC.style.margin = "0px";
      this.parentC.style.padding = "0px";

      window.parent.postMessage({ type: "reportSize", href: window.location.href, width: this.width, height: this.height }, '*');
      window.parent.postMessage({ type: "ready", value: window.location.href }, '*');

      descartesJS.onResize();
    }

    // scene open in a new window
    if (window.opener) {
      window.opener.postMessage({ type: "isResizeNeeded", href: window.location.href }, '*');
    }

    this.externalSpace.init();

    // trigger descartesReady event
    var evt;
    try {
        // custom event for majority of browsers
        evt = new CustomEvent("descartesReady", { "detail":this });
    }
    catch(e) {
      console.warn("CustomEvents not supported in this browser");
        // custom event for ie
        // evt = document.createEvent("CustomEvent");
        // evt.initCustomEvent("descartesReady", false, false, { "cmd":this });
    }
    // send the event
    window.dispatchEvent(evt);

    this.readyApp = true;
  }

  /**
   * Adjust the size of the window if needed
   */
  descartesJS.DescartesApp.prototype.adjustSize = function() {
    document.body.style.margin = document.body.style.padding = this.parentC.style.margin = this.parentC.style.padding = "0px";
    var winWidth = parseInt(this.width)+30;
    var winHeight = parseInt(this.height)+90;

    window.moveTo((parseInt(screen.width)-winWidth)/2, (parseInt(screen.height)-winHeight)/2);
    window.resizeTo(winWidth, winHeight);

    descartesJS.onResize();
  }

  /**
   *
   */
  descartesJS.DescartesApp.prototype.adjustDimensions = function() {
    var appletsAJS_i = this;
    var init_w;
    var w;
    var percent;

    if ((appletsAJS_i.init_w == undefined) || (appletsAJS_i.init_h == undefined)) {
      appletsAJS_i.init_w = parseInt( appletsAJS_i.container.style.width );
      appletsAJS_i.init_h = parseInt( appletsAJS_i.container.style.height );
    }

    w = parseInt(appletsAJS_i.parentC.offsetWidth);
    init_w = appletsAJS_i.init_w;
    percent = w/init_w;

    if (init_w > w) {
      if (appletsAJS_i.parentC != document.body) {
        appletsAJS_i.parentC.style.height = appletsAJS_i.init_h*percent + "px";
      }
      appletsAJS_i.percent = percent;
      appletsAJS_i.container.style.webkitTransform = appletsAJS_i.container.style.MozTransform = "scale(" +percent+ ")";
      appletsAJS_i.container.style.webkitTransformOrigin = appletsAJS_i.container.style.MozTransformOrigin = "top left";
    }
    else {
      if (appletsAJS_i.parentC != document.body) {
        appletsAJS_i.parentC.style.height = "auto";
      }
      appletsAJS_i.percent = 1;

      appletsAJS_i.container.style.webkitTransform = appletsAJS_i.container.style.MozTransform = "";
      appletsAJS_i.container.style.webkitTransformOrigin = appletsAJS_i.container.style.MozTransformOrigin = "";
    }
  }

  /**
   * Configure the regions
   */
  descartesJS.DescartesApp.prototype.configRegions = function() {
    var parser = this.evaluator.parser;
    var buttonsConfig = this.buttonsConfig;
    var principalContainer = this.container;

    // descartes 4
    var fontSizeDefaultButtons = "15";
    var aboutWidth = configWidth = initWidth = clearWidth = 100;

    // descartes 2
    if (this.version == 2) {
      fontSizeDefaultButtons = "14";
      aboutWidth = 63;
      configWidth = 50;
      initWidth = 44;
      clearWidth = 53;
    }

    var northRegionHeight = southRegionHeight = eastRegionHeight = westRegionHeight = editableRegionHeight = northRegionWidht = southRegionWidht = eastRegionWidth = westRegionWidth = 0;

    var northSpaceControls = this.northSpace.controls;
    var southSpaceControls = this.southSpace.controls;
    var eastSpaceControls = this.eastSpace.controls;
    var westSpaceControls = this.westSpace.controls;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // north region
    if ((buttonsConfig.rowsNorth > 0) || ( northSpaceControls.length > 0) || (buttonsConfig.about) || (buttonsConfig.config)) {
      // if the number of rows is zero but contains controls then the height is the specified height
      if (buttonsConfig.rowsNorth <= 0) {
        northRegionHeight = buttonsConfig.height;
        buttonsConfig.rowsNorth = 1;
      }
      // if the number of rows is diferent of zero then the height is the number of rows
      else {
        northRegionHeight = buttonsConfig.height * buttonsConfig.rowsNorth;
      }

      var container = this.northSpace.container;
      container.setAttribute("id", "descartesJS_north");
      container.setAttribute("style", "width:" + principalContainer.width + "px;height:" + northRegionHeight + "px;background:#c0c0c0;position:absolute;left:0px;top:" + this.plecaHeight + "px;z-index:100;");

      principalContainer.insertBefore(container, this.loader);

      northRegionWidht = principalContainer.width;
      var displaceButton = 0;

      // show the credits button
      if (buttonsConfig.about) {
        displaceButton = aboutWidth;
        northRegionWidht -= displaceButton;
      }
      else {
        aboutWidth = 0;
      }
      // show the configuration button
      if (buttonsConfig.config) {
        northRegionWidht -= configWidth;
      }

      var numberOfControlsPerRow = Math.ceil(northSpaceControls.length / buttonsConfig.rowsNorth);
      var controlWidth = northRegionWidht/numberOfControlsPerRow;

      // configure the controls in the region
      for (var i=0, l=northSpaceControls.length; i<l; i++) {
        northSpaceControls[i].expresion = parser.parse("(" + (displaceButton +controlWidth*(i%numberOfControlsPerRow)) +"," + (buttonsConfig.height*Math.floor(i/numberOfControlsPerRow)) + "," + controlWidth + "," + buttonsConfig.height +")");
        northSpaceControls[i].drawif = parser.parse("1");
        northSpaceControls[i].init();
      }

      // create the credits button
      if (buttonsConfig.about) {
        var btnAbout = new descartesJS.Button(this, {region: "north",
                                                     name: (this.language == "english") ? "about" : "cr\u00E9ditos",
                                                     font_size: parser.parse(fontSizeDefaultButtons),
                                                     expresion: parser.parse("(0, 0, " + aboutWidth + ", " + northRegionHeight + ")")
                                                    });
        btnAbout.actionExec = { execute: descartesJS.showAbout };
        btnAbout.update();
      }
      // create the configuration button
      if (buttonsConfig.config) {
        var btnConfig = new descartesJS.Button(this, {region: "north",
                                                      name: "config",
                                                      font_size: parser.parse(fontSizeDefaultButtons),
                                                      action: "config",
                                                      expresion: parser.parse("(" + (northRegionWidht + aboutWidth)  + ", 0, " + configWidth + ", " + northRegionHeight + ")")
                                                     });
        btnConfig.update();
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // south region
    if ((buttonsConfig.rowsSouth > 0) || (southSpaceControls.length > 0) || (buttonsConfig.init) || (buttonsConfig.clear)) {
      // if the number of rows is zero but contains controls then the height is the specified height
      if (buttonsConfig.rowsSouth <= 0) {
        southRegionHeight = buttonsConfig.height;
        buttonsConfig.rowsSouth = 1;
      }
      // if the number of rows is diferent of zero then the height is the number of rows
      else {
        southRegionHeight = buttonsConfig.height * buttonsConfig.rowsSouth;
      }

      southRegionWidht = principalContainer.width;
      var displaceButton = 0;
      // show the init button
      if (buttonsConfig.init) {
        displaceButton = initWidth;
        southRegionWidht -= displaceButton;
      }
      else {
        initWidth = 0;
      }
      // show the clear button
      if (buttonsConfig.clear) {
        southRegionWidht -= clearWidth;
      }

      var container = this.southSpace.container;
      container.setAttribute("id", "descartesJS_south");
      container.setAttribute("style", "width:" + principalContainer.width + "px;height:" + southRegionHeight + "px;background:#c0c0c0;position:absolute;left:0px;top:" + (principalContainer.height-southRegionHeight) + "px;z-index:100;");

      principalContainer.insertBefore(container, this.loader);

      var numberOfControlsPerRow = Math.ceil(southSpaceControls.length / buttonsConfig.rowsSouth);
      var controlWidth = southRegionWidht/numberOfControlsPerRow;

      // configure the controls in the region
      for (var i=0, l=southSpaceControls.length; i<l; i++) {
        southSpaceControls[i].expresion = parser.parse("(" + (displaceButton + controlWidth*(i%numberOfControlsPerRow)) +"," + (buttonsConfig.height*Math.floor(i/numberOfControlsPerRow)) + "," + controlWidth + "," + buttonsConfig.height +")");
        southSpaceControls[i].drawif = parser.parse("1");
        southSpaceControls[i].init();
      }

      // create the init button
      if (buttonsConfig.init) {
        var btnInit = new descartesJS.Button(this, {region: "south",
                                                    name: (this.language == "english") ? "init" : "inicio",
                                                    font_size: parser.parse(fontSizeDefaultButtons),
                                                    action: "init",
                                                    expresion: parser.parse("(0, 0, " + initWidth + ", " + southRegionHeight + ")")
                                                  });
        btnInit.update();
      }
      // create the clear button
      if (buttonsConfig.clear) {
        var btnClear = new descartesJS.Button(this, {region: "south",
                                                     name: (this.language == "english") ? "clear" : "limpiar",
                                                     font_size: parser.parse(fontSizeDefaultButtons),
                                                     action: "clear",
                                                     expresion: parser.parse("(" + (southRegionWidht + initWidth) + ", 0, " + clearWidth + ", " + southRegionHeight + ")")
                                                     });
        btnClear.update();
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // east region
    if (eastSpaceControls.length > 0) {
      eastRegionHeight = principalContainer.height - northRegionHeight - southRegionHeight;
      eastRegionWidth = buttonsConfig.widthEast;

      var container = this.eastSpace.container;
      container.setAttribute("id", "descartesJS_east");
      container.setAttribute("style", "width:" + eastRegionWidth + "px;height:" + eastRegionHeight + "px;background:#c0c0c0;position:absolute;left:" + (principalContainer.width - eastRegionWidth) + "px;top:" + northRegionHeight + "px;z-index:100;");

      principalContainer.insertBefore(container, this.loader);

      // configure the controls in the region
      for (var i=0, l=eastSpaceControls.length; i<l; i++) {
        eastSpaceControls[i].expresion = parser.parse("(0," + (buttonsConfig.height*i) + "," + eastRegionWidth + "," + buttonsConfig.height +")");
        eastSpaceControls[i].drawif = parser.parse("1");
        eastSpaceControls[i].init();
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // west region
    if (westSpaceControls.length > 0) {
      westRegionHeight = principalContainer.height - northRegionHeight - southRegionHeight;
      westRegionWidth = buttonsConfig.widthWest;

      var container = this.westSpace.container;
      container.setAttribute("id", "descartesJS_west");
      container.setAttribute("style", "width: " + westRegionWidth + "px;height:" + westRegionHeight + "px;background:#c0c0c0;position:absolute;left:0px;top:" + northRegionHeight + "px;z-index:100;");

      principalContainer.insertBefore(container, this.loader);

      // configure the controls in the region
      for (var i=0, l=westSpaceControls.length; i<l; i++) {
        westSpaceControls[i].expresion = parser.parse("(0," + (buttonsConfig.height*i) + "," + westRegionWidth + "," + buttonsConfig.height +")");
        westSpaceControls[i].drawif = parser.parse("1");
        westSpaceControls[i].init();
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // editable and visible region
    if (this.editableRegionVisible) {
      editableRegionHeight = buttonsConfig.height;
      var container = this.editableRegion.container;
      container.setAttribute("id", "descartesJS_editableRegion");
      container.setAttribute("style", "width:" + principalContainer.width + "px;height:" + editableRegionHeight + "px;position:absolute;left:0px;top:" + (principalContainer.height - southRegionHeight - buttonsConfig.height) + "px;z-index:100;background:#c0c0c0;overflow:hidden;");

      principalContainer.insertBefore(container, this.loader);

      var editableRegionTextFields = this.editableRegion.textFields;
      var textFieldsWidth = (principalContainer.width)/editableRegionTextFields.length;

      var fontSize = descartesJS.getFieldFontSize(editableRegionHeight);
      // configure the text fields in the region
      for (var i=0, l=editableRegionTextFields.length; i<l; i++) {
        if (editableRegionTextFields[i].type == "div") {
          container.appendChild(editableRegionTextFields[i].container);

          ////////////////////////////////////////////////////////////////
          // the container
          editableRegionTextFields[i].container.setAttribute("style", "font-family:"+ descartesJS.sansserif_font +";width:" + (textFieldsWidth-4) + "px;height:" + (editableRegionHeight) + "px;position:absolute;left:" + ( i*textFieldsWidth ) + "px;top:0;");

          ////////////////////////////////////////////////////////////////
          // the label
          var label = editableRegionTextFields[i].container.firstChild;

          label.setAttribute("style", "font-family:"+ descartesJS.sansserif_font +";font-size:" + fontSize + "px;padding-top:0px;background-color:#e0e4e8;position:absolute;left:0;top:0;height:" + (editableRegionHeight) + "px;text-align:center;line-height:"+ (editableRegionHeight) +"px;");
          var labelWidth = label.offsetWidth;
          label.style.width = labelWidth + "px";

          // remove the first and last character, because are initially underscores
          label.firstChild.textContent = label.firstChild.textContent.substring(3, label.firstChild.textContent.length-3);

          ////////////////////////////////////////////////////////////////
          // the text field
          var textfield = editableRegionTextFields[i].container.lastChild;
          textfield.setAttribute("style", "font-family:"+ descartesJS.monospace_font +";font-size:" + fontSize + "px;width:" + (textFieldsWidth-labelWidth) + "px;height:" + (editableRegionHeight) + "px;position:absolute;left:" + (labelWidth) + "px;top:0;border:2px groove white;");
        }

        else {
          container.appendChild(editableRegionTextFields[i]);

          editableRegionTextFields[i].setAttribute("style", "font-family:"+ descartesJS.monospace_font +";font-size:" + fontSize + "px;width:" + (textFieldsWidth) + "px;height:" + (editableRegionHeight) + "px;position:absolute;left:" + ( i*textFieldsWidth ) + "px;top:0;border:2px groove white;");
        }
      }
    }

    this.displaceRegionNorth = northRegionHeight;
    this.displaceRegionSouth = southRegionHeight;

    this.displaceRegionEast = eastRegionWidth;
    this.displaceRegionWest = westRegionWidth;

    for (var i=0, l=this.spaces.length; i<l; i++) {
      this.spaces[i].init()
    }
  }

  /**
   * Update the applet
   */
  descartesJS.DescartesApp.prototype.update = function() {
    this.updateAuxiliaries();
    this.updateControls();
    this.updateEvents();
    this.updateControls();
    this.updateSpaces();
  }

  /**
   * Change the click to 0
   */
  descartesJS.DescartesApp.prototype.clearClick = function() {
    for (var i=0, l=this.spaces.length; i<l; i++) {
      this.spaces[i].clearClick()
    }
  }

  /** */
  descartesJS.DescartesApp.prototype.removeButtonClick = function() {
    descartesJS.newBlobContent = null;
    for (var i=0, l=this.controls.length; i<l; i++) {
      this.controls[i].buttonClick = false;
    }
  }

  /**
   * Deactivate the graphic controls
   */
  descartesJS.DescartesApp.prototype.deactivateGraphiControls = function() {
    var controls_i;
    for (var i=0, l=this.controls.length; i<l; i++) {
      controls_i = this.controls[i];
      if (controls_i.type == "graphic") {
        controls_i.deactivate();
      }
    }
  }

  /**
   * Update the auxiliaries
   */
  descartesJS.DescartesApp.prototype.updateAuxiliaries = function() {
    for (var i=0, l=this.auxiliaries.length; i<l; i++) {
      this.auxiliaries[i].update();
    }
  }

  /**
   * Update the events
   */
  descartesJS.DescartesApp.prototype.updateEvents = function() {
    for (var i=0, l=this.events.length; i<l; i++) {
      this.events[i].update();
    }
  }

  /**
   * Update the controls
   */
  descartesJS.DescartesApp.prototype.updateControls = function() {
    for (var i=0, l=this.controls.length; i<l; i++) {
      this.controls[i].update();
    }
  }

  /**
   * Update the spaces
   */
  descartesJS.DescartesApp.prototype.updateSpaces = function(firstime) {
    for (var i=0, l=this.spaces.length; i<l; i++) {
      this.spaces[i].update(firstime);
    }
  }

  /**
   * Clear the trace in the space
   */
  descartesJS.DescartesApp.prototype.clear = function() {
    for (var i=0, l=this.spaces.length; i<l; i++) {
      this.spaces[i].spaceChange = true;

      if (this.spaces[i].drawBackground) {
        this.spaces[i].drawBackground();
      }
    }
  }

  /**
   * Play the animation
   */
  descartesJS.DescartesApp.prototype.play = function() {
    this.animation.play();
  }

  /**
   * Stop the animation
   */
  descartesJS.DescartesApp.prototype.stop = function() {
    this.animation.stop();
  }

  /**
   * Reinit the animation
   */
  descartesJS.DescartesApp.prototype.reinitAnimation = function() {
    this.animation.reinit();
  }

  /**
   * Stop the playing audios
   */
  descartesJS.DescartesApp.prototype.stopAudios = function() {
    // stop the animation
    this.stop()

    // stop the audios
    for (var propName in this.audios) {
      if ((this.audios).hasOwnProperty(propName)) {
        if (this.audios[propName].pause) {
          this.audios[propName].pause();
          this.audios[propName].currentTime = 0;
        }
      }
    }
  }

  /**
   * Get an image by name
   * @param {String} name the name of the image
   * @return {Image} the image with the name
   */
  descartesJS.DescartesApp.prototype.getImage = function(name) {
    var images = this.images;
    if (name) {
      // if the image exist return that image
      if (images[name]) {
        return images[name];
      }
      // if do not exist then create a new image
      else {
        images[name] = new Image();
        images[name].addEventListener('load', function() { this.ready = 1; });
        images[name].addEventListener('error', function() { this.ready = 0; this.errorload = 1; });
        images[name].src = name;

        return images[name];
      }
    }

    return new Image();
  }

  /**
   * Get an audio by name
   * @param {String} name the name of the audio
   * @return {Audio} the audio with the name
   */
  descartesJS.DescartesApp.prototype.getAudio = function(name) {
    var audios = this.audios;
    if (name) {
      // if the audio exist return that audio
      if (audios[name]) {
        return audios[name];
      }
      // if do not exist then create a new audio
      else {
        var lastIndexOfDot = name.lastIndexOf(".");
        lastIndexOfDot = (lastIndexOfDot === -1) ? name.lenght : lastIndexOfDot;
        var namename = name.substring(0, lastIndexOfDot);

        audios[name] = new Audio(name);

        var onCanPlayThrough = function(evt) {
          this.ready = 1;
        }
        audios[name].addEventListener('canplaythrough', onCanPlayThrough);

        var onError = function(evt) {
          if (!this.canPlayType("audio/" + name.substring(name.length-3)) && (name.substring(name.length-3) == "mp3")) {
            audios[name] = new Audio(name.replace("mp3", "ogg"));
            audios[name].addEventListener('canplaythrough', onCanPlayThrough);
            audios[name].addEventListener('load', onCanPlayThrough);
            audios[name].addEventListener('error', onError);
            audios[name].load();
          } else {
            console.log("El archivo '" + name + "' no puede ser reproducido");
            this.errorload = 1;
          }
        }
        audios[name].addEventListener('error', onError);

        audios[name].play();
        descartesJS.setTimeout( function(){ audios[name].pause(); }, 15);

        return audios[name];
      }
    }

    return new Audio();
  }

  /**
   * Get a control by a component identifier
   * @param {String} cID the component identifier of the control
   * @return {Control} return a control with a component identifier or a dummy control if not find
   */
  descartesJS.DescartesApp.prototype.getControlByCId = function(cID) {
    return this.getControlById(cID, true);
  }

  /**
   * Get a control by identifier
   * @param {String} id the identifier of the control
   * @return {Control} return a control with identifier or a dummy control if not find
   */
  descartesJS.DescartesApp.prototype.getControlById = function(id, cID) {
    var param = (cID) ? "cID" : "id";
    var controls_i;
    for (var i=0, l=this.controls.length; i<l; i++) {
      controls_i = this.controls[i];
      if (controls_i[param] == id) {
        return controls_i;
      }
    }

    return { update: function() {}, w: 0, h: 0 };
  }

  /**
   * Get a space by a component identifier
   * @param {String} cId the component identifier of the space
   * @return {Space} return a space with the component identifier or a dummy space if not find
   */
  descartesJS.DescartesApp.prototype.getSpaceByCId = function(cID) {
    return this.getSpaceById(cID, true);
  }

  /**
   * Get a space by identifier
   * @param {String} cId the identifier of the space
   * @return {Space} return a space with the identifier or a dummy space if not find
   */
  descartesJS.DescartesApp.prototype.getSpaceById = function(id, cID) {
    var param = (cID) ? "cID" : "id";
    var spaces_i;
    for (var i=0, l=this.spaces.length; i<l; i++) {
      spaces_i = this.spaces[i];
      if (spaces_i[param] == id) {
        return spaces_i;
      }
    }

    return { update: function() {}, w: 0, h: 0 };
  }

  /**
   * Get the parameters in the URL an set the values in the URL object
   * ex. index.html?var1=0&var2=hi, creates URL.var1=0 y URL.var2='hi' 
   */
  descartesJS.DescartesApp.prototype.getURLParameters = function() {
    var url = window.location.href;
    var indexParams = url.indexOf("?");
    var tmpParam;

    if (indexParams != -1) {
      url = decodeURIComponent(url.substring(indexParams+1)).split("&");
      for (var i=0, l=url.length; i<l; i++) {
        tmpParam = url[i].split("=");

        if (tmpParam.length == 2) {
          // is number
          if (+tmpParam[1] == +tmpParam[1]) {
            tmpParam[1] = parseFloat(tmpParam[1]);
          }
          this.evaluator.setVariable("URL." + tmpParam[0], tmpParam[1]);
        }
      }
    }
  }

  /**
   * Get a string representation of an array
   * @param {Array} array the array to get the string representation
   * @return {String} return a string representing the array
   */
  function arrayToString(array) {
    var result = "[";

    for (var i=0, l=array.length; i<l; i++) {
      // nested array
      if (array[i] instanceof Array) {
        result += arrayToString(array[i]);
      }
      // value
      else {
        tmpVal = array[i];
        if ( (typeof(tmpVal) == "undefined") || (!tmpVal)) {
          tmpVal = 0;
        }

        if (typeof(tmpVal) == "string") {
          tmpVal = "'" + tmpVal + "'";
        }

        result += tmpVal;
      }

      // add commas to the string
      if (i<l-1) {
        result += ",";
      }
    }

    return result + "]"
  }

  /**
   * Get the state of the applet
   * @return {String} return a string with the variables, vectors and matrices separate with commas
   */
  descartesJS.DescartesApp.prototype.getState = function() {
    var theValues;
    var state = "";

    var theVariables = this.evaluator.variables;
    // check all the variables
    for (var varName in theVariables) {
      if (theVariables.hasOwnProperty(varName)) {
        theValues = theVariables[varName];

        // if the value is a string, we must ensure that it does not lose the single quotes
        if (typeof(theValues) == "string") {
          theValues = "'" + theValues + "'";
        }

        // if the name of the variable is the name of an internal variable or is an object, then ignore it
        if ( (theValues != undefined) && (varName != "rnd") && (varName != "pi") && (varName != "e") && (varName != "Infinity") && (varName != "-Infinity") && (typeof(theValues) != "object") ) {

          state = (state != "") ? (state + "\n" + varName + "=" + theValues) : (varName + "=" + theValues);
        }
      }
    }

    var theVectors = this.evaluator.vectors;
    // check all the vectors
    for (var vecName in theVectors) {
      if (theVectors.hasOwnProperty(vecName)) {
        theValues = theVectors[vecName];

        state = state + "\n" + vecName + "=" + arrayToString(theValues);
      }
    }

    var theMatrices = this.evaluator.matrices;
    // check all the matrices
    for (var matName in theMatrices) {
      if (theMatrices.hasOwnProperty(matName)) {
        theValues = theMatrices[matName];

        state = state + "\n" + matName + "=" + arrayToString(theValues);
      }
    }

    // return the values in the form variable1=value1\nvariable2=value2\n...\nvariableN=valueN
    return state;
  }

  /**
   * Set the state of the applet
   * @param {String} state string containing the values to set of the form variable1=value1\nvariable2=value2\n...\nvariableN=valueN
   */
  descartesJS.DescartesApp.prototype.setState = function(state, noUpdate) {
    var theState = state.split("\n");

    var tmpParse;
    var value;

    for (var i=0, l=theState.length; i<l; i++) {
      tmpParse = theState[i].split("=");

      // the text is of the type variable=value
      if (tmpParse.length >= 2) {
        value = eval(tmpParse[1]);

        // the value of a matrix
        if (tmpParse[1].indexOf("[[") != -1) {
          this.evaluator.matrices[tmpParse[0]] = value;
          this.evaluator.matrices[tmpParse[0]].rows = value.length;
          this.evaluator.matrices[tmpParse[0]].cols = value[0].length;
        }
        // the value of a vector
        else if (tmpParse[1].indexOf("[") != -1) {
          this.evaluator.vectors[tmpParse[0]] = value;
          this.evaluator.variables[tmpParse[0] + ".long"] = value.length;
        }
        // the vale of a variable
        else {
          this.evaluator.variables[tmpParse[0]] = value;
        }
      }
    }

    if (!noUpdate) {
      // update the lesson
      this.update();
    }
  }

  /**
   * Get the evaluation of the lesson
   * @return {String} return a string of the form: questions=something \n correct=something \n wrong=something \n control1=respuestaAlumno|0 o 1 \n control2=respuestaAlumno|0 o 1
   */
  descartesJS.DescartesApp.prototype.getEvaluation = function() {
    var questions = 0;
    var correct = 0;

    var answers = "";

    for (var i=0, l=this.controls.length; i<l; i++) {
      if ( (this.controls[i].gui == "textfield") && (this.controls[i].evaluate) ) {
        questions++;
        correct += this.controls[i].ok;
        this.controls[i].value = (this.controls[i].value == "") ? "''" : this.controls[i].value;
        answers += (" \\n " + this.controls[i].id + "=" + this.controls[i].value + "|" + this.controls[i].ok);
      }
    }

    return "questions=" + questions + " \\n correct=" + correct + " \\n wrong=" + (questions-correct) + answers;
  }

  /**
   * Store que values in the text fields in the moment of the execution and show the first element in the answer pattern
   */
  descartesJS.DescartesApp.prototype.showSolution = function() {
    var controls = this.controls;
    for (var i=0, l=controls.length; i<l; i++) {
      if ( (controls[i].gui == "textfield") && (controls[i].evaluate) ) {
        controls[i].changeValue( controls[i].getFirstAnswer() );
      }
    }

    this.update();
  }

  /**
   * Store the values in the text fields in the moment of the execution and show the answer of the student
   */
  descartesJS.DescartesApp.prototype.showAnswer = function() {
    for (var i=0, l=this.saveState.length; i<l; i++){
      this.evaluator.eval( this.saveState[i] );
    }

    this.update();
  }

  /**
   *
   */
  function scaleToFit() {
    scaleToFitX = window.innerWidth/this.width;
    scaleToFitY = window.innerHeight/this.height;

    optimalRatio = Math.min(scaleToFitX, scaleToFitY);
    descartesJS.cssScale = optimalRatio;

    this.container.parentNode.setAttribute("align", "");
    this.container.style.transformOrigin = "0 0";
    if (scaleToFitX < scaleToFitY) {
      this.container.style.left = "0";
      this.container.style.transform = "translate3d(0px, 0px, 0px) scale("+optimalRatio+")";
    }
    else {
      this.container.style.left = "50%";
      this.container.style.transform = "translate3d(0px, 0px, 0px) scale("+optimalRatio+") translate(-50%, 0)";
    }
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  descartesJS.DEBUG = {
    PARENTHESIS_CLOSING: "Faltan paréntesis por cerrar",
    PARENTHESIS_OPENING: "Faltan paréntesis por abrir",
    BRACKET_CLOSING: "Faltan corchetes por cerrar",
    BRACKET_OPENING: "Faltan corchetes por abrir",
    INCOMPLETE_IF: "Condicional incompleta",
    EXPRESSION: "En la expresión",
  };

  descartesJS.DEBUG.setError = function(type, expr) {
    var errStr = "Error: " + type + " en《 " + expr + " 》. ";
    var tmpErr = "";
    var extraErr = "";

    switch(descartesJS.DEBUG.objectName) {
      //////////////////////////////////////////
      case("Auxiliar"):
        if ( (descartesJS.DEBUG.typeName === "event") || (descartesJS.DEBUG.typeName === "algorithm") || (descartesJS.DEBUG.typeName === "constant")) {
          tmpErr = "En el programa ";
        }
        else {
          tmpErr = "En la definición "
        }

        if ( (babel[descartesJS.DEBUG.paramName] == "doExpr") ||
             (babel[descartesJS.DEBUG.paramName] == "init") ) {
          extraErr = " en la línea " + (descartesJS.DEBUG.lineCount+1);
        }

        errStr += tmpErr + "「" +descartesJS.DEBUG.idName + "」, en el paramétro 「" + descartesJS.DEBUG.paramName + "」" + extraErr + ".";
        break;

      //////////////////////////////////////////
      case("Graphic"):
        errStr += "En el gráfico #" + (descartesJS.DEBUG.elemIndex+1) + " de tipo 「" +descartesJS.DEBUG.idName + "」, en el paramétro 「" + descartesJS.DEBUG.paramName + "」.";
        break;
    }

    console.info(errStr);
  }

  return descartesJS;
})(descartesJS || {});
/**
 * @author Joel Espinosa Longi
 * @licencia LGPL - http://www.gnu.org/licenses/lgpl.html
 */

var descartesJS = (function(descartesJS) {
  if (descartesJS.loadLib) { return descartesJS; }

  /**
   * Array to store the javascript replacements of the java applets
   * type [DescartesApp]
   * @private
   */
  descartesJS.apps = [];

  /**
   * Make the javascript replacements of the java applets
   */
  function makeDescartesApps() {
    var applets = getDescartesApplets();

    // for all descartes applets in the page make a javascript replacement
    for (var i=0, l=applets.length; i<l; i++) {
      descartesJS.apps.push( new descartesJS.DescartesApp(applets[i]) );
      changeClassDescartesJS(applets[i]);
    }
  }

  /**
   * Hide the applets in the page
   */
  function hideApplets() {
    var cssNode = document.getElementById("StyleDescartesApps");

    if (cssNode) {
      (cssNode.parentNode).removeChild(cssNode);
    }

    // create the CSS style to hide the applets
    cssNode = document.createElement("style");
    cssNode.id = "StyleDescartesApps";
    cssNode.type = "text/css";
    cssNode.setAttribute("rel", "stylesheet");
    cssNode.innerHTML = "applet.DescartesJS,applet,ajs.DescartesJS,ajs{display:none;}";

    // add the style in the head of the document
    document.head.appendChild(cssNode);
  }

  /**
   * Show the hidden applets
   */
  function showApplets() {
    document.getElementById("StyleDescartesApps").innerHTML = "applet.DescartesJS,applet,ajs.DescartesJS,ajs{display:block;}";
  }

  /**
   * Shows applets that are not descartes
   */
  function showNoDescartesJSApplets() {
    document.getElementById("StyleDescartesApps").innerHTML = "applet.DescartesJS,applet,ajs.DescartesJS,ajs{display:none;}";
  }

  /**
   * Find and get the descartes applets in the document
   * @return {Array.<applet>} the descartes applets in the document
   */
  function getDescartesApplets() {
    // get all the applets in the document
    var applets = document.querySelectorAll("applet,ajs");
    var descartesRegExp = /Descartes|DescartesJS|descinst.DescartesWeb2_0.class|Arquimedes|Discurso/i;

    // create an array to hold the applets
    var tmpArrayApplets = [];

    for (var i=0, l=applets.length; i<l; i++) {
      if ( descartesRegExp.test(applets[i].getAttribute("code")) ) {
        tmpArrayApplets.push(applets[i]);
      }
    }

    return tmpArrayApplets;
  }

  /**
   * Change the class of an applet to "DescartesJS"
   * @param {<applet>} applet the applet to change the class
   */
  function changeClassDescartesJS(applet) {
    applet.className = "DescartesJS";
  }

  /**
   * Remove extra data included in a previous interpretation
   */
  function removeDescartesAppContainers() {
    // remove elements with "DescartesAppContainer" class
    var toBeRemoved = document.querySelectorAll(".DescartesAppContainer");

    // remove the elements in the toBeRemove array
    for (var i=0, l=toBeRemoved.length; i<l; i++) {
      (toBeRemoved[i].parentNode).removeChild(toBeRemoved[i]);
    }
  }

  /**
   * Get the array of descartes apps, i.e. javascript interpretations of the descartes applets
   * @return {Array.<DescartesApp>}
   */
  descartesJS.getDescartesApps = function() {
    return descartesJS.apps;
  }

  //////////////////////////////////////////////////////////////////////////////////////////////////
  // The following code is executed immediately
  //////////////////////////////////////////////////////////////////////////////////////////////////
  hideApplets();
  //////////////////////////////////////////////////////////////////////////////////////////////////

  /**
   * Function to handle the resize of the browser
   * @param {Event} evt the evt of resize the browser
   */
  descartesJS.onResize = function(evt) {
    // if is adaptative then scale it
    if (descartesJS.apps.length > 0) {
      descartesJS.apps[0].scaleToFit();
    }
  }

  /**
   * Function to handle the load evt of the document
   * @param {Event} evt the evt of load the web page
   */
  function onLoad(evt) {
    var fontDiv = document.createElement("div");
    var str = '<div style="font-size:12px;visibility:hidden;">\n';
    var font_names = ["descartesJS_serif", "descartesJS_sansserif", "descartesJS_monospace", "DJS_symbola", "DJS_extra", "DJS_sansserif", "DJS_serif", "DJS_monospace"];
    for (let i=0,l=font_names.length; i<l; i++) {
      str += '<div style="font-family:'+ font_names[i] +';">\n<span>_</span>\n<span style="font-weight:bold;">_</span>\n<span style="font-style:italic;">_</span>\n<span style="font-weight:bold;font-style:italic;">_</span>\n</div>\n';
    }
    fontDiv.innerHTML = str + '</div>';

    document.body.appendChild(fontDiv);

    // get the features for interpreting descartes applets
    descartesJS.getFeatures();

    // if has support for canvas start the interpretation
    if (descartesJS.hasCanvas) {
      window.scrollTo(0, 10);

      removeDescartesAppContainers();
      makeDescartesApps();

      window.addEventListener("resize", descartesJS.onResize);

      window.scrollTo(0, 0);
    }
    // if has not support for canvas show the applets and do not interpret
    else {
      showApplets();
    }

    document.body.removeChild(fontDiv);
  }

  var applets_cache = {};
  /**
   * Function to handle the message between frames
   * @param {Event} evt the evt of receive a message
   */
  descartesJS.onMessage = function(evt) {
    if (descartesJS.apps.length > 0) {
      var data = evt.data;

      if (!data) { return; }

      // set a value to a variable
      if (data.type === "set") {
        if ((typeof(data.value) == "string") || (typeof(data.value) == "number")) {
          descartesJS.apps[0].evaluator.setVariable(data.name, data.value);
        }
        else {
          if ((data.value) && (data.value.rows != undefined)) {
            descartesJS.apps[0].evaluator.matrices[data.name] = data.value;
          }
          else {
            descartesJS.apps[0].evaluator.vectors[data.name] = data.value;
          }
        }
      }

      // update the scene
      else if (data.type === "update") {
        descartesJS.apps[0].update();
      }

      // execute a function
      else if (data.type === "exec") {
        var fun = descartesJS.apps[0].evaluator.getFunction(data.name);
        if (fun) {
          fun.apply(descartesJS.apps[0].evaluator, (data.value.toString()).split(","));
        }
      }

      else if (data.type === "isResizeNeeded") {
        evt.source.postMessage({ type: "doResize" }, '*');
      }

      else if (data.type === "doResize") {
        if (descartesJS.apps.length > 0) {
          descartesJS.apps[0].adjustSize();
        }
      }

      else if (data.type === "change_config") {
        let new_applets;

        if (applets_cache[data.filename]) {
          new_applets = applets_cache[data.filename];
        }
        else {
          new_applets = document.createElement("div");
          new_applets.innerHTML = data.content;
          applets_cache[data.filename] = new_applets;
        }

        descartesJS.apps[0].children = new_applets.getElementsByTagName("param");
        descartesJS.apps[0].init();
      }
    }
  }

  // if the DescartesJS library is loaded multiple times, prevent the collision of diferent versions
  if (descartesJS.loadLib == undefined) {
    descartesJS.loadLib = true;

    // register the onload event
    window.addEventListener("load", onLoad);

    // register the message event, to handle the messages between frames
    window.addEventListener("message", descartesJS.onMessage);

    // add event listener to transitions of spaces
    var trasitionEvents = ["webkitTransitionEnd", "transitionend", "oTransitionEnd", "MSTransitionEnd"];
    for (var i=0,l=trasitionEvents.length; i<l; i++) {
      window.addEventListener(trasitionEvents[i], function(evt) {
        descartesJS.onResize(evt);
      });
    }
  }

  return descartesJS;
})(descartesJS || {});
